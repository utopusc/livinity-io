---
phase: v1.5-05-skill-marketplace-parallel-execution
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/task-manager.ts
  - nexus/packages/core/src/api.ts
  - nexus/packages/core/src/index.ts
  - nexus/packages/core/src/ws-gateway.ts
  - nexus/packages/core/src/config/schema.ts
autonomous: true

must_haves:
  truths:
    - "User can ask the AI to perform two independent tasks simultaneously and both run in parallel"
    - "User can view the status of running tasks (task ID, status, progress) via API"
    - "User can cancel any running task mid-execution"
    - "Parallel tasks respect concurrency limits and do not exceed resource budget"
    - "Completed/failed tasks have accessible results for retrieval"
  artifacts:
    - path: "nexus/packages/core/src/task-manager.ts"
      provides: "BullMQ-based parallel task manager with status tracking, cancellation, and resource-aware scheduling"
      exports: ["TaskManager", "TaskStatus", "TaskInfo"]
    - path: "nexus/packages/core/src/api.ts"
      provides: "REST API endpoints for task management (submit, list, status, cancel)"
      contains: "/api/tasks"
    - path: "nexus/packages/core/src/ws-gateway.ts"
      provides: "WebSocket methods for parallel task submission and monitoring"
      contains: "task.submit"
    - path: "nexus/packages/core/src/config/schema.ts"
      provides: "TaskManager configuration schema (concurrency, token budgets)"
      contains: "TaskConfigSchema"
  key_links:
    - from: "nexus/packages/core/src/task-manager.ts"
      to: "nexus/packages/core/src/agent.ts"
      via: "Creates AgentLoop instances for each parallel task"
      pattern: "new AgentLoop"
    - from: "nexus/packages/core/src/task-manager.ts"
      to: "bullmq"
      via: "BullMQ Queue and Worker for job processing"
      pattern: "new Queue|new Worker"
    - from: "nexus/packages/core/src/api.ts"
      to: "nexus/packages/core/src/task-manager.ts"
      via: "REST endpoints call TaskManager methods"
      pattern: "taskManager"
    - from: "nexus/packages/core/src/ws-gateway.ts"
      to: "nexus/packages/core/src/task-manager.ts"
      via: "WebSocket method handlers call TaskManager"
      pattern: "taskManager"
---

<objective>
Implement BullMQ-based parallel agent task execution with status monitoring, cancellation, and resource-aware scheduling. Add both REST API and WebSocket methods for task management.

Purpose: Allow the AI agent (and external clients) to run multiple independent tasks in parallel. This is critical for efficiency — "scan Docker containers AND check disk usage" should run concurrently, not sequentially. Task status monitoring and cancellation give users control over long-running operations.

Output: TaskManager class with BullMQ integration, REST API endpoints under /api/tasks, WebSocket methods (task.submit, task.status, task.cancel, task.list), and config schema extension.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@nexus/packages/core/src/agent.ts
@nexus/packages/core/src/index.ts
@nexus/packages/core/src/ws-gateway.ts
@nexus/packages/core/src/config/schema.ts
@nexus/packages/core/src/daemon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskManager with BullMQ parallel execution, cancellation, and resource scheduling</name>
  <files>nexus/packages/core/src/task-manager.ts, nexus/packages/core/src/config/schema.ts</files>
  <action>
**Update `nexus/packages/core/src/config/schema.ts`:**

Add a new TaskConfigSchema before the main NexusConfigSchema:

```typescript
export const TaskConfigSchema = z.object({
  /** Maximum concurrent parallel tasks */
  maxConcurrent: z.number().int().min(1).max(20).default(4),
  /** Per-task token budget (total input+output tokens) */
  perTaskTokenBudget: z.number().int().min(10000).max(500000).default(100000),
  /** Per-task max turns */
  perTaskMaxTurns: z.number().int().min(1).max(50).default(15),
  /** Per-task timeout in ms */
  perTaskTimeoutMs: z.number().int().min(10000).max(600000).default(300000),
  /** How long to keep completed task results in Redis (seconds) */
  resultTtlSec: z.number().int().min(60).max(86400).default(3600),
}).strict().optional();
```

Add `tasks: TaskConfigSchema` to `NexusConfigSchema` (after `approval`).
Add default values to `DEFAULT_NEXUS_CONFIG`:
```typescript
tasks: {
  maxConcurrent: 4,
  perTaskTokenBudget: 100000,
  perTaskMaxTurns: 15,
  perTaskTimeoutMs: 300000,
  resultTtlSec: 3600,
},
```

Export `TaskConfig` type.

**Create `nexus/packages/core/src/task-manager.ts`:**

```typescript
export type TaskStatus = 'queued' | 'running' | 'completed' | 'failed' | 'cancelled';

export interface TaskInfo {
  id: string;               // BullMQ job ID (UUID)
  task: string;             // Task description
  status: TaskStatus;
  createdAt: number;        // Unix timestamp ms
  startedAt?: number;
  completedAt?: number;
  progress?: string;        // Last progress message
  result?: {
    success: boolean;
    answer: string;
    turns: number;
    totalInputTokens: number;
    totalOutputTokens: number;
    stoppedReason: string;
  };
  error?: string;
  sessionId?: string;       // For WebSocket routing of events
  tier?: string;            // Model tier used
}

export interface SubmitTaskOptions {
  task: string;
  tier?: 'flash' | 'haiku' | 'sonnet' | 'opus';
  maxTurns?: number;
  maxTokens?: number;
  timeoutMs?: number;
  sessionId?: string;       // For WebSocket event routing
}
```

Class: `TaskManager`

Constructor: `constructor(opts: { brain: Brain; toolRegistry: ToolRegistry; redis: Redis; nexusConfig?: NexusConfig; approvalManager?: ApprovalManager })`

Initialization in constructor:
1. Create a BullMQ Queue named `'nexus-parallel-tasks'` with the same Redis connection pattern as the existing memory extraction queue in index.ts (extract `bullConnection` from redis options).
2. Create a BullMQ Worker for `'nexus-parallel-tasks'` with a concurrency limit from `nexusConfig.tasks.maxConcurrent` (default 4).
3. The worker processor function:
   - Extract task data from `job.data` (SubmitTaskOptions).
   - Store task status in Redis: `nexus:tasks:{jobId}` as JSON TaskInfo with status 'running'.
   - Create an AgentLoop instance with the task's parameters, using the brain, toolRegistry, and approval settings from the constructor opts. Pass `nexusConfig` for agent defaults.
   - Wire the AgentLoop's event emitter to update progress in Redis (on 'event', update `nexus:tasks:{jobId}` with latest event info).
   - Also publish AgentLoop events to Redis pub/sub channel `nexus:notify:task:{jobId}` so WebSocket clients get real-time updates.
   - Await `agent.run(task)`.
   - On completion: update Redis task info with status 'completed' and result. Set TTL on the Redis key (resultTtlSec from config).
   - On error: update Redis task info with status 'failed' and error message.
   - **Cancellation**: Before each agent turn, check Redis key `nexus:tasks:{jobId}:cancel`. If set, throw a cancellation error. The AgentLoop doesn't have native AbortController support (per Phase 4 decision), so use the same status flag pattern: set a flag that the worker checks between turns. Since we can't inject into AgentLoop's turn loop directly, use a wrapper approach: set `session.status = 'cancelled'` in the task metadata and check it in the agent's onAction callback. If cancelled, the agent won't be interrupted mid-tool-call, but will stop before the next turn by having the worker throw after the current turn completes.
   - Actually, since we own the worker and can set short turn timeouts, the pragmatic approach is: store a cancel flag in Redis, and in the worker's event listener, if cancel flag is detected, mark the job as failed with "Task cancelled". The AgentLoop will naturally stop when the worker function returns/throws.

Methods:
- `async submit(options: SubmitTaskOptions): Promise<string>` - Add a job to the BullMQ queue. Store initial TaskInfo in Redis with status 'queued'. Return the job ID (use randomUUID).
- `async getStatus(taskId: string): Promise<TaskInfo | null>` - Read from Redis `nexus:tasks:{taskId}`.
- `async listTasks(filter?: { status?: TaskStatus }): Promise<TaskInfo[]>` - Scan Redis keys `nexus:tasks:*` (use SCAN, not KEYS for safety). Optionally filter by status. Sort by createdAt descending. Limit to most recent 50.
- `async cancel(taskId: string): Promise<boolean>` - Set Redis key `nexus:tasks:{taskId}:cancel` to '1' with 60s TTL. Update task status to 'cancelled'. Return true if task existed and was running.
- `async cleanup(): Promise<void>` - Close queue and worker (for shutdown).

Resource-aware scheduling: The BullMQ worker concurrency parameter directly controls how many tasks run in parallel. The per-task token budget and max turns constrain individual task resource usage. No additional scheduling logic needed — BullMQ handles the queue.

Import: Brain from './brain.js', ToolRegistry from './tool-registry.js', AgentLoop from './agent.js', ApprovalManager from './approval-manager.js', NexusConfig from './config/schema.js', logger from './logger.js', Queue/Worker from 'bullmq', Redis from 'ioredis', randomUUID from 'node:crypto'.
  </action>
  <verify>
Run: `cd nexus && npx tsc --noEmit --project packages/core/tsconfig.json 2>&1 | head -20`
Expect: No type errors. TaskManager compiles cleanly. Config schema includes tasks field.
  </verify>
  <done>
TaskManager class exists with BullMQ queue/worker for parallel agent execution. Tasks can be submitted, monitored, and cancelled. Worker respects concurrency limits from config. Task status is persisted in Redis with TTL. Cancel uses Redis flag that worker checks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add REST API endpoints, WebSocket methods, and wire TaskManager into Nexus</name>
  <files>nexus/packages/core/src/api.ts, nexus/packages/core/src/ws-gateway.ts, nexus/packages/core/src/index.ts</files>
  <action>
**Update `nexus/packages/core/src/api.ts`:**

Add TaskManager to ApiDeps:
```typescript
taskManager?: TaskManager;
```

Add REST API endpoints under `/api/tasks` (after existing skill routes, all protected by requireApiKey):

1. `POST /api/tasks` - Submit a new parallel task.
   - Body: `{ task: string, tier?: string, maxTurns?: number, timeoutMs?: number }`
   - Response: `{ taskId: string, status: 'queued' }`
   - Calls `taskManager.submit(body)`

2. `GET /api/tasks` - List all tasks.
   - Query params: `?status=running` (optional filter)
   - Response: `{ tasks: TaskInfo[] }`
   - Calls `taskManager.listTasks({ status })`

3. `GET /api/tasks/:id` - Get status of a specific task.
   - Response: TaskInfo object or 404
   - Calls `taskManager.getStatus(id)`

4. `POST /api/tasks/:id/cancel` - Cancel a running task.
   - Response: `{ cancelled: boolean }`
   - Calls `taskManager.cancel(id)`

**Update `nexus/packages/core/src/ws-gateway.ts`:**

Add TaskManager to WsGatewayDeps:
```typescript
taskManager?: TaskManager;
```

Add three new method handlers in the switch statement (after 'notify.unsubscribe'):

1. `task.submit` - Submit a parallel task via WebSocket.
   - Params: `{ task: string, tier?: string, maxTurns?: number }`
   - Calls `taskManager.submit(params)` and sends the taskId as result.
   - Subscribe the client to task notifications by adding `task:{taskId}` to their notifyFilter.

2. `task.status` - Get task status.
   - Params: `{ taskId: string }`
   - Calls `taskManager.getStatus(taskId)` and sends result.

3. `task.list` - List all tasks.
   - Params: `{ status?: string }` (optional filter)
   - Calls `taskManager.listTasks(params)` and sends result.

4. `task.cancel` - Cancel a task.
   - Params: `{ taskId: string }`
   - Calls `taskManager.cancel(taskId)` and sends result.

Pass `taskManager` through the WsGateway constructor deps. Access it as `this.deps.taskManager` in the handlers. If taskManager is not available, return RPC_INTERNAL_ERROR with "Task system not configured".

**Update `nexus/packages/core/src/index.ts`:**

After the ApprovalManager initialization (around line 257):

1. Import `TaskManager` from `./task-manager.js`
2. Create the task manager:
   ```typescript
   const taskManager = new TaskManager({
     brain,
     toolRegistry,
     redis,
     nexusConfig: configManager.get(),
     approvalManager,
   });
   logger.info('TaskManager initialized', {
     maxConcurrent: configManager.get().tasks?.maxConcurrent || 4,
   });
   ```
3. Pass `taskManager` to `createApiServer` deps.
4. Pass `taskManager` to `setupWsGateway` deps — update the `setupWsGateway` call to include taskManager. Check how `setupWsGateway` is called and what it accepts. It takes `WsGatewayDeps` which we updated above.
5. Add `await taskManager.cleanup()` to the shutdown handler (before redis.quit()).

The setupWsGateway function in api.ts creates the WsGateway — check its signature and pass taskManager through.
  </action>
  <verify>
Run: `cd nexus && npx tsc --noEmit --project packages/core/tsconfig.json 2>&1 | head -20`
Expect: No type errors. All new endpoints and WebSocket methods compile.
Test with curl: `curl -X POST -H "X-Api-Key: $KEY" -H "Content-Type: application/json" -d '{"task":"ping localhost"}' http://localhost:3200/api/tasks` returns `{"taskId":"...","status":"queued"}`.
Test list: `curl -H "X-Api-Key: $KEY" http://localhost:3200/api/tasks` returns `{"tasks":[...]}`.
  </verify>
  <done>
REST API endpoints for /api/tasks (submit, list, get status, cancel) are functional. WebSocket gateway supports task.submit, task.status, task.list, task.cancel methods. TaskManager is created at Nexus startup and properly shut down on exit. Parallel tasks are processed by BullMQ worker with configurable concurrency. Task events are published to Redis pub/sub for real-time WebSocket notifications.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors in nexus/packages/core
2. Config schema includes tasks configuration (maxConcurrent, perTaskTokenBudget, etc.)
3. TaskManager creates BullMQ queue and worker with correct concurrency
4. REST API: POST /api/tasks submits task, GET /api/tasks lists tasks, GET /api/tasks/:id gets status, POST /api/tasks/:id/cancel cancels
5. WebSocket: task.submit, task.status, task.list, task.cancel methods work
6. Cancel flag in Redis stops task execution before next turn
7. Task results persist in Redis with configurable TTL
8. Existing memory extraction BullMQ pipeline is unaffected
</verification>

<success_criteria>
- Two tasks submitted simultaneously both run in parallel (up to maxConcurrent limit)
- Task status is queryable in real-time (queued, running, completed, failed, cancelled)
- Running tasks can be cancelled and stop within one turn
- Concurrency is configurable via NexusConfig
- Task results are retrievable after completion
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-05-skill-marketplace-parallel-execution/v1.5-05-03-SUMMARY.md`
</output>
