---
phase: v2.0-p02-automation-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["v2.0-02-03"]
files_modified:
  - nexus/packages/core/src/channels/gmail.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/packages/core/src/index.ts
autonomous: true

must_haves:
  truths:
    - "AI agent can call gmail_read tool to read a specific email by ID and see subject, from, to, body, and date"
    - "AI agent can call gmail_reply tool to send a reply to an email thread and the reply appears in the sender's inbox"
    - "AI agent can call gmail_send tool to compose and send a new email to any address"
    - "AI agent can call gmail_search tool with a query and see matching email subjects, senders, and dates"
    - "AI agent can call gmail_archive tool to archive an email (remove from inbox)"
    - "When Gmail OAuth refresh token fails, user receives a notification in Telegram/Discord prompting re-authentication"
  artifacts:
    - path: "nexus/packages/core/src/daemon.ts"
      provides: "gmail_read, gmail_reply, gmail_send, gmail_search, gmail_archive MCP tools"
      contains: "gmail_read"
    - path: "nexus/packages/core/src/channels/gmail.ts"
      provides: "readEmail, sendReply, sendEmail, searchEmails, archiveEmail helper methods + token failure alerting"
      contains: "readEmail"
  key_links:
    - from: "nexus/packages/core/src/daemon.ts"
      to: "nexus/packages/core/src/channels/gmail.ts"
      via: "MCP tools call GmailProvider helper methods"
      pattern: "gmailProvider\\.readEmail|gmailProvider\\.sendReply"
    - from: "nexus/packages/core/src/channels/gmail.ts"
      to: "googleapis"
      via: "gmail.users.messages.send and gmail.users.messages.modify"
      pattern: "gmail\\.users\\.messages\\.(send|modify|get)"
---

<objective>
Add Gmail MCP tools for the AI agent: read, reply, send, search, and archive emails. Also implement token refresh failure detection with user notifications via Telegram/Discord.

Purpose: The AI agent needs to fully interact with Gmail — not just receive emails (Plan 03), but also reply, compose, search, and manage them. Token failure alerting ensures the user is aware when re-authentication is needed.

Output: 5 Gmail MCP tools, GmailProvider helper methods, token failure notification system.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v2.0-p02-automation-infrastructure/v2.0-02-03-SUMMARY.md

Key codebase references:
@nexus/packages/core/src/channels/gmail.ts (GmailProvider from Plan 03 — add helper methods here)
@nexus/packages/core/src/daemon.ts (registerTools at line 1135, existing tool patterns; addToInbox)
@nexus/packages/core/src/channels/index.ts (ChannelManager for notification delivery)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gmail helper methods on GmailProvider (read, send, reply, search, archive)</name>
  <files>
    nexus/packages/core/src/channels/gmail.ts
  </files>
  <action>
Add the following public methods to `GmailProvider` class:

**1. `readEmail(messageId: string): Promise<EmailDetail>`**
- Call `gmail.users.messages.get({ userId: 'me', id: messageId, format: 'full' })`.
- Parse headers to extract: subject, from, to, cc, date.
- Extract body: prefer text/plain part, fallback to text/html (strip HTML tags with simple regex), fallback to snippet.
- Return structured `EmailDetail` object.

**2. `sendEmail(to: string, subject: string, body: string): Promise<{ messageId: string }>`**
- Construct RFC 2822 message:
  ```
  From: {user's email from profile}
  To: {to}
  Subject: {subject}
  Content-Type: text/plain; charset=utf-8

  {body}
  ```
- Base64url encode the raw message.
- Call `gmail.users.messages.send({ userId: 'me', requestBody: { raw: encoded } })`.
- Return the sent message ID.

**3. `sendReply(messageId: string, body: string): Promise<{ messageId: string }>`**
- First, fetch the original message to get threadId, subject, and from header.
- Construct reply with `In-Reply-To` and `References` headers set to the original message's Message-ID header.
- Set `Subject: Re: {originalSubject}` (if not already prefixed with "Re:").
- Set `To:` as the original sender's email.
- Call `gmail.users.messages.send({ userId: 'me', requestBody: { raw: encoded, threadId } })`.
- Return sent message ID.

**4. `searchEmails(query: string, maxResults?: number): Promise<EmailSummary[]>`**
- Call `gmail.users.messages.list({ userId: 'me', q: query, maxResults: maxResults || 10 })`.
- For each message ID returned, fetch headers only (format: 'metadata', metadataHeaders: ['Subject', 'From', 'Date']).
- Return array of `EmailSummary` objects: `{ id, subject, from, date, snippet }`.

**5. `archiveEmail(messageId: string): Promise<boolean>`**
- Call `gmail.users.messages.modify({ userId: 'me', id: messageId, requestBody: { removeLabelIds: ['INBOX'] } })`.
- Return true on success.

**6. Update `sendMessage(chatId, text)` implementation:**
- Now that sendEmail works, implement `sendMessage` to call `this.sendEmail(chatId, 'Message from LivOS AI', text)`.
- This wires the ChannelProvider interface so the system can send emails through the standard channel mechanism.

**Types to add:**
```typescript
interface EmailDetail {
  id: string;
  threadId: string;
  subject: string;
  from: string;
  to: string;
  cc?: string;
  date: string;
  body: string;
  snippet: string;
  labels: string[];
}

interface EmailSummary {
  id: string;
  subject: string;
  from: string;
  date: string;
  snippet: string;
}
```

**Token Refresh Failure Handling:**
Add a `private async handleTokenRefreshFailure(error: Error)` method:
1. Log the error: `logger.error('Gmail token refresh failed', { error: error.message })`.
2. Update status to disconnected with error message.
3. Store a notification in Redis: `nexus:notifications` list with `{ message: "Gmail authentication expired. Please re-connect Gmail in Settings.", timestamp: Date.now(), type: "gmail_auth_failure" }`.
4. If `channelManager` is available (pass via constructor or setter), attempt to send notification to all connected channels using the heartbeat delivery pattern from index.ts:
   ```typescript
   for (const channel of ['telegram', 'discord'] as const) {
     const lastChatId = await this.redis.get(`nexus:${channel}:last_chat_id`);
     if (lastChatId) {
       await this.channelManager.sendMessage(channel, lastChatId,
         '⚠️ Gmail authentication expired. Please re-connect Gmail in Settings > Gmail.');
     }
   }
   ```
5. Stop the polling interval (disconnect).

Wire this into the OAuth2 client error handling: wrap the `oauth2Client.getAccessToken()` or `oauth2Client.refreshAccessToken()` call in a try-catch, and call `handleTokenRefreshFailure` on auth errors (status 401 or `invalid_grant`).

Also wrap the `poll()` method — if any Gmail API call fails with 401/403/`invalid_grant`, call `handleTokenRefreshFailure`.
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core. Verify gmail.ts has all 5 helper methods (readEmail, sendEmail, sendReply, searchEmails, archiveEmail). Verify token failure handler exists.
  </verify>
  <done>
GmailProvider has readEmail, sendEmail, sendReply, searchEmails, and archiveEmail methods. Token refresh failures trigger notifications to Telegram/Discord and disconnect the provider.
  </done>
</task>

<task type="auto">
  <name>Task 2: Gmail MCP tools registered in daemon</name>
  <files>
    nexus/packages/core/src/daemon.ts
    nexus/packages/core/src/index.ts
  </files>
  <action>
**In daemon.ts:**

Add to DaemonConfig interface:
```typescript
gmailProvider?: any; // GmailProvider from channels
```

Import is not needed since we use `any` type to avoid circular dependency (GmailProvider is in channels/).

In `registerTools()`, add 5 Gmail tools. Check if `this.config.gmailProvider` exists before registering (only register if Gmail is configured):

```typescript
if (this.config.gmailProvider) {
  const gp = this.config.gmailProvider;
  // Register gmail tools...
}
```

**1. gmail_read**
- Parameters: `id` (string, required) — Gmail message ID
- Execute: Call `gp.readEmail(id)`. Return formatted output with subject, from, to, date, and body. If error, return `{ success: false, error: ... }`.

**2. gmail_reply**
- Parameters: `id` (string, required) — Gmail message ID to reply to, `body` (string, required) — reply text
- Execute: Call `gp.sendReply(id, body)`. Return success message with sent message ID.

**3. gmail_send**
- Parameters: `to` (string, required) — recipient email, `subject` (string, required), `body` (string, required)
- Execute: Call `gp.sendEmail(to, subject, body)`. Return success message with sent message ID.

**4. gmail_search**
- Parameters: `query` (string, required) — Gmail search query (e.g., "from:user@example.com subject:invoice"), `max_results` (number, optional, default 10)
- Execute: Call `gp.searchEmails(query, maxResults)`. Return formatted list of results with id, subject, from, date, snippet.

**5. gmail_archive**
- Parameters: `id` (string, required) — Gmail message ID
- Execute: Call `gp.archiveEmail(id)`. Return success/failure message.

Each tool should have clear descriptions explaining what it does and the parameter formats (especially for gmail_search — mention Gmail search operators like `is:unread`, `from:`, `subject:`, `newer_than:`, `has:attachment`).

**In index.ts:**

After GmailProvider configuration, get a reference to the GmailProvider and pass it to the Daemon config:
```typescript
const gmailProvider = channelManager.getProvider('gmail') as any;
```

Add `gmailProvider` to the Daemon constructor call. Also set channelManager on gmailProvider for notification delivery:
```typescript
if (gmailProvider?.setChannelManager) {
  gmailProvider.setChannelManager(channelManager);
}
```

(Add a `setChannelManager(manager: ChannelManager)` method to GmailProvider in gmail.ts for this wiring.)
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core. Search for `gmail_read` in daemon.ts to confirm tool registration. Verify all 5 tools exist: gmail_read, gmail_reply, gmail_send, gmail_search, gmail_archive.
  </verify>
  <done>
Five Gmail MCP tools are registered: gmail_read, gmail_reply, gmail_send, gmail_search, gmail_archive. AI agent can fully interact with Gmail through tool calls. Token refresh failure notifications are delivered to connected Telegram/Discord channels.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in nexus/packages/core
2. Five Gmail tools registered in daemon registerTools()
3. GmailProvider helper methods all implemented (readEmail, sendEmail, sendReply, searchEmails, archiveEmail)
4. Token refresh failure triggers notification to Telegram/Discord
5. sendMessage on GmailProvider sends an email via Gmail API
6. gmailProvider passed to daemon config and wired in index.ts
</verification>

<success_criteria>
- AI agent can read, reply, send, search, and archive emails via MCP tools
- Email replies include proper In-Reply-To and References headers for threading
- Search supports Gmail query operators
- Token refresh failure detection sends notification to connected channels
- Provider disconnects gracefully on auth failure
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p02-automation-infrastructure/v2.0-02-04-SUMMARY.md`
</output>
