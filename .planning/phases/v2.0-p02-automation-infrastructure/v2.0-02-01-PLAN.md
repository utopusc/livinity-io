---
phase: v2.0-p02-automation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/webhook-manager.ts
  - nexus/packages/core/src/api.ts
  - nexus/packages/core/src/index.ts
autonomous: true

must_haves:
  truths:
    - "POST request to /api/webhook/:id with valid HMAC-SHA256 signature returns 200 and queues a BullMQ job"
    - "POST request with invalid or missing HMAC signature returns 401 Unauthorized"
    - "Duplicate deliveries with the same X-Delivery-ID are silently ignored (200 returned, no job queued)"
    - "Webhook payloads over 1MB are rejected with 413 Payload Too Large"
  artifacts:
    - path: "nexus/packages/core/src/webhook-manager.ts"
      provides: "WebhookManager class with HMAC verification, BullMQ job queuing, and Redis dedup"
      min_lines: 80
    - path: "nexus/packages/core/src/api.ts"
      provides: "POST /api/webhook/:id receiver route"
      contains: "/api/webhook/:id"
  key_links:
    - from: "nexus/packages/core/src/api.ts"
      to: "nexus/packages/core/src/webhook-manager.ts"
      via: "webhookManager.handleIncoming()"
      pattern: "webhookManager\\.handleIncoming"
    - from: "nexus/packages/core/src/webhook-manager.ts"
      to: "daemon.addToInbox()"
      via: "BullMQ webhook queue worker processes jobs into daemon inbox"
      pattern: "addToInbox.*webhook"
---

<objective>
Create the webhook receiver infrastructure: Express routes that accept incoming POST requests, verify HMAC-SHA256 signatures, deduplicate by delivery ID, enforce payload size limits, and queue verified payloads as BullMQ jobs that the agent processes.

Purpose: This is the foundational plumbing for Phase 2 automation. External services (GitHub, n8n, custom scripts) need a secure endpoint to trigger AI agent tasks.

Output: WebhookManager class, receiver route in api.ts, BullMQ webhook queue + worker, Redis dedup.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v2.0-p01-stability-security/v2.0-01-01-SUMMARY.md

Key codebase references:
@nexus/packages/core/src/api.ts (existing Express app, webhook/git route at line 160, ApiDeps interface)
@nexus/packages/core/src/daemon.ts (addToInbox method at line 433, DaemonConfig interface, registerTools at line 1135)
@nexus/packages/core/src/index.ts (BullMQ queue patterns at lines 227, 335; initialization flow)
@nexus/packages/core/src/router.ts (Intent source type includes 'webhook')
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebhookManager class with HMAC verification, BullMQ queue, and dedup</name>
  <files>
    nexus/packages/core/src/webhook-manager.ts
    nexus/packages/core/src/index.ts
  </files>
  <action>
Create `nexus/packages/core/src/webhook-manager.ts` with a `WebhookManager` class:

**Constructor:** Takes `{ redis, daemon }` (Redis instance, Daemon reference for addToInbox).

**Redis Schema:**
- `nexus:webhooks:{id}` — HASH with fields: `name`, `secret`, `createdAt`, `lastUsed`, `deliveryCount`
- `nexus:webhooks:index` — SET of all webhook IDs
- `nexus:webhook:dedup:{deliveryId}` — STRING with 24h TTL for dedup (value: "1")

**Methods:**
- `createWebhook(name: string, secret?: string): Promise<{ id: string; secret: string; url: string }>` — Generate UUID for id, generate 32-byte hex secret if not provided, store in Redis HASH + add to index SET. Return the webhook ID, secret, and URL path `/api/webhook/{id}`.
- `getWebhook(id: string): Promise<WebhookRecord | null>` — Fetch HASH from Redis, return null if not found.
- `listWebhooks(): Promise<WebhookRecord[]>` — SMEMBERS on index, pipeline HGETALL for each.
- `deleteWebhook(id: string): Promise<boolean>` — DEL the HASH, SREM from index.
- `verifySignature(id: string, payload: Buffer, signature: string): Promise<boolean>` — Fetch secret from Redis, compute HMAC-SHA256 of payload using `crypto.createHmac('sha256', secret)`, compare with `crypto.timingSafeEqual` against the provided signature (expect format `sha256=<hex>`). Return false if webhook not found or signature mismatch.
- `isDuplicate(deliveryId: string): Promise<boolean>` — Check if `nexus:webhook:dedup:{deliveryId}` exists via Redis GET. If exists, return true. If not, SET with EX 86400 (24h) and return false. Use SET NX pattern for atomic check-and-set.
- `handleIncoming(id: string, payload: Buffer, signature: string, deliveryId?: string): Promise<{ ok: boolean; reason?: string }>` — Orchestrates: verify signature -> check dedup -> increment deliveryCount and lastUsed -> queue BullMQ job. Returns `{ ok: true }` on success, `{ ok: false, reason: '...' }` on failure.

**BullMQ Integration:**
- Create a `Queue` named `nexus-webhooks` in the WebhookManager constructor (same Redis connection pattern as cronQueue in index.ts — use `{ connection: { host, port, password } }` extracted from Redis URL).
- Create a `Worker` for `nexus-webhooks` that processes jobs by calling `daemon.addToInbox(formattedMessage, 'webhook')` where `formattedMessage` includes the webhook name and a JSON summary of the payload (truncated to 2000 chars if needed).

**Types:**
```typescript
interface WebhookRecord {
  id: string;
  name: string;
  secret: string;
  createdAt: string;
  lastUsed: string | null;
  deliveryCount: number;
}
```

In `index.ts`, initialize WebhookManager after daemon creation, pass it to createApiServer via ApiDeps. Add `webhookManager?: WebhookManager` to ApiDeps interface in api.ts (but the actual route wiring is Task 2).

Import pattern: `import { WebhookManager } from './webhook-manager.js';`
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core to verify TypeScript compiles cleanly. Verify webhook-manager.ts exports WebhookManager class. Verify index.ts creates and passes webhookManager to createApiServer.
  </verify>
  <done>
WebhookManager class exists with HMAC verification, BullMQ queue/worker, Redis dedup, and CRUD operations. It is initialized in index.ts and passed to the API server.
  </done>
</task>

<task type="auto">
  <name>Task 2: Webhook receiver Express route with size limit and signature verification</name>
  <files>
    nexus/packages/core/src/api.ts
  </files>
  <action>
In `api.ts`:

1. Add `webhookManager` to the ApiDeps interface destructuring (it's already typed from Task 1).

2. Add the webhook receiver route AFTER the existing `/api/webhook/git` route (around line 167). Use `express.raw()` middleware for this specific route to get the raw body as Buffer for HMAC verification:

```typescript
// ── Dynamic Webhook Receiver ─────────────────────────────────────
app.post('/api/webhook/:id',
  express.raw({ type: '*/*', limit: '1mb' }),
  async (req, res) => {
    if (!webhookManager) {
      return res.status(503).json({ error: 'Webhook system not initialized' });
    }

    const { id } = req.params;
    const signature = (req.headers['x-hub-signature-256'] || req.headers['x-signature-256'] || '') as string;
    const deliveryId = (req.headers['x-delivery-id'] || req.headers['x-github-delivery'] || '') as string;

    // Body is already limited to 1MB by express.raw({ limit: '1mb' })
    const payload = req.body as Buffer;

    const result = await webhookManager.handleIncoming(id, payload, signature, deliveryId || undefined);

    if (result.ok) {
      res.json({ ok: true, message: 'Webhook received and queued' });
    } else {
      const statusMap: Record<string, number> = {
        'not_found': 404,
        'invalid_signature': 401,
        'duplicate': 200, // Return 200 for dupes to prevent retries
      };
      const status = statusMap[result.reason || ''] || 400;
      res.status(status).json({ ok: result.reason === 'duplicate', message: result.reason });
    }
  }
);
```

IMPORTANT: This route must be placed BEFORE the general `app.use(express.json())` middleware applies, OR the express.raw middleware must override it. Since express.json() is already applied at the top of createApiServer, we need to ensure the raw body is captured. The simplest approach: add this route with its own `express.raw()` middleware which will override the parsed body for this specific route. Express allows route-level middleware to override app-level middleware.

Actually, the better approach: the express.json() middleware at the top will parse JSON bodies. For webhook verification, we need the RAW body. The solution is to use `express.json({ verify: (req, res, buf) => { (req as any).rawBody = buf; } })` at the app level, OR add the webhook route before express.json(). The cleanest approach for this specific case:

- Move the dynamic webhook route registration to BEFORE `app.use(express.json())` at the top of createApiServer, with `express.raw({ type: '*/*', limit: '1mb' })` as route-level middleware.
- This ensures the webhook route gets raw Buffer body while all other routes still get parsed JSON.

3. For duplicate deliveries, return HTTP 200 (not 4xx) so external services don't retry. Include `{ ok: true, message: 'duplicate (already processed)' }`.
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core. Verify the route exists by searching for `/api/webhook/:id` in api.ts. Verify express.raw middleware is used on the route.
  </verify>
  <done>
POST /api/webhook/:id route accepts raw body, verifies HMAC-SHA256 signature, deduplicates by delivery ID, and queues verified payloads via WebhookManager. Payloads over 1MB are rejected by Express. Invalid signatures return 401. Duplicates return 200.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in nexus/packages/core
2. WebhookManager class exists with all methods (createWebhook, verifySignature, isDuplicate, handleIncoming, listWebhooks, deleteWebhook)
3. BullMQ webhook queue and worker are created
4. Express route at /api/webhook/:id uses raw body parsing
5. Signature verification uses crypto.timingSafeEqual
6. Dedup uses Redis SET NX with 24h TTL
</verification>

<success_criteria>
- WebhookManager class compiles and exports correctly
- POST /api/webhook/:id route registered in Express
- HMAC-SHA256 signature verification implemented with timing-safe comparison
- BullMQ job queued on valid webhook, processed into daemon inbox
- Duplicate delivery IDs are detected and silently accepted (200)
- Payload size limited to 1MB via Express middleware
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p02-automation-infrastructure/v2.0-02-01-SUMMARY.md`
</output>
