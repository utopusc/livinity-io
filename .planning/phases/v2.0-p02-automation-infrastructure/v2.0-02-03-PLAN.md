---
phase: v2.0-p02-automation-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/channels/gmail.ts
  - nexus/packages/core/src/channels/types.ts
  - nexus/packages/core/src/channels/index.ts
  - nexus/packages/core/src/api.ts
  - nexus/packages/core/src/index.ts
  - livos/packages/livinityd/source/modules/ai/routes.ts
  - livos/packages/ui/src/routes/settings/gmail.tsx
  - livos/packages/ui/src/routes/settings/_components/settings-content.tsx
autonomous: false
user_setup:
  - service: google-cloud
    why: "Gmail API OAuth 2.0 credentials for email integration"
    env_vars:
      - name: GMAIL_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
      - name: GMAIL_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Web application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Add authorized redirect URI: https://{domain}/api/gmail/oauth/callback"
        location: "Google Cloud Console -> Credentials -> Edit OAuth Client"
      - task: "Enable Gmail API"
        location: "Google Cloud Console -> APIs & Services -> Library -> Gmail API -> Enable"

must_haves:
  truths:
    - "User can navigate to Settings > Gmail and initiate OAuth 2.0 flow that redirects to Google consent screen"
    - "After authorizing, user is redirected back and sees 'Connected' status with their Gmail address"
    - "GmailProvider polls for new emails at configurable interval and forwards them to the agent as inbox messages"
    - "If the user disconnects Gmail in Settings, polling stops and OAuth tokens are cleared"
    - "The system stores refresh tokens securely in Redis and refreshes access tokens automatically"
  artifacts:
    - path: "nexus/packages/core/src/channels/gmail.ts"
      provides: "GmailProvider class implementing polling-based email channel"
      min_lines: 150
    - path: "nexus/packages/core/src/api.ts"
      provides: "Gmail OAuth endpoints (start, callback, status, disconnect)"
      contains: "/api/gmail/oauth"
    - path: "livos/packages/ui/src/routes/settings/gmail.tsx"
      provides: "Gmail settings page with OAuth connect/disconnect"
      min_lines: 60
  key_links:
    - from: "nexus/packages/core/src/channels/gmail.ts"
      to: "googleapis"
      via: "gmail.users.messages.list + gmail.users.messages.get for polling"
      pattern: "gmail\\.users\\.messages"
    - from: "nexus/packages/core/src/api.ts"
      to: "nexus/packages/core/src/channels/gmail.ts"
      via: "OAuth callback stores tokens, triggers GmailProvider.connect()"
      pattern: "gmailProvider.*connect|oauth2Client"
    - from: "livos/packages/ui/src/routes/settings/gmail.tsx"
      to: "livos/packages/livinityd/source/modules/ai/routes.ts"
      via: "tRPC proxy for Gmail status and OAuth initiation"
      pattern: "getGmailStatus|startGmailOauth|disconnectGmail"
---

<objective>
Implement Gmail as a channel provider: OAuth 2.0 flow in the Settings UI, GmailProvider that polls for new emails and forwards them to the agent, automatic token refresh, and a Settings page for connecting/disconnecting Gmail.

Purpose: Gmail is the first email channel for LivOS, enabling the AI agent to receive and eventually respond to emails. This plan handles authentication and the inbound email pipeline. Polling mode is used as the default (simpler than Pub/Sub for self-hosted deployments).

Output: GmailProvider class, OAuth flow endpoints, polling worker, Settings Gmail page, tRPC proxies.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v2.0-p01-stability-security/v2.0-01-01-SUMMARY.md (BullMQ patterns)
@.planning/phases/v2.0-p01-stability-security/v2.0-01-02-SUMMARY.md (channel provider patterns, DmPairing wiring)

Key codebase references:
@nexus/packages/core/src/channels/types.ts (ChannelProvider interface, ChannelId type, IncomingMessage)
@nexus/packages/core/src/channels/telegram.ts (reference implementation for ChannelProvider)
@nexus/packages/core/src/channels/index.ts (ChannelManager, provider registration)
@nexus/packages/core/src/index.ts (initialization flow, BullMQ queue patterns)
@nexus/packages/core/src/api.ts (Express route patterns)
@livos/packages/ui/src/routes/settings/dm-pairing.tsx (Settings page UI pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: GmailProvider class and Gmail OAuth API endpoints</name>
  <files>
    nexus/packages/core/src/channels/gmail.ts
    nexus/packages/core/src/channels/types.ts
    nexus/packages/core/src/channels/index.ts
    nexus/packages/core/src/api.ts
    nexus/packages/core/src/index.ts
  </files>
  <action>
**First, install googleapis:**
Run `cd nexus && npm install googleapis` (adds `googleapis` to nexus/packages/core dependencies — or add to the root package.json if that's the pattern, check existing package.json).

Actually, check `nexus/package.json` (root) vs `nexus/packages/core/package.json` for where dependencies go. Add `googleapis` to the correct package.json. The package provides `google.auth.OAuth2` and `google.gmail('v1')`.

**In channels/types.ts:**
Add `'gmail'` to the `ChannelId` type union: `export type ChannelId = 'telegram' | 'discord' | 'slack' | 'matrix' | 'gmail';`

Add Gmail-specific fields to ChannelConfig (optional, backwards-compatible):
```typescript
/** Gmail OAuth client ID */
gmailClientId?: string;
/** Gmail OAuth client secret */
gmailClientSecret?: string;
/** Gmail polling interval in seconds (default 60) */
gmailPollIntervalSec?: number;
```

Add Gmail to CHANNEL_META:
```typescript
gmail: { name: 'Gmail', color: '#EA4335', textLimit: 50000 },
```

**In channels/gmail.ts:**
Create `GmailProvider` implementing `ChannelProvider`:

```typescript
import { google } from 'googleapis';
import type Redis from 'ioredis';
import { logger } from '../logger.js';
import type { ChannelProvider, ChannelConfig, ChannelStatus, IncomingMessage } from './types.js';
import { getRedisPrefix } from './types.js';
```

**Redis Schema:**
- `nexus:gmail:config` — JSON with enabled, gmailClientId, gmailClientSecret, gmailPollIntervalSec
- `nexus:gmail:tokens` — JSON with access_token, refresh_token, expiry_date
- `nexus:gmail:profile` — JSON with email, name
- `nexus:gmail:last_history_id` — STRING: Gmail historyId for incremental polling
- `nexus:gmail:last_poll_message_ids` — SET: message IDs from last poll to avoid re-processing

**Constructor:** No args. Provider is initialized via `init(redis)`.

**Key Methods:**
- `init(redis)`: Store redis reference, load config from Redis.
- `connect()`: Create OAuth2 client from stored config. Load tokens from Redis. If tokens exist, set credentials on OAuth2 client. Start polling interval with `setInterval`. Initial poll fetches messages from last 5 minutes (or since last historyId).
- `disconnect()`: Clear interval. Clear OAuth2 client state. Update status.
- `getStatus()`: Return connected state, email address, last poll time.
- `sendMessage(chatId, text)`: Send email (implemented in Plan 04 — for now return false with log).
- `onMessage(handler)`: Store handler callback. Called during polling when new emails arrive.
- `updateConfig(config)`: Update stored config. Reconnect if needed.
- `testConnection()`: Verify OAuth tokens are valid by calling `gmail.users.getProfile({ userId: 'me' })`.

**Polling Implementation:**
- `private async poll()`:
  1. Use `gmail.users.messages.list({ userId: 'me', q: 'is:unread newer_than:1d', maxResults: 10 })` to get recent unread messages.
  2. Filter out message IDs already in `nexus:gmail:last_poll_message_ids` set.
  3. For new messages, call `gmail.users.messages.get({ userId: 'me', id: msgId, format: 'full' })`.
  4. Extract subject, from, body (prefer text/plain part, fallback to text/html stripped of tags).
  5. Create `IncomingMessage` with `channel: 'gmail'`, `chatId` as sender email, `userId` as sender email, `text` as `"Subject: {subject}\n\n{body}"`.
  6. Call `this.messageHandler(msg)` for each new message.
  7. Update `nexus:gmail:last_poll_message_ids` with current batch (overwrite SET, not accumulate).
  8. Default poll interval: 60 seconds (configurable via `gmailPollIntervalSec`).

**OAuth2 Token Refresh:**
- On OAuth2 client creation, set `oauth2Client.on('tokens', async (tokens) => { ... })` to persist refreshed tokens to Redis automatically.
- Before each poll, check if access token is expired and refresh if needed.

**In channels/index.ts:**
Import and register GmailProvider:
```typescript
import { GmailProvider } from './gmail.js';
```
Add `new GmailProvider()` to the providers array in ChannelManager (follow the pattern of how TelegramProvider and DiscordProvider are registered).

**In api.ts:**
Add OAuth endpoints (do NOT require API key — the OAuth callback comes from Google's redirect):

```
GET  /api/gmail/oauth/start     → Generate OAuth URL with scopes, redirect user
GET  /api/gmail/oauth/callback  → Exchange auth code for tokens, store in Redis, connect provider
GET  /api/gmail/oauth/status    → Return connection status (connected, email, etc.) — requireApiKey
POST /api/gmail/oauth/disconnect → Clear tokens, disconnect provider — requireApiKey
```

**OAuth scopes:** `['https://www.googleapis.com/auth/gmail.readonly', 'https://www.googleapis.com/auth/gmail.send', 'https://www.googleapis.com/auth/gmail.modify']`

The `/start` endpoint generates the auth URL using:
```typescript
const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
const url = oauth2Client.generateAuthUrl({
  access_type: 'offline',
  scope: GMAIL_SCOPES,
  prompt: 'consent', // Force refresh token generation
});
```

The `/callback` endpoint exchanges the code:
```typescript
const { tokens } = await oauth2Client.getToken(code);
// Store tokens in Redis
// Get user profile
// Connect the GmailProvider
```

The redirect URI should be: `https://{domain}/api/gmail/oauth/callback` where domain is read from env `NEXUS_DOMAIN` or `PUBLIC_URL` or constructed from request.

**In index.ts:**
Get the GmailProvider from channelManager after init and set the clientId/clientSecret from environment variables:
```typescript
const gmailClientId = process.env.GMAIL_CLIENT_ID;
const gmailClientSecret = process.env.GMAIL_CLIENT_SECRET;
if (gmailClientId && gmailClientSecret) {
  const gmailProvider = channelManager.getProvider('gmail') as any;
  if (gmailProvider?.updateConfig) {
    await gmailProvider.updateConfig({
      enabled: true,
      gmailClientId,
      gmailClientSecret,
    });
  }
}
```

Also pass the gmailProvider reference to the API server so OAuth endpoints can call connect/disconnect on it. Add `gmailProvider` to ApiDeps.
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core. Verify gmail.ts exports GmailProvider. Verify ChannelId type includes 'gmail'. Verify OAuth endpoints exist in api.ts. Verify googleapis is in package.json dependencies.
  </verify>
  <done>
GmailProvider class implements polling-based email channel. OAuth 2.0 endpoints handle the full authorization flow. Tokens are stored in Redis with automatic refresh. Polling fetches unread emails and forwards them to the agent via messageHandler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Gmail Settings UI with OAuth connect/disconnect</name>
  <files>
    livos/packages/livinityd/source/modules/ai/routes.ts
    livos/packages/ui/src/routes/settings/gmail.tsx
    livos/packages/ui/src/routes/settings/_components/settings-content.tsx
  </files>
  <action>
**In livos/packages/livinityd/source/modules/ai/routes.ts:**

Add tRPC proxy routes for Gmail OAuth (follow existing DM pairing proxy pattern):

```typescript
getGmailStatus: privateProcedure.query(async ({ctx}) => {
  const res = await fetch(`${nexusApiUrl}/api/gmail/oauth/status`, {
    headers: { 'X-Api-Key': apiKey },
  });
  return res.json();
}),

startGmailOauth: privateProcedure.mutation(async ({ctx}) => {
  const res = await fetch(`${nexusApiUrl}/api/gmail/oauth/start`);
  return res.json(); // Returns { url: string } — the OAuth consent screen URL
}),

disconnectGmail: privateProcedure.mutation(async ({ctx}) => {
  const res = await fetch(`${nexusApiUrl}/api/gmail/oauth/disconnect`, {
    method: 'POST',
    headers: { 'X-Api-Key': apiKey },
  });
  return res.json();
}),
```

**In livos/packages/ui/src/routes/settings/gmail.tsx:**

Create Gmail settings page (follow dm-pairing.tsx UI pattern):

**Layout:**
- Title: "Gmail Integration" with subtitle "Connect your Gmail account to receive and send emails through the AI agent"
- Status card at top: Shows connected/disconnected status
  - If connected: Green badge "Connected", email address shown, "Disconnect" button (red, with confirmation dialog)
  - If disconnected: Gray badge "Not Connected", "Connect Gmail" button (blue, primary)
- Configuration card (shown when connected):
  - Polling interval display (e.g., "Checking every 60 seconds")
  - Last poll time (relative, e.g., "Last checked 30 seconds ago")
  - Email count processed (if available from status)

**Connect Flow:**
1. User clicks "Connect Gmail"
2. Call `trpc.ai.startGmailOauth.useMutation()`
3. Open returned URL in a new window/tab: `window.open(data.url, '_blank')`
4. Show "Waiting for authorization..." message with a manual "Check Status" button
5. After OAuth completes (user returns to this page), auto-refresh status with `refetch()`

**Disconnect Flow:**
1. User clicks "Disconnect"
2. Show confirmation dialog: "This will disconnect Gmail and stop email processing. Continue?"
3. On confirm, call `trpc.ai.disconnectGmail.useMutation()`
4. Refetch status

**Setup hint (shown when no OAuth credentials configured):**
If status returns an error indicating missing credentials, show an info card:
"Gmail OAuth credentials not configured. Set GMAIL_CLIENT_ID and GMAIL_CLIENT_SECRET in your environment variables."

Use the same Tailwind + shadcn components as other settings pages (Card, Button, Badge, Dialog).

**In settings-content.tsx:**

Add Gmail menu item in the appropriate section (near Channels — Telegram, Discord area):
- Icon: `TbMail` from `react-icons/tb`
- Label: "Gmail"
- Lazy import: `const GmailSettings = React.lazy(() => import('../gmail'))`
- Wire into sections and content rendering following the exact pattern of DM Security and Usage Dashboard entries.
  </action>
  <verify>
Verify gmail.tsx exists and exports a default component. Verify settings-content.tsx has a Gmail menu item with TbMail icon. Check that tRPC proxy routes exist in ai/routes.ts for Gmail operations.
  </verify>
  <done>
Gmail Settings page shows connection status with connect/disconnect flow. OAuth is initiated from the UI and opens Google consent screen. After authorization, status shows connected with email address. Settings navigation includes Gmail menu item.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Gmail OAuth 2.0 flow and GmailProvider polling implementation</what-built>
  <how-to-verify>
    1. Ensure GMAIL_CLIENT_ID and GMAIL_CLIENT_SECRET environment variables are set (from Google Cloud Console)
    2. Navigate to Settings > Gmail in the LivOS web UI
    3. Click "Connect Gmail" — you should be redirected to Google's OAuth consent screen
    4. Authorize the application — you should be redirected back with "Connected" status
    5. Wait 60 seconds and check if the agent receives any incoming email messages
    6. Click "Disconnect" — status should return to "Not Connected"
  </how-to-verify>
  <resume-signal>Type "approved" if OAuth flow works and emails are received, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in nexus/packages/core
2. GmailProvider class exists and is registered in ChannelManager
3. ChannelId type includes 'gmail'
4. OAuth endpoints (start, callback, status, disconnect) exist in api.ts
5. googleapis package installed
6. Gmail Settings page renders with connect/disconnect
7. tRPC proxy routes work for Gmail operations
8. Polling interval is configurable and defaults to 60 seconds
</verification>

<success_criteria>
- User can initiate OAuth flow from Settings UI
- Google consent screen appears with correct scopes
- After authorization, tokens are stored in Redis
- GmailProvider polls for new emails and forwards to agent
- Token refresh happens automatically via OAuth2 client
- Disconnect clears tokens and stops polling
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p02-automation-infrastructure/v2.0-02-03-SUMMARY.md`
</output>
