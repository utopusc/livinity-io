---
phase: v2.0-p05-live-canvas-livhub
plan: 01
subsystem: canvas-backend
tags: [canvas, redis, mcp-tools, rest-api, trpc]
dependency-graph:
  requires: []
  provides:
    - CanvasManager class with Redis-backed artifact storage
    - canvas_render and canvas_update MCP tools in daemon ToolRegistry
    - REST endpoints for canvas artifact CRUD
    - tRPC proxy routes for frontend canvas artifact access
    - conversationId plumbing from frontend to canvas tools
  affects:
    - v2.0-05-02 (Canvas renderer frontend uses tRPC routes and artifact format)
    - v2.0-05-03 (LivHub may reference canvas artifacts)
tech-stack:
  added: []
  patterns:
    - CanvasManager singleton instantiated in index.ts, passed via DaemonConfig
    - conversationId context set/cleared around SSE agent run lifecycle
    - Redis SCAN for listing artifacts by conversation
key-files:
  created:
    - nexus/packages/core/src/canvas-manager.ts
  modified:
    - nexus/packages/core/src/daemon.ts
    - nexus/packages/core/src/api.ts
    - nexus/packages/core/src/index.ts
    - livos/packages/livinityd/source/modules/ai/routes.ts
    - livos/packages/livinityd/source/modules/ai/index.ts
decisions:
  - "Canvas artifacts stored in Redis with nexus:canvas:{id} key pattern and 2h TTL"
  - "conversationId plumbed from frontend chat() -> SSE request body -> daemon instance state -> canvas_render tool"
  - "tRPC routes proxy to Nexus REST endpoints (consistent with existing pattern)"
  - "Part D (chatStatus canvasArtifactId) skipped per plan â€” frontend polls listCanvasArtifacts instead"
  - "deleteCanvasArtifact tRPC route added beyond plan spec (needed for frontend cleanup)"
metrics:
  duration: 5min
  completed: 2026-02-21
---

# Phase 5 Plan 01: Canvas MCP Tools Summary

Canvas backend infrastructure with Redis-backed artifact storage, MCP tools for AI agent rendering, REST CRUD endpoints, and tRPC proxy routes for the frontend.

## What Was Built

### CanvasManager (canvas-manager.ts)
- `CanvasArtifact` interface: id, type (react|html|svg|mermaid|recharts), title, content, conversationId, version tracking
- `CanvasManager` class with full CRUD: create, get, update, delete, listByConversation
- Redis key pattern `nexus:canvas:{id}` with 7200s (2 hour) TTL
- ID format: `canvas_{8-char-uuid}` (e.g. `canvas_a1b2c3d4`)
- Version incremented on each update, TTL refreshed on update
- SCAN-based listing filtered by conversationId, sorted by updatedAt desc

### MCP Tools (daemon.ts)
- `canvas_render`: Creates a new canvas artifact with type, title, and content. Uses `this.currentCanvasConversationId` for the conversationId tag.
- `canvas_update`: Updates an existing artifact by ID. Increments version.
- Both tools conditionally registered only when `canvasManager` exists in DaemonConfig.

### REST Endpoints (api.ts)
- `GET /api/canvas/:id` - Retrieve single artifact
- `GET /api/canvas?conversationId=X` - List artifacts for a conversation
- `DELETE /api/canvas/:id` - Delete an artifact
- All return 503 if canvasManager not available (graceful degradation)

### tRPC Proxy Routes (routes.ts)
- `getCanvasArtifact` - Proxy to GET /api/canvas/:id
- `listCanvasArtifacts` - Proxy to GET /api/canvas?conversationId=X
- `deleteCanvasArtifact` - Proxy to DELETE /api/canvas/:id

### Wiring (index.ts, api.ts, daemon.ts, ai/index.ts)
- CanvasManager instantiated in index.ts with shared Redis connection
- Passed into DaemonConfig and exposed via `daemon.canvasManager` getter
- conversationId included in AiModule's SSE request body to `/api/agent/stream`
- SSE endpoint sets/clears `daemon.setCanvasConversationId()` around agent execution
- `setCanvasConversationId`/`clearCanvasConversationId` methods on Daemon for lifecycle management

## Decisions Made

1. **Redis storage with 2h TTL**: Canvas artifacts are ephemeral session data. 2 hours gives enough time for a session while auto-cleaning.
2. **conversationId plumbing**: Rather than modifying chatStatus (complex SSE parsing), the conversationId flows from the frontend through the SSE request body to the daemon's instance state, used by canvas_render to tag artifacts.
3. **Frontend polls listCanvasArtifacts**: Instead of piping artifact IDs through chatStatus/SSE events, the frontend will poll the `listCanvasArtifacts` tRPC endpoint alongside its existing chatStatus polling (decided in plan, simpler architecture).
4. **deleteCanvasArtifact added**: Not in original plan, but needed for frontend cleanup operations.

## Deviations from Plan

None - plan executed exactly as written.

## Commits

| Hash | Description |
|------|-------------|
| 8d72d3e | feat(v2.0-05-01): add CanvasManager class with Redis artifact storage |
| b8af1cc | feat(v2.0-05-01): register canvas tools, REST endpoints, tRPC routes |

## Next Phase Readiness

Plan 02 (Canvas Renderer Frontend) can proceed immediately. The tRPC routes `getCanvasArtifact` and `listCanvasArtifacts` are ready for the frontend to poll. The `conversationId` matching between frontend's `activeConversationId` and the backend's stored artifacts is wired through the SSE request body.
