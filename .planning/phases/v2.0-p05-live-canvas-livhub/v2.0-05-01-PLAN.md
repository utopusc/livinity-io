---
phase: v2.0-p05-live-canvas-livhub
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/canvas-manager.ts
  - nexus/packages/core/src/index.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/packages/core/src/api.ts
  - livos/packages/livinityd/source/modules/ai/routes.ts
  - livos/packages/livinityd/source/modules/ai/index.ts
autonomous: true

must_haves:
  truths:
    - "AI agent can call canvas_render MCP tool with HTML content and receive an artifact ID"
    - "AI agent can call canvas_update MCP tool to patch existing artifact content"
    - "Canvas artifacts are stored in Redis with a 2-hour TTL and retrievable by ID"
    - "Frontend can poll for canvas artifacts via tRPC endpoint"
    - "chatStatus includes canvasArtifactId when a canvas artifact is active"
  artifacts:
    - path: "nexus/packages/core/src/canvas-manager.ts"
      provides: "CanvasManager class with create/get/update/list/delete operations"
      exports: ["CanvasManager", "CanvasArtifact"]
    - path: "nexus/packages/core/src/daemon.ts"
      provides: "canvas_render and canvas_update tools registered in ToolRegistry"
      contains: "canvas_render"
    - path: "nexus/packages/core/src/api.ts"
      provides: "REST endpoints for canvas artifact CRUD"
      contains: "/api/canvas"
    - path: "livos/packages/livinityd/source/modules/ai/routes.ts"
      provides: "tRPC proxy routes for canvas artifact retrieval"
      contains: "getCanvasArtifact"
  key_links:
    - from: "nexus/packages/core/src/daemon.ts"
      to: "nexus/packages/core/src/canvas-manager.ts"
      via: "CanvasManager instance passed to registerTools, tools call manager.create/update"
      pattern: "canvasManager\\.(create|update|get)"
    - from: "livos/packages/livinityd/source/modules/ai/routes.ts"
      to: "nexus/packages/core/src/api.ts"
      via: "tRPC proxy route fetches from Nexus /api/canvas/* endpoints"
      pattern: "fetch.*api/canvas"
    - from: "livos/packages/livinityd/source/modules/ai/index.ts"
      to: "chatStatus canvasArtifactId"
      via: "chat method sets canvasArtifactId on chatStatus when canvas_render event received"
      pattern: "canvasArtifactId"
---

<objective>
Create the canvas backend infrastructure: CanvasManager for Redis-backed artifact storage, canvas_render and canvas_update MCP tools in the daemon ToolRegistry, Nexus REST endpoints for CRUD, and tRPC proxy routes for the frontend to retrieve artifacts.

Purpose: This is the foundation for Live Canvas. Without the backend tools and storage, the AI cannot generate visual artifacts and the frontend cannot display them.

Output: CanvasManager class, two new MCP tools (canvas_render, canvas_update), REST endpoints, tRPC routes, and chatStatus extension for canvas artifact tracking.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@nexus/packages/core/src/types.ts
@nexus/packages/core/src/tool-registry.ts
@nexus/packages/core/src/daemon.ts
@nexus/packages/core/src/api.ts
@livos/packages/livinityd/source/modules/ai/routes.ts
@livos/packages/livinityd/source/modules/ai/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CanvasManager class with Redis artifact storage</name>
  <files>nexus/packages/core/src/canvas-manager.ts</files>
  <action>
Create a new file `nexus/packages/core/src/canvas-manager.ts` implementing the CanvasManager class.

**CanvasArtifact interface:**
```typescript
export interface CanvasArtifact {
  id: string;              // UUID, e.g. "canvas_abc123"
  type: 'react' | 'html' | 'svg' | 'mermaid' | 'recharts';
  title: string;           // Human-readable title (e.g. "Docker Dashboard")
  content: string;         // The full source code / HTML / SVG / mermaid content
  conversationId: string;  // Links artifact to a chat conversation
  createdAt: number;       // Unix timestamp ms
  updatedAt: number;       // Unix timestamp ms
  version: number;         // Incremented on each update (starts at 1)
}
```

**CanvasManager class:**
- Constructor takes `{ redis: Redis }` (ioredis, named import)
- Redis key pattern: `nexus:canvas:{id}` storing JSON-stringified CanvasArtifact
- TTL: 7200 seconds (2 hours) — canvas artifacts are ephemeral session data
- Methods:
  - `create(opts: { type, title, content, conversationId }): Promise<CanvasArtifact>` — generates ID as `canvas_${randomUUID().slice(0,8)}`, sets version=1, stores in Redis with TTL
  - `get(id: string): Promise<CanvasArtifact | null>` — retrieves from Redis, returns null if not found
  - `update(id: string, content: string, title?: string): Promise<CanvasArtifact | null>` — increments version, updates content/title/updatedAt, refreshes TTL. Returns null if artifact doesn't exist.
  - `delete(id: string): Promise<boolean>` — deletes key, returns true if existed
  - `listByConversation(conversationId: string): Promise<CanvasArtifact[]>` — scans Redis for `nexus:canvas:*`, filters by conversationId. Note: For small scale (< 100 artifacts), SCAN is fine. Returns sorted by updatedAt desc.

**Import pattern:**
```typescript
import { Redis } from 'ioredis';
import { randomUUID } from 'node:crypto';
import { logger } from './logger.js';
```

Use the existing `logger` from logger.js for info/error messages (consistent with existing patterns in skill-installer.ts, skill-registry-client.ts).
  </action>
  <verify>
Read the file and confirm:
1. CanvasArtifact interface is exported with all fields
2. CanvasManager class has create/get/update/delete/listByConversation methods
3. Redis key pattern uses `nexus:canvas:{id}`
4. TTL is set to 7200 on create and refreshed on update
5. Import uses `import { Redis } from 'ioredis'` (named export, NOT default)
  </verify>
  <done>CanvasManager class exists with full CRUD operations, Redis storage with 2-hour TTL, and proper TypeScript exports</done>
</task>

<task type="auto">
  <name>Task 2: Register canvas_render and canvas_update tools in daemon + wire REST and tRPC</name>
  <files>
    nexus/packages/core/src/daemon.ts
    nexus/packages/core/src/api.ts
    livos/packages/livinityd/source/modules/ai/routes.ts
    livos/packages/livinityd/source/modules/ai/index.ts
  </files>
  <action>
**Part A0: Instantiate CanvasManager in Nexus startup (index.ts)**

In `nexus/packages/core/src/index.ts` (the Nexus entry point), add:

1. Import CanvasManager:
```typescript
import { CanvasManager } from './canvas-manager.js';
```

2. After Redis is connected and before the Daemon is constructed, create the CanvasManager instance:
```typescript
const canvasManager = new CanvasManager({ redis });
```

3. Pass it into the DaemonConfig when constructing the Daemon:
```typescript
// In the DaemonConfig object passed to new Daemon({...}):
canvasManager,
```

4. Also pass `canvasManager` to `createApiServer()` if it needs its own reference (or access via `daemon.canvasManager` getter).

This is CRITICAL — without this wiring, `daemon.canvasManager` returns undefined and all canvas REST endpoints return 503.

**Part A: Update daemon.ts**

1. Import CanvasManager at the top:
```typescript
import { CanvasManager } from './canvas-manager.js';
import type { CanvasArtifact } from './canvas-manager.js';
```

2. Add `canvasManager?: CanvasManager` to the `DaemonConfig` interface.

3. In `registerTools()`, after the existing tool registrations (find the end of registerTools), add two new tools:

**canvas_render tool:**
```typescript
if (this.config.canvasManager) {
  const canvasManager = this.config.canvasManager;

  toolRegistry.register({
    name: 'canvas_render',
    description: 'Render interactive content (React component, HTML, SVG, Mermaid diagram, or Recharts chart) in the Live Canvas panel next to the chat. The content will appear as a split-pane alongside the conversation. Use this when the user asks for visual output like dashboards, charts, diagrams, or interactive UI.',
    parameters: [
      { name: 'type', type: 'string', description: 'Artifact type', required: true, enum: ['react', 'html', 'svg', 'mermaid', 'recharts'] },
      { name: 'title', type: 'string', description: 'Short title for the artifact (e.g. "Docker Dashboard", "Memory Usage Chart")', required: true },
      { name: 'content', type: 'string', description: 'The full source code. For react: a React component using JSX (function App() {...}). For html: complete HTML. For svg: SVG markup. For mermaid: Mermaid diagram definition. For recharts: a React component using Recharts library.', required: true },
    ],
    execute: async (params) => {
      const { type, title, content } = params as { type: string; title: string; content: string };
      if (!type || !title || !content) {
        return { success: false, output: '', error: 'type, title, and content are required' };
      }
      // conversationId MUST match what the frontend uses for activeConversationId
      // In the frontend, activeConversationId comes from the ?conv= query param or is generated as `conv_${Date.now()}`
      // On the backend, this is the requestId or conversationId from the InboxItem
      // The Daemon should set currentCanvasConversationId from the chatStatus conversationId key
      const convId = this.currentCanvasConversationId || 'unknown';
      try {
        const artifact = await canvasManager.create({
          type: type as CanvasArtifact['type'],
          title,
          content,
          conversationId: convId,
        });
        return {
          success: true,
          output: `Canvas artifact "${title}" created (ID: ${artifact.id}, type: ${type}). The user can now see it in the Live Canvas panel.`,
          data: { artifactId: artifact.id, type, title, version: artifact.version },
        };
      } catch (err: any) {
        return { success: false, output: '', error: `Canvas render failed: ${err.message}` };
      }
    },
  });

  toolRegistry.register({
    name: 'canvas_update',
    description: 'Update the content of an existing Live Canvas artifact. Use this to modify a previously rendered artifact (e.g., "add a memory chart to the dashboard"). The artifact ID is returned by canvas_render.',
    parameters: [
      { name: 'artifactId', type: 'string', description: 'The artifact ID from a previous canvas_render call', required: true },
      { name: 'content', type: 'string', description: 'The complete updated source code (replaces the entire content)', required: true },
      { name: 'title', type: 'string', description: 'Optional: update the title', required: false },
    ],
    execute: async (params) => {
      const { artifactId, content, title } = params as { artifactId: string; content: string; title?: string };
      if (!artifactId || !content) {
        return { success: false, output: '', error: 'artifactId and content are required' };
      }
      try {
        const artifact = await canvasManager.update(artifactId, content, title);
        if (!artifact) {
          return { success: false, output: '', error: `Artifact "${artifactId}" not found or expired` };
        }
        return {
          success: true,
          output: `Canvas artifact "${artifact.title}" updated (version ${artifact.version}).`,
          data: { artifactId: artifact.id, version: artifact.version, title: artifact.title },
        };
      } catch (err: any) {
        return { success: false, output: '', error: `Canvas update failed: ${err.message}` };
      }
    },
  });
}
```

4. Add a property to Daemon class to track the current canvas conversation ID:
```typescript
private currentCanvasConversationId: string | undefined;
```

5. In the `processInboxItem` method (or wherever inbox items are processed before calling the agent), set `this.currentCanvasConversationId` from the request. Search for where `addToInbox` is called and where the agent is invoked — the conversationId should be derived from the `requestId` or a dedicated field. If InboxItem doesn't have conversationId, add it as optional:
```typescript
// In InboxItem interface:
conversationId?: string;
```
And set it before the agent runs:
```typescript
this.currentCanvasConversationId = item.conversationId;
```

**Part B: Add REST endpoints in api.ts**

In `api.ts`, after the skill marketplace endpoints, add canvas CRUD endpoints:

```typescript
// ── Canvas API ────────────────────────────────────────────────────────
const canvasManager = daemon?.canvasManager; // or however the daemon exposes it

app.get('/api/canvas/:id', async (req, res) => {
  if (!canvasManager) {
    res.status(503).json({ error: 'Canvas not available' });
    return;
  }
  try {
    const artifact = await canvasManager.get(req.params.id);
    if (!artifact) {
      res.status(404).json({ error: 'Artifact not found' });
      return;
    }
    res.json(artifact);
  } catch (err) {
    res.status(500).json({ error: formatErrorMessage(err) });
  }
});

app.get('/api/canvas', async (req, res) => {
  if (!canvasManager) {
    res.status(503).json({ error: 'Canvas not available' });
    return;
  }
  try {
    const conversationId = req.query.conversationId as string;
    if (!conversationId) {
      res.status(400).json({ error: 'conversationId query param required' });
      return;
    }
    const artifacts = await canvasManager.listByConversation(conversationId);
    res.json({ artifacts });
  } catch (err) {
    res.status(500).json({ error: formatErrorMessage(err) });
  }
});

app.delete('/api/canvas/:id', async (req, res) => {
  if (!canvasManager) {
    res.status(503).json({ error: 'Canvas not available' });
    return;
  }
  try {
    const deleted = await canvasManager.delete(req.params.id);
    res.json({ success: deleted });
  } catch (err) {
    res.status(500).json({ error: formatErrorMessage(err) });
  }
});
```

To expose canvasManager from daemon, add a getter:
```typescript
get canvasManager(): CanvasManager | undefined {
  return this.config.canvasManager;
}
```

**Part C: Add tRPC proxy routes in ai/routes.ts**

In `livos/packages/livinityd/source/modules/ai/routes.ts`, add these routes in the router:

```typescript
/** Get a canvas artifact by ID (proxied from Nexus) */
getCanvasArtifact: privateProcedure
  .input(z.object({ id: z.string().min(1) }))
  .query(async ({ input }) => {
    const nexusUrl = getNexusApiUrl()
    const response = await fetch(`${nexusUrl}/api/canvas/${encodeURIComponent(input.id)}`, {
      headers: process.env.LIV_API_KEY ? { 'X-API-Key': process.env.LIV_API_KEY } : {},
    })
    if (!response.ok) {
      if (response.status === 404) return null
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: `Nexus API error: ${response.status}` })
    }
    return await response.json()
  }),

/** List canvas artifacts for a conversation (proxied from Nexus) */
listCanvasArtifacts: privateProcedure
  .input(z.object({ conversationId: z.string().min(1) }))
  .query(async ({ input }) => {
    const nexusUrl = getNexusApiUrl()
    const response = await fetch(
      `${nexusUrl}/api/canvas?conversationId=${encodeURIComponent(input.conversationId)}`,
      { headers: process.env.LIV_API_KEY ? { 'X-API-Key': process.env.LIV_API_KEY } : {} },
    )
    if (!response.ok) {
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: `Nexus API error: ${response.status}` })
    }
    const data = await response.json() as { artifacts: unknown[] }
    return data.artifacts || []
  }),
```

**Part D: Extend chatStatus in ai/index.ts**

In `livos/packages/livinityd/source/modules/ai/index.ts`:

1. Update the chatStatus type to include an optional `canvasArtifactId`:
```typescript
chatStatus = new Map<string, {
  status: string;
  tool?: string;
  steps?: string[];
  commands?: string[];
  turn?: number;
  canvasArtifactId?: string;
}>()
```

2. In the `chat()` method where SSE events are processed, detect when a `tool_call` event is for `canvas_render` and extract the artifact ID from the tool result. Find where `event.type === 'observation'` is handled. After a canvas_render tool returns successfully, parse the tool result data and set canvasArtifactId:

In the tool_call event handler where it sets chatStatus (around line 341-350), add logic to detect canvas tool results:
```typescript
// After the existing chatStatus.set for tool_call events:
// Check if this is a canvas_render tool call by looking at the observation
if (event.type === 'observation' && isEventData(event.data)) {
  const toolName = formatToolName(event.data.tool || 'unknown');
  // ... existing chatStatus update ...

  // Extract canvas artifact ID from canvas_render results
  if (toolName === 'canvas_render' && event.data.result?.data?.artifactId) {
    const prev = this.chatStatus.get(conversationId);
    if (prev) {
      prev.canvasArtifactId = event.data.result.data.artifactId;
      this.chatStatus.set(conversationId, prev);
    }
  }
}
```

Actually, the observation event data structure might not have `result.data`. Check the SSE event format from the Nexus agent stream. The SSE events come from the `/api/agent/stream` endpoint. The observation event includes tool output. The exact field names depend on the SSE serialization in api.ts. Look at how observations are emitted in sdk-agent-runner.ts and how they flow through the SSE stream.

A safer approach: After the agent completes (at the point where chatStatus is about to be deleted), check if any canvas artifacts were created for this conversation by querying the canvasManager through the Nexus API. But this is complex.

Simpler approach: When the frontend receives the AI response, it checks `trpcReact.ai.listCanvasArtifacts` for the conversation. The frontend polls for canvas artifacts alongside chatStatus polling. This avoids needing to pipe artifact IDs through the SSE stream.

So for Part D, instead of modifying chatStatus, add a new tRPC query that the frontend will poll:
- The `listCanvasArtifacts` tRPC route (already added in Part C) is sufficient.
- The frontend (Plan 02) will poll this endpoint alongside chatStatus to detect when a canvas artifact appears.

SKIP Part D's chatStatus modification. The tRPC `listCanvasArtifacts` route from Part C is the mechanism the frontend uses to detect artifacts.
  </action>
  <verify>
1. Read daemon.ts and confirm canvas_render and canvas_update tools are registered in registerTools()
2. Confirm canvasManager is in DaemonConfig interface
3. Read api.ts and confirm /api/canvas/:id GET, /api/canvas GET, /api/canvas/:id DELETE endpoints exist
4. Read routes.ts and confirm getCanvasArtifact and listCanvasArtifacts tRPC procedures exist
5. Confirm the CanvasManager is exposed via a Daemon getter
  </verify>
  <done>
canvas_render and canvas_update tools are registered, REST endpoints serve artifact CRUD, tRPC proxy routes let the frontend retrieve artifacts, and the conversationId context is passed to canvas tools
  </done>
</task>

</tasks>

<verification>
1. Run TypeScript compilation check: `cd nexus/packages/core && npx tsc --noEmit` (should have no errors related to canvas-manager.ts, daemon.ts, api.ts)
2. Verify canvas_render tool is accessible: Search for "canvas_render" in daemon.ts registerTools()
3. Verify Redis key pattern: Grep for "nexus:canvas:" in canvas-manager.ts
4. Verify tRPC routes: Search for "getCanvasArtifact" in routes.ts
</verification>

<success_criteria>
- CanvasManager class exists with create/get/update/delete/listByConversation methods
- canvas_render and canvas_update tools are registered in the daemon ToolRegistry
- REST endpoints at /api/canvas/* serve artifact CRUD
- tRPC proxy routes (getCanvasArtifact, listCanvasArtifacts) exist
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p05-live-canvas-livhub/v2.0-05-01-SUMMARY.md`
</output>
