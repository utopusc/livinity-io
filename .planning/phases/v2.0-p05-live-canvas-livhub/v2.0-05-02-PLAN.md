---
phase: v2.0-p05-live-canvas-livhub
plan: 02
type: execute
wave: 2
depends_on: ["v2.0-05-01"]
files_modified:
  - livos/packages/ui/src/routes/ai-chat/canvas-panel.tsx
  - livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx
  - livos/packages/ui/src/routes/ai-chat/index.tsx
autonomous: false

must_haves:
  truths:
    - "When the AI renders a canvas artifact, a split-pane appears next to the chat showing the rendered content"
    - "Canvas content runs in a sandboxed iframe that cannot access the parent page's cookies, localStorage, or DOM"
    - "The iframe loads React 18, Babel standalone, and Tailwind CSS from CDN"
    - "Errors inside the iframe are caught and displayed to the user via postMessage"
    - "The canvas panel can be closed by the user and re-opened from the chat"
  artifacts:
    - path: "livos/packages/ui/src/routes/ai-chat/canvas-panel.tsx"
      provides: "CanvasPanel component with split-pane layout, artifact polling, close/open controls"
      exports: ["CanvasPanel"]
    - path: "livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx"
      provides: "CanvasIframe component with sandboxed iframe, srcdoc generation, postMessage handling"
      exports: ["CanvasIframe"]
    - path: "livos/packages/ui/src/routes/ai-chat/index.tsx"
      provides: "Updated AI chat layout with conditional split-pane when canvas artifact exists"
      contains: "CanvasPanel"
  key_links:
    - from: "livos/packages/ui/src/routes/ai-chat/index.tsx"
      to: "livos/packages/ui/src/routes/ai-chat/canvas-panel.tsx"
      via: "lazy-loaded CanvasPanel rendered when canvasArtifact state is set"
      pattern: "CanvasPanel"
    - from: "livos/packages/ui/src/routes/ai-chat/canvas-panel.tsx"
      to: "tRPC listCanvasArtifacts"
      via: "polling for artifacts via trpcReact.ai.listCanvasArtifacts"
      pattern: "listCanvasArtifacts"
    - from: "livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx"
      to: "iframe srcdoc"
      via: "generates srcdoc HTML with CDN scripts, transpiles JSX via Babel standalone"
      pattern: "srcdoc"
---

<objective>
Build the Canvas UI: a split-pane CanvasPanel component that appears alongside the chat when the AI renders a visual artifact, a sandboxed CanvasIframe component that renders content securely via srcdoc, and the integration into the existing AI chat layout.

Purpose: This is the user-facing half of Live Canvas. Without it, canvas artifacts created by the AI have no visual rendering surface.

Output: CanvasPanel split-pane component, CanvasIframe sandboxed renderer, updated AI chat layout with conditional split-pane.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v2.0-p05-live-canvas-livhub/v2.0-05-01-SUMMARY.md

@livos/packages/ui/src/routes/ai-chat/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CanvasIframe sandboxed renderer component</name>
  <files>livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx</files>
  <action>
Create `livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx` — the sandboxed iframe renderer.

**Core concept:** The iframe uses the `srcdoc` attribute (NOT src URL) to inject content. The sandbox attribute is `sandbox="allow-scripts allow-popups"` — NEVER add `allow-same-origin` as this would let the iframe access the parent page's cookies, localStorage, and DOM.

**CanvasIframe component props:**
```typescript
interface CanvasIframeProps {
  content: string;       // Raw source code from the artifact
  type: 'react' | 'html' | 'svg' | 'mermaid' | 'recharts';
  onError?: (error: string) => void;  // Error callback from iframe
  className?: string;
}
```

**CDN URLs (load inside iframe srcdoc):**
```
React 18:       https://unpkg.com/react@18/umd/react.production.min.js
ReactDOM 18:    https://unpkg.com/react-dom@18/umd/react-dom.production.min.js
Babel standalone: https://unpkg.com/@babel/standalone/babel.min.js
Tailwind CSS:   https://cdn.tailwindcss.com
Mermaid:        https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js
Recharts:       https://unpkg.com/recharts@2/umd/Recharts.js
```

**srcdoc generation function — `buildSrcdoc(content: string, type: string): string`:**

For type `html`:
- Return the content directly as srcdoc (it's already complete HTML)
- Prepend Tailwind CSS CDN if not already present

For type `react`:
- Build a complete HTML document with:
  - `<meta charset="utf-8">`, `<meta name="viewport">`
  - Tailwind CSS CDN via `<script src="...tailwindcss">`
  - React 18 UMD + ReactDOM 18 UMD via `<script src="...">`
  - Babel standalone via `<script src="...">`
  - A `<div id="root">` container
  - A `<script type="text/babel">` block that wraps the user's content:
    ```html
    <script type="text/babel">
      ${content}
      // Auto-render: find the first exported function or the App/Main component
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(typeof App !== 'undefined' ? App : (typeof Main !== 'undefined' ? Main : () => React.createElement('div', null, 'No App or Main component found'))));
    </script>
    ```
  - An error boundary script that catches runtime errors and posts them to parent:
    ```html
    <script>
      window.onerror = function(message, source, lineno, colno, error) {
        window.parent.postMessage({ type: 'canvas-error', error: String(message), source: source, line: lineno }, '*');
      };
      window.onunhandledrejection = function(e) {
        window.parent.postMessage({ type: 'canvas-error', error: String(e.reason) }, '*');
      };
    </script>
    ```

For type `svg`:
- Wrap SVG content in minimal HTML: `<html><body style="margin:0;display:flex;justify-content:center;align-items:center;min-height:100vh;background:#0a0a0a">${content}</body></html>`

For type `mermaid`:
- HTML document with Mermaid CDN loaded
- `<pre class="mermaid">${content}</pre>`
- Mermaid init script: `mermaid.initialize({startOnLoad:true, theme:'dark'});`
- Dark background style

For type `recharts`:
- Same as `react` but also include the Recharts UMD bundle
- Destructure Recharts globals in the script so the user's code can reference them:
  ```javascript
  const { LineChart, Line, BarChart, Bar, PieChart, Pie, Cell, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, AreaChart, Area, RadarChart, Radar, PolarGrid, PolarAngleAxis, PolarRadiusAxis } = Recharts;
  ```

**postMessage listener:**
In the CanvasIframe component, add a `useEffect` that listens for `message` events from the iframe:
```typescript
useEffect(() => {
  const handler = (e: MessageEvent) => {
    // We can't check origin because sandbox prevents same-origin
    // Instead, check the message shape
    if (e.data?.type === 'canvas-error' && onError) {
      onError(e.data.error || 'Unknown error');
    }
  };
  window.addEventListener('message', handler);
  return () => window.removeEventListener('message', handler);
}, [onError]);
```

**Render:**
```tsx
<iframe
  srcDoc={srcdoc}
  sandbox="allow-scripts allow-popups"
  title="Canvas Preview"
  className={cn('h-full w-full border-0', className)}
  style={{ colorScheme: 'dark' }}
/>
```

**Important:** The `srcdoc` string must include `<style>body{margin:0;color:#e5e5e5;background:#0a0a0a;font-family:system-ui,sans-serif}</style>` for dark mode consistency.

**Styling note:** Use Tailwind classes from the parent app for the container, but the iframe content uses its own Tailwind instance (loaded via CDN inside srcdoc).
  </action>
  <verify>
1. Read the file and confirm sandbox="allow-scripts allow-popups" (NO allow-same-origin)
2. Confirm srcdoc is used (NOT src URL)
3. Confirm CDN URLs for React 18, Babel, Tailwind, Mermaid, Recharts are present
4. Confirm postMessage error listener exists
5. Confirm buildSrcdoc handles all 5 types: react, html, svg, mermaid, recharts
  </verify>
  <done>CanvasIframe component renders content in a sandboxed iframe with CDN-loaded React/Tailwind/Mermaid/Recharts, and error boundary posts errors to parent via postMessage</done>
</task>

<task type="auto">
  <name>Task 2: Create CanvasPanel split-pane and integrate into AI chat layout</name>
  <files>
    livos/packages/ui/src/routes/ai-chat/canvas-panel.tsx
    livos/packages/ui/src/routes/ai-chat/index.tsx
  </files>
  <action>
**Part A: Create CanvasPanel component**

Create `livos/packages/ui/src/routes/ai-chat/canvas-panel.tsx`:

**CanvasPanel props:**
```typescript
interface CanvasPanelProps {
  artifact: {
    id: string;
    type: string;
    title: string;
    content: string;
    version: number;
  };
  onClose: () => void;
}
```

**Layout:**
- Full height panel with a sticky header bar and the iframe below
- Header contains:
  - Artifact title (text-body font-semibold)
  - Artifact type badge (rounded pill, color-coded: react=blue, html=emerald, svg=amber, mermaid=purple, recharts=cyan)
  - Version badge (v1, v2, etc.)
  - Close button (IconX from @tabler/icons-react)
- Below the header: `<CanvasIframe>` component fills remaining space
- Error display: A collapsible error bar at the bottom that appears when iframe posts an error

**Error handling:**
```typescript
const [error, setError] = useState<string | null>(null);
// Pass setError as onError to CanvasIframe
// Show error bar at bottom with red background, dismiss button
```

**Styling:**
Use existing design tokens — bg-surface-base for the panel, border-border-default for borders, text-text-primary/secondary/tertiary for text hierarchy. Use @tabler/icons-react icons (IconX for close, IconCode for type indicator, IconAlertTriangle for errors).

```tsx
export function CanvasPanel({ artifact, onClose }: CanvasPanelProps) {
  const [error, setError] = useState<string | null>(null);

  return (
    <div className="flex h-full flex-col border-l border-border-default bg-surface-base">
      {/* Header */}
      <div className="flex flex-shrink-0 items-center gap-3 border-b border-border-default px-4 py-3">
        <div className="flex h-7 w-7 items-center justify-center rounded-lg bg-gradient-to-br from-cyan-500/30 to-blue-500/30">
          <IconCode size={14} className="text-cyan-400" />
        </div>
        <div className="min-w-0 flex-1">
          <span className="truncate text-body-sm font-semibold text-text-primary">{artifact.title}</span>
        </div>
        <span className={cn('rounded-radius-sm px-2 py-0.5 text-caption-sm font-medium', typeColorClass(artifact.type))}>
          {artifact.type}
        </span>
        <span className="rounded-radius-sm bg-surface-2 px-1.5 py-0.5 font-mono text-caption-sm text-text-tertiary">
          v{artifact.version}
        </span>
        <button onClick={onClose} className="rounded-radius-sm p-1.5 text-text-tertiary transition-colors hover:bg-surface-2 hover:text-text-primary">
          <IconX size={16} />
        </button>
      </div>

      {/* Canvas iframe */}
      <div className="flex-1 overflow-hidden">
        <CanvasIframe
          content={artifact.content}
          type={artifact.type as any}
          onError={setError}
        />
      </div>

      {/* Error bar */}
      {error && (
        <div className="flex items-start gap-2 border-t border-red-500/20 bg-red-500/10 px-4 py-2">
          <IconAlertTriangle size={14} className="mt-0.5 flex-shrink-0 text-red-400" />
          <span className="flex-1 text-caption text-red-400">{error}</span>
          <button onClick={() => setError(null)} className="text-red-400/60 hover:text-red-400">
            <IconX size={12} />
          </button>
        </div>
      )}
    </div>
  );
}
```

**Helper for type color class:**
```typescript
function typeColorClass(type: string): string {
  switch (type) {
    case 'react': return 'bg-blue-500/15 text-blue-400';
    case 'html': return 'bg-emerald-500/15 text-emerald-400';
    case 'svg': return 'bg-amber-500/15 text-amber-400';
    case 'mermaid': return 'bg-purple-500/15 text-purple-400';
    case 'recharts': return 'bg-cyan-500/15 text-cyan-400';
    default: return 'bg-surface-2 text-text-tertiary';
  }
}
```

**Part B: Integrate CanvasPanel into AI chat layout (index.tsx)**

Modify `livos/packages/ui/src/routes/ai-chat/index.tsx`:

1. Add lazy import at the top:
```typescript
const CanvasPanel = lazy(() => import('./canvas-panel').then(m => ({default: m.CanvasPanel})));
```

2. Add new imports:
```typescript
import { IconCode } from '@tabler/icons-react'  // add to existing import list
```

3. Add state for canvas artifact in the AiChat component:
```typescript
const [canvasArtifact, setCanvasArtifact] = useState<{
  id: string; type: string; title: string; content: string; version: number;
} | null>(null);
const [canvasMinimized, setCanvasMinimized] = useState(false);
```

4. Add a tRPC query to poll for canvas artifacts while loading:
```typescript
const canvasQuery = trpcReact.ai.listCanvasArtifacts.useQuery(
  { conversationId: activeConversationId },
  {
    enabled: isLoading,
    refetchInterval: isLoading ? 1000 : false,
  },
);

// Update canvas artifact when query returns data
useEffect(() => {
  if (canvasQuery.data && Array.isArray(canvasQuery.data) && canvasQuery.data.length > 0) {
    // Take the most recent artifact (first in the list, sorted by updatedAt desc)
    const latest = canvasQuery.data[0] as any;
    setCanvasArtifact({
      id: latest.id,
      type: latest.type,
      title: latest.title,
      content: latest.content,
      version: latest.version,
    });
  }
}, [canvasQuery.data]);
```

5. Also do a one-time fetch when conversation is loaded (for re-opening conversations with canvas):
```typescript
const canvasLoadQuery = trpcReact.ai.listCanvasArtifacts.useQuery(
  { conversationId: activeConversationId },
  {
    enabled: !!searchParams.get('conv') && !isLoading,
    refetchInterval: false,
    staleTime: 30000,
  },
);

useEffect(() => {
  if (canvasLoadQuery.data && Array.isArray(canvasLoadQuery.data) && canvasLoadQuery.data.length > 0) {
    const latest = canvasLoadQuery.data[0] as any;
    setCanvasArtifact({
      id: latest.id,
      type: latest.type,
      title: latest.title,
      content: latest.content,
      version: latest.version,
    });
  }
}, [canvasLoadQuery.data]);
```

6. Clear canvas when creating a new conversation:
```typescript
// In handleNewConversation():
setCanvasArtifact(null);
setCanvasMinimized(false);
```

7. Modify the layout to show split-pane when canvas artifact exists. The current layout is:
```
<div className='flex h-full overflow-hidden'>
  {sidebar}
  {chat area (flex-1)}
</div>
```

Change it to:
```
<div className='flex h-full overflow-hidden'>
  {sidebar}
  {chat area}  {/* flex-1 when no canvas, or specific width when canvas exists */}
  {canvas panel when artifact exists}
</div>
```

The chat area and canvas panel should split the available space. When both are visible:
- Chat area: `flex-1 min-w-[400px]` (or 50% on desktop)
- Canvas panel: `w-1/2` (or flex-1)

When canvas is minimized, show a small floating button to re-open it:

Update the main return JSX. In the `activeView === 'chat'` block, wrap the chat content div and conditionally add the CanvasPanel:

```tsx
{activeView === 'chat' && (
  <div className='relative flex min-h-0 min-w-0 flex-1'>
    {/* Chat area */}
    <div className={cn(
      'flex min-h-0 flex-col',
      canvasArtifact && !canvasMinimized ? 'w-1/2 min-w-[360px]' : 'flex-1',
    )}>
      {/* ... existing mobile header, messages area, input area ... */}
    </div>

    {/* Canvas panel */}
    {canvasArtifact && !canvasMinimized && (
      <Suspense fallback={<div className='flex w-1/2 items-center justify-center'><IconLoader2 size={24} className='animate-spin text-text-tertiary' /></div>}>
        <div className='w-1/2 min-w-[360px]'>
          <CanvasPanel
            artifact={canvasArtifact}
            onClose={() => setCanvasMinimized(true)}
          />
        </div>
      </Suspense>
    )}

    {/* Minimized canvas indicator */}
    {canvasArtifact && canvasMinimized && (
      <button
        onClick={() => setCanvasMinimized(false)}
        className='absolute right-4 top-4 z-10 flex items-center gap-2 rounded-radius-lg border border-border-default bg-surface-1 px-3 py-2 text-body-sm font-medium text-text-secondary shadow-elevation-1 transition-all hover:bg-surface-2 hover:text-text-primary'
      >
        <IconCode size={16} className='text-cyan-400' />
        {canvasArtifact.title}
      </button>
    )}
  </div>
)}
```

**IMPORTANT:** On mobile (when `isMobile` is true), the canvas panel should NOT use split-pane. Instead, show a full-screen overlay or a bottom sheet. For MVP, on mobile just show the minimized button — the user taps it to see a full-screen canvas panel. Add `!isMobile` check to the split-pane rendering.

For mobile, when canvas is not minimized, render it as a full overlay:
```tsx
{canvasArtifact && !canvasMinimized && isMobile && (
  <div className='fixed inset-0 z-50 bg-surface-base'>
    <CanvasPanel artifact={canvasArtifact} onClose={() => setCanvasMinimized(true)} />
  </div>
)}
```
  </action>
  <verify>
1. Read canvas-panel.tsx: confirm CanvasPanel renders header, CanvasIframe, error bar
2. Read canvas-iframe.tsx: confirm it's imported and used by CanvasPanel
3. Read index.tsx: confirm canvasArtifact state, canvasQuery polling, split-pane layout, lazy-loaded CanvasPanel
4. Confirm mobile handling: canvas is full overlay on mobile, split-pane on desktop
5. Confirm canvas is cleared on new conversation
  </verify>
  <done>CanvasPanel split-pane appears in AI chat when artifact exists, shows sandboxed iframe content, handles errors, and supports close/re-open on both desktop and mobile</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Canvas UI with split-pane layout: when the AI creates a canvas artifact, a panel appears next to the chat showing the rendered content in a sandboxed iframe. Supports close/re-open, error display, and responsive layout (split-pane on desktop, full overlay on mobile).
  </what-built>
  <how-to-verify>
1. Open the AI chat at the LivOS web UI
2. Ask the AI: "Create a simple React component that shows a counter with increment and decrement buttons"
3. Verify: A split-pane appears next to the chat showing the rendered React component
4. Verify: The counter buttons work (interactive)
5. Try closing the canvas panel (X button) — a minimized button should appear
6. Click the minimized button — the canvas panel should re-open
7. Open browser DevTools Console and run:
   ```javascript
   // Verify the iframe is properly sandboxed
   const iframe = document.querySelector('iframe[title="Canvas Preview"]');
   console.log('Sandbox:', iframe.sandbox.toString());
   // Should output "allow-scripts allow-popups" (NO allow-same-origin)
   ```
8. If on mobile (or resize browser window), verify the canvas shows as a full overlay instead of split-pane
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. CanvasIframe uses sandbox="allow-scripts allow-popups" (grep for sandbox in canvas-iframe.tsx)
2. srcdoc is used, NOT src URL (grep for srcdoc)
3. CDN URLs for React 18, Babel standalone, Tailwind CSS are present
4. postMessage error handler exists in CanvasIframe
5. Split-pane layout appears in index.tsx when canvasArtifact is set
6. CanvasPanel has close button that minimizes, minimized button that re-opens
7. Canvas is cleared on new conversation
</verification>

<success_criteria>
- Canvas panel appears as split-pane when AI creates a visual artifact
- Content renders in sandboxed iframe (verified by checking sandbox attribute)
- Iframe loads React 18, Babel, Tailwind from CDN
- Error boundary catches iframe errors and displays them
- Desktop: split-pane layout. Mobile: full overlay.
- User can close and re-open the canvas panel
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p05-live-canvas-livhub/v2.0-05-02-SUMMARY.md`
</output>
