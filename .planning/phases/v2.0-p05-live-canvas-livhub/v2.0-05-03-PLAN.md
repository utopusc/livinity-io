---
phase: v2.0-p05-live-canvas-livhub
plan: 03
type: execute
wave: 2
depends_on: ["v2.0-05-01"]
files_modified:
  - livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx
  - nexus/packages/core/src/daemon.ts
autonomous: true

must_haves:
  truths:
    - "React component artifacts render interactively with working state and event handlers"
    - "HTML/CSS/JS artifacts render as complete web pages with styles and scripts"
    - "Mermaid diagram artifacts render as visual diagrams with dark theme"
    - "SVG artifacts render as scalable graphics centered on a dark background"
    - "Recharts artifacts render as interactive charts with tooltips and legends"
    - "The system auto-detects artifact type from content when not explicitly specified"
  artifacts:
    - path: "livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx"
      provides: "buildSrcdoc function with type-specific rendering for all 5 artifact types"
      exports: ["CanvasIframe"]
      contains: "buildSrcdoc"
    - path: "nexus/packages/core/src/daemon.ts"
      provides: "Enhanced canvas_render tool description with per-type examples and auto-detection hint"
      contains: "canvas_render"
  key_links:
    - from: "canvas-iframe.tsx buildSrcdoc"
      to: "CanvasArtifact.type field"
      via: "switch on type to produce different srcdoc HTML"
      pattern: "case 'react'|case 'html'|case 'svg'|case 'mermaid'|case 'recharts'"
---

<objective>
Implement comprehensive artifact type handling for all 5 supported canvas types (React components, HTML/CSS/JS, Mermaid diagrams, SVG, Recharts charts) with type auto-detection and optimized rendering templates.

Purpose: Plan 02 creates the basic iframe infrastructure. This plan ensures each artifact type renders correctly with the right CDN dependencies, error handling, and dark-mode styling.

Output: Enhanced buildSrcdoc function with per-type templates, type auto-detection helper, and improved tool descriptions with per-type examples.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v2.0-p05-live-canvas-livhub/v2.0-05-01-SUMMARY.md
@.planning/phases/v2.0-p05-live-canvas-livhub/v2.0-05-02-SUMMARY.md

@livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx
@nexus/packages/core/src/daemon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement per-type srcdoc templates and type auto-detection</name>
  <files>livos/packages/ui/src/routes/ai-chat/canvas-iframe.tsx</files>
  <action>
Enhance the `buildSrcdoc` function in `canvas-iframe.tsx` with production-quality templates for each artifact type. If Plan 02's executor already created a basic version, this task refines and hardens it.

**Type auto-detection helper:**
Add a `detectArtifactType(content: string): CanvasIframeProps['type']` function that attempts to detect the type from content:

```typescript
function detectArtifactType(content: string): 'react' | 'html' | 'svg' | 'mermaid' | 'recharts' {
  const trimmed = content.trim();

  // SVG detection: starts with <svg or <?xml...><svg
  if (trimmed.startsWith('<svg') || (trimmed.startsWith('<?xml') && trimmed.includes('<svg'))) {
    return 'svg';
  }

  // Mermaid detection: starts with common mermaid keywords
  const mermaidKeywords = ['graph ', 'graph\n', 'flowchart ', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 'erDiagram', 'journey', 'gantt', 'pie ', 'pie\n', 'mindmap', 'timeline', 'gitGraph', 'C4Context', 'sankey'];
  if (mermaidKeywords.some(kw => trimmed.startsWith(kw))) {
    return 'mermaid';
  }

  // HTML detection: starts with <!DOCTYPE or <html or has <head>/<body> tags
  if (trimmed.startsWith('<!DOCTYPE') || trimmed.startsWith('<!doctype') || trimmed.startsWith('<html') || (trimmed.includes('<head>') && trimmed.includes('<body>'))) {
    return 'html';
  }

  // Recharts detection: content references Recharts components
  const rechartsComponents = ['LineChart', 'BarChart', 'PieChart', 'AreaChart', 'RadarChart', 'ResponsiveContainer', 'Recharts'];
  if (rechartsComponents.some(comp => trimmed.includes(comp))) {
    return 'recharts';
  }

  // Default: React (most common for generated components)
  return 'react';
}
```

Use this in CanvasIframe as a fallback: `const resolvedType = type || detectArtifactType(content);`

**Enhanced srcdoc templates:**

**Common error boundary script (shared across types):**
```typescript
const ERROR_BOUNDARY_SCRIPT = `
<script>
  window.onerror = function(msg, src, line, col, err) {
    window.parent.postMessage({
      type: 'canvas-error',
      error: String(msg),
      source: src || '',
      line: line || 0,
      stack: err && err.stack ? err.stack : ''
    }, '*');
    return true; // Prevent default error logging
  };
  window.onunhandledrejection = function(e) {
    window.parent.postMessage({
      type: 'canvas-error',
      error: 'Unhandled Promise: ' + String(e.reason),
      stack: e.reason && e.reason.stack ? e.reason.stack : ''
    }, '*');
  };
</script>`;
```

**Common dark-mode base styles (shared across types):**
```typescript
const BASE_STYLES = `
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0;
    padding: 16px;
    color: #e5e5e5;
    background: #0a0a0a;
    font-family: system-ui, -apple-system, sans-serif;
    line-height: 1.5;
  }
  ::-webkit-scrollbar { width: 6px; height: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }
</style>`;
```

**React template:**
```typescript
function buildReactSrcdoc(content: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  ${BASE_STYLES}
  ${ERROR_BOUNDARY_SCRIPT}
  <script src="https://cdn.tailwindcss.com"><\/script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: { extend: {} }
    };
  </script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"><\/script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"><\/script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"><\/script>
</head>
<body class="dark">
  <div id="root"></div>
  <script type="text/babel" data-type="module">
    const { useState, useEffect, useRef, useMemo, useCallback, useReducer, useContext, createContext, Fragment } = React;

    ${content}

    // Auto-mount: try App, then Main, then first function
    const Component = typeof App !== 'undefined' ? App
      : typeof Main !== 'undefined' ? Main
      : typeof Dashboard !== 'undefined' ? Dashboard
      : typeof Page !== 'undefined' ? Page
      : () => React.createElement('div', {style:{padding:'20px',color:'#ef4444'}}, 'Error: No App, Main, Dashboard, or Page component found. Define a function component named App.');

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(Component));
  <\/script>
</body>
</html>`;
}
```

**HTML template:**
```typescript
function buildHtmlSrcdoc(content: string): string {
  // If content is already a full HTML document, inject error boundary and dark styles
  if (content.trim().startsWith('<!DOCTYPE') || content.trim().startsWith('<html')) {
    // Inject error boundary script right after <head> or at the start
    const injected = content.replace(/<head>/i, `<head>${ERROR_BOUNDARY_SCRIPT}`);
    return injected;
  }
  // Otherwise, wrap in a minimal HTML document
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  ${BASE_STYLES}
  ${ERROR_BOUNDARY_SCRIPT}
  <script src="https://cdn.tailwindcss.com"><\/script>
</head>
<body class="dark">
  ${content}
</body>
</html>`;
}
```

**SVG template:**
```typescript
function buildSvgSrcdoc(content: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  ${ERROR_BOUNDARY_SCRIPT}
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #0a0a0a;
      padding: 16px;
    }
    svg {
      max-width: 100%;
      max-height: 100vh;
      height: auto;
    }
  </style>
</head>
<body>
  ${content}
</body>
</html>`;
}
```

**Mermaid template:**
```typescript
function buildMermaidSrcdoc(content: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  ${ERROR_BOUNDARY_SCRIPT}
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #0a0a0a;
      padding: 24px;
    }
    .mermaid {
      font-family: system-ui, sans-serif;
    }
    /* Override Mermaid's default white background */
    .mermaid svg {
      max-width: 100%;
    }
  </style>
</head>
<body>
  <pre class="mermaid">
${content}
  </pre>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"><\/script>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: 'dark',
      themeVariables: {
        darkMode: true,
        background: '#0a0a0a',
        primaryColor: '#6366f1',
        primaryTextColor: '#e5e5e5',
        primaryBorderColor: '#4f46e5',
        lineColor: '#6366f1',
        secondaryColor: '#1e1b4b',
        tertiaryColor: '#1e1b4b',
        fontFamily: 'system-ui, sans-serif',
        fontSize: '14px',
        nodeBorder: '#4f46e5',
        mainBkg: '#1e1b4b',
        clusterBkg: '#1e1b4b',
      }
    });
  <\/script>
</body>
</html>`;
}
```

**Recharts template:**
```typescript
function buildRechartsSrcdoc(content: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  ${BASE_STYLES}
  ${ERROR_BOUNDARY_SCRIPT}
  <script src="https://cdn.tailwindcss.com"><\/script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"><\/script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"><\/script>
  <script src="https://unpkg.com/recharts@2/umd/Recharts.js"><\/script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"><\/script>
</head>
<body class="dark">
  <div id="root"></div>
  <script type="text/babel" data-type="module">
    const { useState, useEffect, useRef, useMemo, useCallback, Fragment } = React;

    // Recharts components available as globals
    const {
      LineChart, Line, BarChart, Bar, PieChart, Pie, Cell,
      XAxis, YAxis, CartesianGrid, Tooltip, Legend,
      ResponsiveContainer, AreaChart, Area, ScatterChart, Scatter,
      RadarChart, Radar, PolarGrid, PolarAngleAxis, PolarRadiusAxis,
      ComposedChart, Treemap, Funnel, FunnelChart,
      RadialBarChart, RadialBar
    } = Recharts;

    ${content}

    const Component = typeof App !== 'undefined' ? App
      : typeof Main !== 'undefined' ? Main
      : typeof Chart !== 'undefined' ? Chart
      : typeof Dashboard !== 'undefined' ? Dashboard
      : () => React.createElement('div', {style:{padding:'20px',color:'#ef4444'}}, 'Error: No App, Main, Chart, or Dashboard component found.');

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(Component));
  <\/script>
</body>
</html>`;
}
```

**Main buildSrcdoc function:**
```typescript
export function buildSrcdoc(content: string, type: string): string {
  switch (type) {
    case 'react': return buildReactSrcdoc(content);
    case 'html': return buildHtmlSrcdoc(content);
    case 'svg': return buildSvgSrcdoc(content);
    case 'mermaid': return buildMermaidSrcdoc(content);
    case 'recharts': return buildRechartsSrcdoc(content);
    default: return buildReactSrcdoc(content); // Fallback to React
  }
}
```

**IMPORTANT escaping note:** When writing the srcdoc string, be careful with `</script>` inside template literals. Use `<\/script>` in the srcdoc string to prevent the browser from interpreting it as the end of the parent script tag. Actually, since this is a TypeScript string, not embedded in HTML, regular `</script>` is fine. But if using `srcdoc` attribute directly in JSX, the string passes through React which handles it correctly via srcdoc attribute.

However, the content from the AI might contain `</script>` tags. The srcdoc attribute encodes the HTML, so this is handled by the browser. No manual escaping needed.

**Update CanvasIframe component** to use the enhanced `buildSrcdoc` with type auto-detection:
```typescript
export function CanvasIframe({ content, type, onError, className }: CanvasIframeProps) {
  const resolvedType = type || detectArtifactType(content);
  const srcdoc = useMemo(() => buildSrcdoc(content, resolvedType), [content, resolvedType]);

  // ... postMessage listener ...

  return (
    <iframe
      srcDoc={srcdoc}
      sandbox="allow-scripts allow-popups"
      title="Canvas Preview"
      className={cn('h-full w-full border-0', className)}
      style={{ colorScheme: 'dark' }}
    />
  );
}
```

Use `useMemo` to avoid regenerating srcdoc on every render.
  </action>
  <verify>
1. Read canvas-iframe.tsx â€” confirm buildSrcdoc has 5 separate template functions (buildReactSrcdoc, buildHtmlSrcdoc, buildSvgSrcdoc, buildMermaidSrcdoc, buildRechartsSrcdoc)
2. Confirm detectArtifactType function handles SVG, Mermaid, HTML, Recharts detection
3. Confirm ERROR_BOUNDARY_SCRIPT is injected in all templates
4. Confirm dark mode styles (background #0a0a0a, color #e5e5e5) are present
5. Confirm Recharts template includes Recharts UMD and destructured globals
6. Confirm Mermaid template has mermaid.initialize with dark theme
  </verify>
  <done>All 5 artifact types render with optimized templates, dark-mode styling, error boundaries, and type auto-detection works for untyped content</done>
</task>

<task type="auto">
  <name>Task 2: Enhance canvas_render tool description with per-type examples</name>
  <files>nexus/packages/core/src/daemon.ts</files>
  <action>
Update the `canvas_render` tool description in `daemon.ts registerTools()` to provide clear per-type examples and guidance for the AI. This helps the AI generate correct content for each type.

Replace the `canvas_render` tool's description with:

```typescript
description: `Render interactive content in the Live Canvas panel next to the chat. Content appears as a split-pane alongside the conversation.

Types and content format:
- react: A React functional component using JSX. Must define a function named App (or Main/Dashboard). Available: React 18, Tailwind CSS, useState/useEffect/etc.
  Example: function App() { const [count, setCount] = useState(0); return <div className="p-8"><h1 className="text-2xl font-bold">{count}</h1><button onClick={() => setCount(c => c+1)} className="bg-blue-500 px-4 py-2 rounded">+</button></div> }

- html: Complete HTML document or HTML fragment. Tailwind CSS available via CDN.
  Example: <div class="p-8 text-center"><h1 class="text-3xl font-bold text-blue-400">Hello World</h1></div>

- svg: SVG markup. Will be centered on dark background.
  Example: <svg viewBox="0 0 200 200"><circle cx="100" cy="100" r="80" fill="#6366f1"/></svg>

- mermaid: Mermaid diagram definition (graph, flowchart, sequence, class, ER, gantt, pie, etc). Renders with dark theme.
  Example: graph TD; A[Start] --> B{Decision}; B -->|Yes| C[OK]; B -->|No| D[End]

- recharts: React component using Recharts library. All Recharts components (LineChart, BarChart, PieChart, AreaChart, etc) are available as globals.
  Example: function App() { const data = [{name:'Jan',value:400},{name:'Feb',value:300}]; return <ResponsiveContainer width="100%" height={400}><BarChart data={data}><XAxis dataKey="name"/><YAxis/><Bar dataKey="value" fill="#6366f1"/></BarChart></ResponsiveContainer> }

Use this when users ask for visual output: dashboards, charts, diagrams, UI mockups, interactive widgets.`,
```

Also update the `content` parameter description to be more specific:
```typescript
{ name: 'content', type: 'string', description: 'The source code. For react/recharts: define a function App() component. For html: full HTML or fragment. For svg: SVG markup. For mermaid: diagram definition text. Do NOT wrap in markdown code blocks.', required: true },
```
  </action>
  <verify>
1. Read daemon.ts canvas_render tool registration
2. Confirm description includes examples for all 5 types
3. Confirm content parameter description mentions all types
  </verify>
  <done>canvas_render tool has comprehensive per-type documentation and examples that guide the AI to generate correct content for each artifact type</done>
</task>

</tasks>

<verification>
1. Test React artifact: Content with `function App() { return <div>Hello</div> }` should render
2. Test HTML artifact: Full HTML document should render with Tailwind
3. Test SVG artifact: SVG markup should render centered
4. Test Mermaid artifact: `graph TD; A-->B` should render as diagram
5. Test Recharts artifact: Component with BarChart should render with tooltips
6. Test auto-detection: SVG content starting with `<svg` should auto-detect as svg type
</verification>

<success_criteria>
- All 5 artifact types render correctly in the sandboxed iframe
- Dark mode styling is consistent across all types
- Error boundaries catch and report errors for all types
- Type auto-detection works for common patterns
- Recharts template provides all common chart components as globals
- Mermaid renders with dark theme
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p05-live-canvas-livhub/v2.0-05-03-SUMMARY.md`
</output>
