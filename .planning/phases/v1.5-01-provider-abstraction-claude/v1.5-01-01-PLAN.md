---
phase: v1.5-01-provider-abstraction-claude
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/providers/types.ts
  - nexus/packages/core/src/providers/normalize.ts
  - nexus/packages/core/src/providers/index.ts
autonomous: true

must_haves:
  truths:
    - "A provider-neutral message format exists with role 'user' | 'assistant' (not 'model')"
    - "Consecutive same-role messages are automatically merged before API calls"
    - "Token usage has a normalized shape (inputTokens, outputTokens) regardless of provider"
    - "Provider capabilities are queryable (supportsVision, supportsToolCalling)"
  artifacts:
    - path: "nexus/packages/core/src/providers/types.ts"
      provides: "AIProvider interface, ChatMessage, ChatOptions, ChatResult, ChatStreamResult, ModelTier, provider config types"
      exports: ["AIProvider", "ProviderMessage", "ProviderChatOptions", "ProviderChatResult", "ProviderStreamResult", "ModelTier", "ProviderConfig", "PROVIDER_COST_DEFAULTS"]
    - path: "nexus/packages/core/src/providers/normalize.ts"
      provides: "Message normalization: role mapping, consecutive merge, alternation validation, image format conversion"
      exports: ["normalizeMessages", "mergeConsecutiveRoles", "validateAlternation", "convertImagesToProvider"]
    - path: "nexus/packages/core/src/providers/index.ts"
      provides: "Barrel export for providers module"
      exports: ["*"]
  key_links:
    - from: "nexus/packages/core/src/providers/types.ts"
      to: "existing brain.ts ChatMessage"
      via: "Compatible shape - ProviderMessage uses role 'user' | 'assistant' internally"
      pattern: "role: 'user' \\| 'assistant'"
    - from: "nexus/packages/core/src/providers/normalize.ts"
      to: "nexus/packages/core/src/providers/types.ts"
      via: "imports ProviderMessage type"
      pattern: "import.*\\{ ProviderMessage\\}.*from './types"
---

<objective>
Create the AIProvider interface, provider-neutral message types, and message normalization layer that all providers will implement.

Purpose: This is the foundational type system for the multi-provider architecture. Without these types, neither ClaudeProvider nor GeminiProvider can be implemented. The normalization layer solves the critical pitfall of Claude's strict user/assistant alternation requirement (Pitfall #1 from research).

Output: Three files in a new `providers/` directory establishing the type contracts and normalization logic that Plans 02 and 03 depend on.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/research/PITFALLS.md

# Current Brain types to understand the shape we're abstracting
@nexus/packages/core/src/brain.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AIProvider interface and provider-neutral types</name>
  <files>nexus/packages/core/src/providers/types.ts</files>
  <action>
Create `nexus/packages/core/src/providers/types.ts` with these exports:

1. **ModelTier** - Re-export the existing type: `'none' | 'flash' | 'haiku' | 'sonnet' | 'opus'`

2. **ProviderMessage** - Provider-neutral message format:
```typescript
interface ProviderMessage {
  role: 'user' | 'assistant';
  content: string;
  images?: Array<{ base64: string; mimeType: string }>;
}
```
Note: Use `'assistant'` not `'model'` -- this is the standard that both Claude and the normalization layer will use. Gemini's `'model'` gets mapped at the provider boundary.

3. **ProviderChatOptions** - What callers pass in:
```typescript
interface ProviderChatOptions {
  systemPrompt: string;
  messages: ProviderMessage[];
  tier?: ModelTier;
  maxOutputTokens?: number;
  /** Provider-specific options (extended thinking, cache control, etc.) */
  providerOptions?: Record<string, unknown>;
}
```

4. **ProviderChatResult** - Non-streaming response:
```typescript
interface ProviderChatResult {
  text: string;
  inputTokens: number;
  outputTokens: number;
  provider: string; // 'claude' | 'gemini'
  model: string;    // actual model name used
}
```

5. **ProviderStreamChunk** and **ProviderStreamResult** - Streaming response:
```typescript
interface ProviderStreamChunk {
  text: string;
  done: boolean;
}

interface ProviderStreamResult {
  stream: AsyncGenerator<ProviderStreamChunk>;
  getUsage: () => { inputTokens: number; outputTokens: number };
  provider: string;
  model: string;
}
```

6. **AIProvider** - The core interface:
```typescript
interface AIProvider {
  readonly id: string;           // 'claude' | 'gemini'
  readonly supportsVision: boolean;
  readonly supportsToolCalling: boolean;

  chat(options: ProviderChatOptions): Promise<ProviderChatResult>;
  chatStream(options: ProviderChatOptions): ProviderStreamResult;
  think(options: { prompt: string; systemPrompt?: string; tier?: ModelTier; maxTokens?: number }): Promise<string>;
  isAvailable(): Promise<boolean>;
  getModels(): Record<string, string>;
}
```

7. **ProviderConfig** - Configuration shape:
```typescript
interface ProviderConfig {
  id: string;
  priority: number;       // Lower = higher priority (0 = primary)
  enabled: boolean;
  models: Record<string, string>;
  costPerMillionTokens: { input: number; output: number };
  defaultMaxOutputTokens: number;
}
```

8. **PROVIDER_COST_DEFAULTS** - Cost constants:
```typescript
const PROVIDER_COST_DEFAULTS = {
  claude: {
    flash: { input: 1.0, output: 5.0 },
    haiku: { input: 1.0, output: 5.0 },
    sonnet: { input: 3.0, output: 15.0 },
    opus: { input: 5.0, output: 25.0 },
  },
  gemini: {
    flash: { input: 0.10, output: 0.40 },
    haiku: { input: 0.10, output: 0.40 },
    sonnet: { input: 0.10, output: 0.40 },
    opus: { input: 1.25, output: 5.0 },
  },
} as const;
```

Export all types and constants. Use `export interface` (not `export type`) for interfaces so they're available as both types and values where needed.
  </action>
  <verify>
Run: `cd nexus && npx tsc --noEmit --pretty 2>&1 | head -20` -- should have no errors in providers/types.ts. Also verify the file exists and exports the expected symbols by checking: `grep -c 'export' nexus/packages/core/src/providers/types.ts` returns at least 8.
  </verify>
  <done>
types.ts exists with AIProvider interface, ProviderMessage, ProviderChatOptions, ProviderChatResult, ProviderStreamResult, ProviderConfig, ModelTier, and PROVIDER_COST_DEFAULTS all exported. No TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message normalization layer</name>
  <files>nexus/packages/core/src/providers/normalize.ts, nexus/packages/core/src/providers/index.ts</files>
  <action>
Create `nexus/packages/core/src/providers/normalize.ts` with these functions:

1. **normalizeMessages(messages: Array<{role: string; text?: string; content?: string; images?: ...}>): ProviderMessage[]**
   - Maps `role: 'model'` to `role: 'assistant'` (Gemini compatibility)
   - Maps `text` field to `content` field (old Brain format compatibility)
   - Preserves `images` array as-is
   - Strips empty messages (no content and no images)

2. **mergeConsecutiveRoles(messages: ProviderMessage[]): ProviderMessage[]**
   - If two consecutive messages have the same role, merge them by concatenating content with `\n\n`
   - Merge images arrays too (combine both arrays)
   - This is CRITICAL for Claude compliance -- Claude rejects consecutive same-role messages
   - Common scenario: tool result (user) followed by another tool result (user) in multi-tool turns

3. **validateAlternation(messages: ProviderMessage[]): { valid: boolean; error?: string }**
   - Checks that messages strictly alternate between 'user' and 'assistant'
   - First message must be 'user' (Claude requirement)
   - Returns descriptive error if validation fails: "Messages[{index}]: expected '{expected}' but got '{actual}'"
   - This is a pre-flight check -- call before sending to Claude

4. **prepareForProvider(messages: ProviderMessage[], provider: 'claude' | 'gemini'): any[]**
   - For 'claude': Convert to Claude message format:
     - `{ role: msg.role, content: string }` for text-only
     - `{ role: msg.role, content: [{ type: 'text', text: msg.content }, ...imageBlocks] }` for messages with images
     - Image blocks: `{ type: 'image', source: { type: 'base64', media_type: img.mimeType, data: img.base64 } }`
   - For 'gemini': Convert to Gemini message format:
     - `{ role: msg.role === 'assistant' ? 'model' : msg.role, parts: [{ text: msg.content }, ...imageParts] }`
     - Image parts: `{ inlineData: { data: img.base64, mimeType: img.mimeType } }`
   - Apply `mergeConsecutiveRoles` before conversion
   - For Claude, also run `validateAlternation` and throw if invalid

5. **normalizeAndPrepare(rawMessages: Array<any>, provider: 'claude' | 'gemini'): any[]**
   - Convenience function combining normalizeMessages + prepareForProvider
   - This is the main entry point callers will use

Import ProviderMessage from ./types.ts. Use the logger from `../logger.js` for any warnings (e.g., "Merged 2 consecutive user messages").

Then create `nexus/packages/core/src/providers/index.ts` as a barrel export:
```typescript
export * from './types.js';
export * from './normalize.js';
```
  </action>
  <verify>
Run: `cd nexus && npx tsc --noEmit --pretty 2>&1 | head -20` -- no TypeScript errors. Also verify normalize.ts exports: `grep -c 'export function' nexus/packages/core/src/providers/normalize.ts` returns at least 4.
  </verify>
  <done>
normalize.ts exports normalizeMessages, mergeConsecutiveRoles, validateAlternation, prepareForProvider, and normalizeAndPrepare. The barrel index.ts re-exports everything from types.ts and normalize.ts. No TypeScript errors. The normalization layer correctly handles: (a) Gemini 'model' to 'assistant' mapping, (b) consecutive same-role merging, (c) Claude alternation validation, (d) provider-specific message format conversion including images.
  </done>
</task>

</tasks>

<verification>
1. `cd nexus && npx tsc --noEmit` passes with no errors related to the providers/ directory
2. `ls nexus/packages/core/src/providers/` shows types.ts, normalize.ts, index.ts
3. The AIProvider interface has chat(), chatStream(), think(), isAvailable() methods
4. The normalizeMessages function maps 'model' role to 'assistant'
5. The mergeConsecutiveRoles function combines consecutive same-role messages
6. The validateAlternation function rejects non-alternating message sequences
7. The prepareForProvider function produces correct format for both 'claude' and 'gemini'
</verification>

<success_criteria>
- All provider types are defined and exported from the providers/ barrel
- Message normalization handles the Gemini 'model' -> 'assistant' role mapping
- Consecutive same-role messages are merged (solving Claude Pitfall #1)
- Provider-specific message format conversion works for both Claude and Gemini
- No TypeScript compilation errors
- Types are compatible with the existing Brain.ChatMessage shape
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-01-provider-abstraction-claude/v1.5-01-01-SUMMARY.md`
</output>
