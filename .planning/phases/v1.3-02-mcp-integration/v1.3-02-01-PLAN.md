---
phase: v1.3-02-mcp-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - chromium/hooks/post-start (gallery repo)
  - chromium/hooks/pre-stop (gallery repo)
  - chromium/docker-compose.yml (gallery repo - CDP verification only)
autonomous: true

must_haves:
  truths:
    - "When browser app starts, Playwright MCP server is auto-registered in Nexus via Redis"
    - "When browser app stops, Playwright MCP server is auto-deregistered from Nexus via Redis"
    - "CDP port 9222 is enabled inside the container but NOT exposed to the host network"
    - "MCP config structure matches what McpConfigManager expects (name, transport, command, args, enabled)"
  artifacts:
    - path: "chromium/hooks/post-start"
      provides: "MCP registration script that runs on HOST after chromium container starts"
      contains: "nexus:mcp:config"
    - path: "chromium/hooks/pre-stop"
      provides: "MCP deregistration script that runs on HOST before chromium container stops"
      contains: "nexus:mcp:config"
  key_links:
    - from: "chromium/hooks/post-start"
      to: "nexus:mcp:config Redis key"
      via: "redis-cli SET and PUBLISH"
      pattern: "redis-cli.*SET.*nexus:mcp:config"
    - from: "chromium/hooks/post-start"
      to: "nexus:config:updated Redis channel"
      via: "redis-cli PUBLISH"
      pattern: "PUBLISH.*nexus:config:updated.*mcp_config"
    - from: "chromium/hooks/pre-stop"
      to: "nexus:mcp:config Redis key"
      via: "redis-cli SET with jq del"
      pattern: "jq.*del.*mcpServers"
---

<objective>
Update and harden the chromium app hooks (post-start, pre-stop) for Playwright MCP auto-registration lifecycle, and verify CDP port 9222 is internal-only in docker-compose.yml.

Purpose: The hooks are the bridge between the browser app lifecycle and Nexus MCP system. When the browser starts, the AI gains browser control tools. When it stops, those tools are cleanly removed. Getting this right is critical for the entire MCP integration.

Output: Production-ready hook scripts in the gallery repo that correctly register/deregister Playwright MCP with Nexus, plus verified docker-compose.yml CDP configuration.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md

# Existing files to modify (in gallery repo)
# Gallery repo is at: C:\Users\hello\Desktop\Projects\contabo\livinity-apps\
@C:\Users\hello\Desktop\Projects\contabo\livinity-apps\chromium\hooks\post-start
@C:\Users\hello\Desktop\Projects\contabo\livinity-apps\chromium\hooks\pre-stop

# Nexus MCP system (reference only - do NOT modify)
@nexus\packages\core\src\mcp-client-manager.ts
@nexus\packages\core\src\mcp-config-manager.ts

# App lifecycle system (reference only - shows how hooks execute on HOST)
@livos\packages\livinityd\source\modules\apps\legacy-compat\app-script
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update post-start and pre-stop hook scripts for correct MCP registration</name>
  <files>
    C:\Users\hello\Desktop\Projects\contabo\livinity-apps\chromium\hooks\post-start
    C:\Users\hello\Desktop\Projects\contabo\livinity-apps\chromium\hooks\pre-stop
  </files>
  <action>
Update both hook scripts in the gallery repo. These hooks run on the HOST (not inside the container) as part of the app lifecycle managed by app-script.

**Key context from app-script (line 365):**
- docker compose uses `--project-name "${app}"` where app = "chromium"
- Container naming (app.ts line 189-190): If no explicit container_name, forces `${appId}_${serviceName}_1`
- So if docker-compose service is named "server", container name = `chromium_server_1`

**Key context from McpConfigManager:**
- Config stored in Redis key `nexus:mcp:config`
- Structure: `{"mcpServers": {"browser": {config...}}}`
- McpServerConfig fields: name, transport, command, args, enabled, description (optional), env (optional)
- Changes trigger via PUBLISH to channel `nexus:config:updated` with message `mcp_config`

**Key context from McpClientManager:**
- Allowed stdio commands (line 28-29): npx, node, python, python3, uvx, docker, deno, bun
- For stdio transport: spawns child process with command + args
- The `npx` command runs on the HOST, connecting to CDP endpoint

**post-start hook updates needed:**

1. Container name: Keep `chromium_server_1` (matches `${appId}_${serviceName}_1` convention where appId=chromium, serviceName=server)

2. CDP endpoint format: Change from `http://localhost:9222` to `http://localhost:9222`.
   IMPORTANT: The Playwright MCP npx process runs on the HOST (spawned by McpClientManager's StdioClientTransport). Port 9222 is NOT mapped to the host. The CDP connection must go through Docker network, NOT localhost. Use `docker exec -i` approach instead, which runs the npx command INSIDE the container where localhost:9222 is the container's own CDP port.

   Wait -- re-reading the existing hook and research docs more carefully:
   - The existing hook uses: `docker exec -i chromium_server_1 npx @playwright/mcp@latest --cdp-endpoint http://localhost:9222`
   - This means the MCP config tells Nexus to run `docker` command with args `["exec", "-i", "chromium_server_1", "npx", "@playwright/mcp@latest", "--cdp-endpoint", "http://localhost:9222"]`
   - `docker` IS in the allowed commands list (line 29 of mcp-client-manager.ts)
   - This approach means Playwright MCP runs INSIDE the container, connecting to localhost:9222 (the container's own CDP)
   - This is CORRECT and avoids needing to expose port 9222 to host (SEC-03)

   Keep the `docker exec -i` approach. This is the right design:
   - CDP stays container-internal (SEC-03 satisfied)
   - No host port mapping needed for 9222
   - `docker` command is in the allowlist

3. MCP config structure must match McpServerConfig exactly:
   ```json
   {
     "mcpServers": {
       "browser": {
         "name": "browser",
         "transport": "stdio",
         "command": "docker",
         "args": ["exec", "-i", "chromium_server_1", "npx", "-y", "@playwright/mcp@latest", "--cdp-endpoint", "http://localhost:9222"],
         "enabled": true,
         "description": "Browser automation via Playwright CDP"
       }
     }
   }
   ```
   Note: Add `-y` flag to npx args to auto-confirm package install without prompting.
   Note: The `name` field should be included (McpConfigManager normalizes it from the key, but including it is cleaner).

4. Redis authentication: The current approach reads REDIS_URL env var or falls back to /opt/livos/.env. This is correct for production. However, use the configurable path pattern from the config system. Keep the current /opt/livos/.env fallback since hooks run on the HOST where the .env lives.

5. Add a CDP readiness wait loop: After container starts, CDP may take a few seconds to be ready. Add a wait loop that checks CDP availability via `docker exec chromium_server_1 curl -s http://localhost:9222/json/version` (curl inside the container, since CDP isn't on host). If curl is not available in the container, use `wget -q -O-` instead, or simply add a `sleep 5` as a simpler approach since the MCP connection itself has a 30-second timeout (CONNECT_TIMEOUT_MS in mcp-client-manager.ts).

   Actually, the McpClientManager already has a 30-second connection timeout. A simple `sleep 3` in the hook before registering is sufficient as a basic grace period. The MCP client will retry on its own via reconcile if the first connection fails.

6. Error handling: Keep `exit 0` on Redis connection failure (non-blocking -- the app should still start even if MCP registration fails).

**pre-stop hook updates needed:**

1. The current script correctly removes `.mcpServers.browser` key and publishes the update.
2. Ensure it uses the same Redis auth approach as post-start.
3. Keep the same server key name "browser" to match post-start.

**Both hooks:**
- Ensure scripts are executable (chmod +x)
- Use `set -e` or handle errors gracefully (current approach of swallowing errors is fine for hooks)
- Add clear logging with `[chromium-mcp]` prefix (already present)
  </action>
  <verify>
1. Read both hook files and verify:
   - post-start: MCP config JSON has correct structure with "browser" key, "docker" command, correct args array with "-y" flag, "stdio" transport, "enabled": true
   - pre-stop: Correctly removes .mcpServers.browser and publishes update
2. Verify container name "chromium_server_1" in the MCP args matches the naming convention
3. Verify `docker` is used as the command (not `npx` directly) -- this ensures CDP stays container-internal
4. Verify scripts have proper shebang (#!/bin/bash) and exit codes
5. Run `bash -n` syntax check on both scripts (if on Linux/WSL)
  </verify>
  <done>
- post-start hook registers Playwright MCP as "browser" server with stdio transport using docker exec approach
- pre-stop hook deregisters "browser" server from Redis config
- MCP config structure matches McpServerConfig interface (name, transport, command, args, enabled)
- CDP endpoint is container-internal (http://localhost:9222 inside docker exec, not exposed to host)
- Both hooks handle Redis auth via REDIS_URL env or /opt/livos/.env fallback
- Both hooks publish to nexus:config:updated channel after config changes
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify docker-compose.yml does NOT expose CDP port 9222 to host</name>
  <files>
    C:\Users\hello\Desktop\Projects\contabo\livinity-apps\chromium\docker-compose.yml (verify/read only -- created by Phase 1)
  </files>
  <action>
This task verifies SEC-03 (CDP port 9222 NOT exposed to host) and MCP-05 (CDP enabled via CHROME_CLI flags).

Since the docker-compose.yml is created in Phase 1, this task verifies the Phase 1 output is compatible with the MCP integration:

1. Read the chromium docker-compose.yml (created by Phase 1 plan 01)
2. Verify that port 9222 does NOT appear in the `ports:` section
3. Verify that `CHROME_CLI` environment variable includes `--remote-debugging-port=9222 --remote-debugging-address=0.0.0.0 --remote-allow-origins=*`
4. If the docker-compose.yml does not yet exist (Phase 1 not executed), create a verification checklist file that documents what Phase 1 MUST include for Phase 2 to work

The `--remote-debugging-address=0.0.0.0` is needed so CDP listens on all interfaces INSIDE the container (so docker exec can reach it). The `--remote-allow-origins=*` allows Playwright to connect.

Since we use `docker exec -i` to run Playwright MCP inside the container, port 9222 never needs to leave the container. The container's localhost:9222 is sufficient.

If docker-compose.yml exists: Read it and verify the above.
If docker-compose.yml does NOT exist: Document the requirements as a pre-condition note in the SUMMARY so Phase 1 executor knows.
  </action>
  <verify>
1. Check docker-compose.yml ports section: 9222 must NOT be listed
2. Check CHROME_CLI env var: must include --remote-debugging-port=9222
3. Check CHROME_CLI env var: must include --remote-debugging-address=0.0.0.0
4. Check CHROME_CLI env var: must include --remote-allow-origins=*
  </verify>
  <done>
- SEC-03 verified: CDP port 9222 is NOT exposed in docker-compose ports mapping
- MCP-05 verified: CHROME_CLI includes --remote-debugging-port=9222, --remote-debugging-address=0.0.0.0, --remote-allow-origins=*
- If docker-compose.yml not yet created, requirements documented for Phase 1
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full MCP integration path:

1. **Hook -> Redis flow:**
   - post-start writes to nexus:mcp:config with correct JSON structure
   - post-start publishes "mcp_config" to nexus:config:updated channel
   - pre-stop removes .mcpServers.browser from config
   - pre-stop publishes "mcp_config" to nexus:config:updated channel

2. **MCP config -> McpClientManager flow:**
   - Config has transport: "stdio", command: "docker", args with exec -i
   - "docker" is in ALLOWED_COMMANDS set
   - McpClientManager.reconcile() will pick up the new "browser" server

3. **CDP security (SEC-03):**
   - docker-compose.yml does NOT map port 9222 to host
   - CDP is only accessible inside the container via localhost:9222
   - Playwright MCP accesses CDP via docker exec (runs inside container)

4. **Requirements coverage:**
   - MCP-01: post-start registers MCP in Redis -- COVERED
   - MCP-02: pre-stop deregisters MCP from Redis -- COVERED
   - MCP-05: CHROME_CLI has --remote-debugging-port=9222 -- VERIFIED
   - SEC-03: CDP port internal only -- VERIFIED
</verification>

<success_criteria>
1. post-start hook correctly registers Playwright MCP server in Redis with valid McpServerConfig structure
2. pre-stop hook correctly deregisters Playwright MCP server from Redis
3. MCP config uses docker exec approach (CDP stays container-internal)
4. docker-compose.yml does NOT expose port 9222 to host
5. CHROME_CLI includes required CDP flags
6. Both hooks handle Redis auth correctly
</success_criteria>

<output>
After completion, create `.planning/phases/v1.3-02-mcp-integration/v1.3-02-01-SUMMARY.md`
</output>
