---
phase: v1.5-04-websocket-gateway-hitl
plan: 03
subsystem: agent-hitl
tags: [hitl, approval, redis, agent-loop, tool-registry]
depends_on:
  requires: [v1.5-04-01, v1.5-04-02]
  provides: [ApprovalManager, tool-approval-gate, approval-types]
  affects: [v1.5-04-04]
tech_stack:
  added: []
  patterns: [BLPOP-blocking-wait, Redis-pub/sub-notification, approval-gate-pattern]
key_files:
  created:
    - nexus/packages/core/src/approval-manager.ts
  modified:
    - nexus/packages/core/src/types.ts
    - nexus/packages/core/src/tool-registry.ts
    - nexus/packages/core/src/agent.ts
decisions:
  - id: HITL-BLPOP
    description: "Use Redis BLPOP on per-request key for approval wait (duplicated connection, auto-disconnect)"
  - id: HITL-POLICY
    description: "Three-level approval policy: 'always' (all tools), 'destructive' (only requiresApproval), 'never' (skip)"
  - id: HITL-TIMEOUT
    description: "Default 5-minute timeout for approval requests; expired = denied with informative message"
  - id: HITL-AUDIT
    description: "Resolved approval requests kept in Redis for 24h audit trail (EX 86400)"
metrics:
  duration: ~4min
  completed: 2026-02-15
---

# Phase 4 Plan 3: HITL Core -- Tool Approval Metadata, ApprovalManager, Agent Loop Gate

**One-liner:** Redis-backed ApprovalManager with BLPOP wait pattern and dual-path agent loop gate for destructive tool authorization.

## What Was Done

### Task 1: Add requiresApproval to Tool type, create ApprovalManager
**Commit:** `44decaa`

Extended the `Tool` interface in `types.ts` with an optional `requiresApproval: boolean` flag. Added `ApprovalRequest` and `ApprovalResponse` types for the full approval lifecycle.

Created `approval-manager.ts` with the `ApprovalManager` class:
- `createRequest()` -- stores pending approval in Redis with TTL, publishes notification to `nexus:notify:approval` channel
- `waitForResponse()` -- uses Redis BLPOP on a per-request response key with a duplicated connection to avoid blocking the main connection
- `resolve()` -- pushes response to the BLPOP key and publishes resolution notification
- `getRequest()` / `listPending()` -- query approval state from Redis
- Private `updateRequestStatus()` -- updates stored request with resolution metadata and 24h retention

Added `requiresApproval()` helper method to `ToolRegistry` for quick lookup of whether a tool needs approval.

### Task 2: Add approval gate to AgentLoop
**Commit:** `28311eb`

Extended `AgentConfig` with three new fields:
- `approvalManager?: ApprovalManager` -- injected dependency for approval handling
- `sessionId?: string` -- auto-generated via `randomUUID()` if not provided
- `approvalPolicy?: 'always' | 'destructive' | 'never'` -- controls which tools require approval

Added `checkApproval()` private method to `AgentLoop` that:
1. Checks if approval is needed based on policy and tool metadata
2. Emits an `awaitingApproval` event for streaming clients
3. Creates an approval request via ApprovalManager
4. Waits for the response (blocks via BLPOP)
5. Returns approved/denied with reason

Inserted the approval gate in both code paths:
- **Claude native tool calling** -- after policy check, before tool execution in the `for (const toolCall of nativeToolUseBlocks)` loop
- **Gemini JSON-in-text** -- after policy check, before tool execution in the `step.type === 'tool_call'` section

Both paths follow the same check order: policy allowed -> approval granted -> execute.

## Deviations from Plan

None -- plan executed exactly as written.

## Verification Results

| # | Criterion | Result |
|---|-----------|--------|
| 1 | `npx tsc --noEmit` passes | PASS |
| 2 | Tool interface has `requiresApproval?: boolean` | PASS (types.ts:33) |
| 3 | ApprovalRequest/ApprovalResponse in types.ts | PASS (types.ts:37,52) |
| 4 | approval-manager.ts: create, wait, resolve | PASS |
| 5 | agent.ts: checkApproval in both paths | PASS (lines 570, 795) |
| 6 | AgentConfig: approvalManager, sessionId, approvalPolicy | PASS |
| 7 | ToolRegistry: requiresApproval() helper | PASS (line 145) |

## Architecture Notes

**Approval flow:**
```
Agent decides to call tool
  -> isToolAllowed(policy)? No -> denied
  -> checkApproval()
    -> policy=never or no manager? -> auto-approved
    -> tool.requiresApproval=false and policy=destructive? -> auto-approved
    -> createRequest() -> Redis SET + PUBLISH
    -> waitForResponse() -> Redis BLPOP (blocking)
      -> timeout? -> expired/denied
      -> deny? -> denied with reason
      -> approve? -> proceed to execution
  -> execute tool
```

**Redis keys used:**
- `nexus:approval:{id}` -- stored approval request (TTL = timeout + 60s, then 24h after resolution)
- `nexus:approval:response:{id}` -- BLPOP response key (pushed by resolve())
- `nexus:notify:approval` -- pub/sub channel for real-time notifications

## Next Phase Readiness

Plan 04 (HITL wiring) can proceed. It needs:
- Wire ApprovalManager into Daemon and pass to AgentLoop
- Add approval resolve/list endpoints to the API
- Mark destructive built-in tools with `requiresApproval: true`
- Add approval policy to NexusConfig schema
