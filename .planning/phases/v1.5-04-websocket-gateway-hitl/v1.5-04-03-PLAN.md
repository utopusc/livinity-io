---
phase: v1.5-04-websocket-gateway-hitl
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/types.ts
  - nexus/packages/core/src/tool-registry.ts
  - nexus/packages/core/src/approval-manager.ts
  - nexus/packages/core/src/agent.ts
autonomous: true

must_haves:
  truths:
    - "Tool interface has a requiresApproval boolean flag that tool authors can set"
    - "Destructive built-in tools (shell with rm/delete, docker stop/remove, file delete) are marked requiresApproval"
    - "When the agent attempts to execute a tool marked requiresApproval, execution pauses and an approval_request is created in Redis"
    - "The agent loop waits for the approval response (approve/deny) before proceeding"
    - "If approved, the tool executes normally and the agent continues"
    - "If denied, the agent receives an error and can try a different approach"
    - "Approval requests expire after a configurable timeout (default 5 minutes)"
  artifacts:
    - path: "nexus/packages/core/src/types.ts"
      provides: "Tool interface with optional requiresApproval flag"
      contains: "requiresApproval"
    - path: "nexus/packages/core/src/approval-manager.ts"
      provides: "ApprovalManager class for creating/resolving approvals via Redis"
      min_lines: 100
    - path: "nexus/packages/core/src/agent.ts"
      provides: "Agent loop with approval gate before tool execution"
      contains: "approvalManager"
    - path: "nexus/packages/core/src/tool-registry.ts"
      provides: "ToolRegistry passes approval metadata through, marks destructive tools"
      contains: "requiresApproval"
  key_links:
    - from: "nexus/packages/core/src/agent.ts"
      to: "nexus/packages/core/src/approval-manager.ts"
      via: "requestApproval call before tool.execute"
      pattern: "requestApproval|waitForApproval"
    - from: "nexus/packages/core/src/approval-manager.ts"
      to: "Redis"
      via: "Store pending approvals, pub/sub for responses"
      pattern: "redis\\.set|redis\\.publish"
    - from: "nexus/packages/core/src/agent.ts"
      to: "nexus/packages/core/src/types.ts"
      via: "Check tool.requiresApproval before execution"
      pattern: "requiresApproval"
---

<objective>
Build the core Human-in-the-Loop (HITL) system: tool approval metadata on the Tool interface, an ApprovalManager for creating and resolving approval requests via Redis, and the agent loop pause/resume gate that waits for approval before executing destructive tools.

Purpose: Destructive operations (deleting files, stopping containers, executing dangerous shell commands) should not execute without explicit user confirmation. This prevents the AI from accidentally causing damage while still allowing it to propose actions.

Output: Updated `types.ts` with approval flag, new `approval-manager.ts`, updated `agent.ts` with approval gate, updated `tool-registry.ts` with approval metadata.
</objective>

<execution_context>
@C:\Users\hello\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\hello\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source files:
@nexus/packages/core/src/types.ts (Tool interface to extend)
@nexus/packages/core/src/tool-registry.ts (ToolRegistry — needs approval metadata passthrough)
@nexus/packages/core/src/agent.ts (AgentLoop — needs approval gate before tool execution)
@nexus/packages/core/src/daemon.ts (registers tools — some need requiresApproval: true)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add requiresApproval to Tool type, create ApprovalManager</name>
  <files>nexus/packages/core/src/types.ts, nexus/packages/core/src/approval-manager.ts, nexus/packages/core/src/tool-registry.ts</files>
  <action>
**In types.ts:**

Add `requiresApproval` to the Tool interface:
```typescript
export interface Tool {
  name: string;
  description: string;
  parameters: ToolParameter[];
  execute: (params: Record<string, unknown>) => Promise<ToolResult>;
  /** If true, agent must get user approval before executing this tool */
  requiresApproval?: boolean;
}
```

Add approval-related types:
```typescript
/** Pending tool approval request */
export interface ApprovalRequest {
  id: string;                    // UUID
  sessionId: string;             // Agent session that triggered this
  tool: string;                  // Tool name
  params: Record<string, unknown>; // Tool parameters
  thought: string;               // Agent's reasoning for calling this tool
  status: 'pending' | 'approved' | 'denied' | 'expired';
  createdAt: number;             // Unix timestamp ms
  expiresAt: number;             // Unix timestamp ms
  resolvedAt?: number;           // When resolved
  resolvedBy?: string;           // Who approved/denied (channel, user ID)
  resolvedFrom?: string;         // Which channel (web, telegram, slack, etc.)
}

/** Response to an approval request */
export interface ApprovalResponse {
  requestId: string;
  decision: 'approve' | 'deny';
  respondedBy?: string;          // User/channel identifier
  respondedFrom?: string;        // Channel type
}
```

**Create approval-manager.ts:**

```typescript
import { randomUUID } from 'node:crypto';
import type Redis from 'ioredis';
import type { ApprovalRequest, ApprovalResponse } from './types.js';
import { logger } from './logger.js';

const APPROVAL_KEY_PREFIX = 'nexus:approval:';
const APPROVAL_CHANNEL = 'nexus:notify:approval';
const APPROVAL_RESPONSE_PREFIX = 'nexus:approval:response:';
const DEFAULT_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes

export class ApprovalManager {
  constructor(private redis: Redis) {}

  /** Create a pending approval request. Publishes to notification channel. Returns the request. */
  async createRequest(opts: {
    sessionId: string;
    tool: string;
    params: Record<string, unknown>;
    thought: string;
    timeoutMs?: number;
  }): Promise<ApprovalRequest> {
    const id = randomUUID();
    const now = Date.now();
    const timeoutMs = opts.timeoutMs ?? DEFAULT_TIMEOUT_MS;

    const request: ApprovalRequest = {
      id,
      sessionId: opts.sessionId,
      tool: opts.tool,
      params: opts.params,
      thought: opts.thought,
      status: 'pending',
      createdAt: now,
      expiresAt: now + timeoutMs,
    };

    // Store in Redis with TTL
    const ttlSec = Math.ceil(timeoutMs / 1000) + 60; // Extra 60s for cleanup
    await this.redis.set(
      `${APPROVAL_KEY_PREFIX}${id}`,
      JSON.stringify(request),
      'EX',
      ttlSec
    );

    // Publish notification so WebSocket clients and channels can display the prompt
    await this.redis.publish(APPROVAL_CHANNEL, JSON.stringify({
      channel: 'approval',
      event: 'approval_request',
      data: request,
      timestamp: now,
    }));

    logger.info('ApprovalManager: created request', { id, tool: opts.tool, sessionId: opts.sessionId });
    return request;
  }

  /** Wait for an approval response. Uses Redis BLPOP on a response key. Returns the decision. */
  async waitForResponse(requestId: string, timeoutMs?: number): Promise<ApprovalResponse | null> {
    const timeout = timeoutMs ?? DEFAULT_TIMEOUT_MS;
    const timeoutSec = Math.ceil(timeout / 1000);
    const responseKey = `${APPROVAL_RESPONSE_PREFIX}${requestId}`;

    // BLPOP blocks until a response is pushed or timeout
    // Need a dedicated connection to avoid blocking the main Redis connection
    const subRedis = this.redis.duplicate();
    try {
      const result = await subRedis.blpop(responseKey, timeoutSec);
      if (!result) {
        // Timeout — mark as expired
        await this.updateRequestStatus(requestId, 'expired');
        return null;
      }

      const [, value] = result;
      const response: ApprovalResponse = JSON.parse(value);

      // Update the request status
      const status = response.decision === 'approve' ? 'approved' : 'denied';
      await this.updateRequestStatus(requestId, status, response.respondedBy, response.respondedFrom);

      return response;
    } finally {
      await subRedis.quit().catch(() => {});
    }
  }

  /** Resolve a pending approval (called by any channel: WebSocket, Telegram, Slack, HTTP API) */
  async resolve(response: ApprovalResponse): Promise<boolean> {
    const requestKey = `${APPROVAL_KEY_PREFIX}${response.requestId}`;
    const stored = await this.redis.get(requestKey);
    if (!stored) return false; // Expired or not found

    const request: ApprovalRequest = JSON.parse(stored);
    if (request.status !== 'pending') return false; // Already resolved

    // Push response to the waiting BLPOP
    const responseKey = `${APPROVAL_RESPONSE_PREFIX}${response.requestId}`;
    await this.redis.lpush(responseKey, JSON.stringify(response));

    // Publish resolution notification
    await this.redis.publish(APPROVAL_CHANNEL, JSON.stringify({
      channel: 'approval',
      event: 'approval_resolved',
      data: { ...request, status: response.decision === 'approve' ? 'approved' : 'denied', resolvedBy: response.respondedBy, resolvedFrom: response.respondedFrom },
      timestamp: Date.now(),
    }));

    logger.info('ApprovalManager: resolved', { requestId: response.requestId, decision: response.decision, by: response.respondedBy });
    return true;
  }

  /** Get a pending approval request by ID */
  async getRequest(requestId: string): Promise<ApprovalRequest | null> {
    const stored = await this.redis.get(`${APPROVAL_KEY_PREFIX}${requestId}`);
    return stored ? JSON.parse(stored) : null;
  }

  /** List all pending approval requests */
  async listPending(): Promise<ApprovalRequest[]> {
    // Scan for pending approvals
    const keys: string[] = [];
    let cursor = '0';
    do {
      const [nextCursor, results] = await this.redis.scan(cursor, 'MATCH', `${APPROVAL_KEY_PREFIX}*`, 'COUNT', 100);
      cursor = nextCursor;
      // Filter out response keys
      keys.push(...results.filter(k => !k.includes(':response:')));
    } while (cursor !== '0');

    if (keys.length === 0) return [];

    const values = await this.redis.mget(...keys);
    return values
      .filter((v): v is string => v !== null)
      .map(v => JSON.parse(v) as ApprovalRequest)
      .filter(r => r.status === 'pending' && r.expiresAt > Date.now());
  }

  private async updateRequestStatus(
    requestId: string,
    status: ApprovalRequest['status'],
    resolvedBy?: string,
    resolvedFrom?: string,
  ) {
    const key = `${APPROVAL_KEY_PREFIX}${requestId}`;
    const stored = await this.redis.get(key);
    if (!stored) return;

    const request: ApprovalRequest = JSON.parse(stored);
    request.status = status;
    request.resolvedAt = Date.now();
    if (resolvedBy) request.resolvedBy = resolvedBy;
    if (resolvedFrom) request.resolvedFrom = resolvedFrom;

    // Keep for 24h after resolution (for audit trail)
    await this.redis.set(key, JSON.stringify(request), 'EX', 86400);
  }
}
```

**In tool-registry.ts:**

Update `toolToClaudeDefinition` and `toJsonSchemas` methods to pass through `requiresApproval` metadata. This is informational — the actual enforcement happens in the agent loop.

Add a helper method:
```typescript
/** Check if a specific tool requires approval */
requiresApproval(toolName: string): boolean {
  const tool = this.tools.get(toolName);
  return tool?.requiresApproval === true;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core — zero TypeScript errors.
Grep for `requiresApproval` in types.ts — should appear in Tool interface.
Verify approval-manager.ts exists and contains ApprovalManager class with createRequest, waitForResponse, resolve methods.
  </verify>
  <done>
Tool interface extended with requiresApproval. ApprovalManager handles the full approval lifecycle (create, wait, resolve, list). ToolRegistry has requiresApproval() helper. Approval requests stored in Redis with TTL, communicated via pub/sub.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add approval gate to AgentLoop before destructive tool execution</name>
  <files>nexus/packages/core/src/agent.ts</files>
  <action>
**Extend AgentConfig:**
```typescript
export interface AgentConfig {
  // ... existing fields ...
  /** ApprovalManager for human-in-the-loop tool approval */
  approvalManager?: ApprovalManager;
  /** Session ID for this agent run (used for approval tracking) */
  sessionId?: string;
  /** Approval policy: 'always' = all tools, 'destructive' = only requiresApproval tools, 'never' = skip */
  approvalPolicy?: 'always' | 'destructive' | 'never';
}
```

**Add approval gate in the agent loop:**

The approval check goes AFTER the agent decides to call a tool but BEFORE executing it. This applies to BOTH the Claude native tool calling path and the Gemini JSON-in-text path.

Create a private method:
```typescript
private async checkApproval(
  toolName: string,
  params: Record<string, unknown>,
  thought: string,
  turn: number,
): Promise<{ approved: boolean; deniedReason?: string }> {
  const { approvalManager, toolRegistry, sessionId } = this.config;
  const policy = this.config.approvalPolicy ?? 'destructive';

  // Skip if no approval manager or policy is 'never'
  if (!approvalManager || policy === 'never') {
    return { approved: true };
  }

  // Check if this tool needs approval
  const needsApproval = policy === 'always' || toolRegistry.requiresApproval(toolName);
  if (!needsApproval) {
    return { approved: true };
  }

  // Emit approval_request event for streaming clients
  this.emitEvent({
    type: 'tool_call',
    turn,
    data: {
      tool: toolName,
      params,
      thought,
      awaitingApproval: true,
    },
  });

  // Create approval request and wait for response
  const request = await approvalManager.createRequest({
    sessionId: sessionId || 'unknown',
    tool: toolName,
    params,
    thought,
  });

  logger.info('Agent: awaiting approval', { requestId: request.id, tool: toolName, sessionId });

  const response = await approvalManager.waitForResponse(request.id);

  if (!response) {
    logger.warn('Agent: approval timed out', { requestId: request.id, tool: toolName });
    return { approved: false, deniedReason: 'Approval request timed out (5 minutes). Tool execution was skipped.' };
  }

  if (response.decision === 'deny') {
    logger.info('Agent: approval denied', { requestId: request.id, tool: toolName, by: response.respondedBy });
    return { approved: false, deniedReason: `Tool execution denied by ${response.respondedBy || 'user'}${response.respondedFrom ? ` via ${response.respondedFrom}` : ''}.` };
  }

  logger.info('Agent: approval granted', { requestId: request.id, tool: toolName, by: response.respondedBy });
  return { approved: true };
}
```

**Insert the approval check in BOTH code paths:**

1. **Claude native tool calling path** (inside the `if (nativeToolUseBlocks.length > 0)` block, in the `for (const toolCall of nativeToolUseBlocks)` loop):
   - BEFORE `toolResult = await toolRegistry.execute(toolCall.name, toolCall.input);`
   - Add:
   ```typescript
   // Approval gate
   const approval = await this.checkApproval(toolCall.name, toolCall.input, responseText.slice(0, 200), turn + 1);
   if (!approval.approved) {
     toolResult = { success: false, output: '', error: approval.deniedReason || 'Tool execution denied.' };
   } else {
     // Proceed with existing execution logic
   }
   ```

2. **Gemini JSON-in-text path** (in the `// Tool call` section after `step.type === 'tool_call'`):
   - BEFORE `toolResult = await toolRegistry.execute(step.tool, step.params);`
   - Add the same approval gate check

**Important:** The approval gate wraps AROUND the existing tool execution, including the spawn_subagent and policy checks. The check order is:
1. Is tool allowed by policy? (existing check)
2. Does tool require approval? (NEW check)
3. Execute tool (existing)

If approval is denied, the tool result is a failure with the denial reason, and the agent can try a different approach on the next turn.

**Also: Add `sessionId` auto-generation if not provided:**
```typescript
// At the start of run():
const sessionId = this.config.sessionId || randomUUID();
```
Import `randomUUID` from `node:crypto`.
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core — zero TypeScript errors.
Grep for `checkApproval` in agent.ts — should appear as a private method and be called in both Claude and Gemini code paths.
Grep for `approvalManager` in agent.ts — should appear in AgentConfig interface and in the checkApproval method.
  </verify>
  <done>
Agent loop has approval gate before destructive tool execution. Both Claude native and Gemini JSON-in-text paths check approval. Approval requests are created via ApprovalManager and the agent waits for response. Denied tools return error results so the agent can adapt. Timeout defaults to 5 minutes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Tool interface in types.ts has `requiresApproval?: boolean`
3. ApprovalRequest and ApprovalResponse types defined in types.ts
4. approval-manager.ts creates, waits, and resolves approval requests via Redis
5. agent.ts has checkApproval method called before tool execution in both code paths
6. AgentConfig has approvalManager, sessionId, and approvalPolicy fields
7. ToolRegistry has requiresApproval() helper method
</verification>

<success_criteria>
- Destructive tools can be flagged with `requiresApproval: true`
- Agent loop pauses and waits for human decision before executing flagged tools
- Approval requests are stored in Redis and published to notification channel
- Approved tools execute normally; denied tools return error to agent
- Timeout causes denial with informative message
- Both Claude and Gemini agent paths support the approval gate
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-04-websocket-gateway-hitl/v1.5-04-03-SUMMARY.md`
</output>
