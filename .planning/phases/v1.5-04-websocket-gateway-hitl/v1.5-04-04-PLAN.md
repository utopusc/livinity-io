---
phase: v1.5-04-websocket-gateway-hitl
plan: 04
type: execute
wave: 2
depends_on: ["v1.5-04-01", "v1.5-04-03"]
files_modified:
  - nexus/packages/core/src/config/schema.ts
  - nexus/packages/core/src/api.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/packages/core/src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can approve or deny a pending tool action via HTTP API endpoint POST /api/approvals/:id/resolve"
    - "User can list all pending approval requests via GET /api/approvals"
    - "Approval policy is configurable per user in NexusConfig (always/destructive/never)"
    - "All tool approval decisions are logged with who approved, what was approved, and when in a Redis sorted set"
    - "Audit trail is queryable via GET /api/approvals/audit endpoint"
    - "ApprovalManager is wired into the Daemon and passed to agent runs"
    - "Destructive built-in tools (shell rm/delete, docker stop/remove, file delete) are registered with requiresApproval: true"
  artifacts:
    - path: "nexus/packages/core/src/config/schema.ts"
      provides: "ApprovalPolicySchema in NexusConfig"
      contains: "approvalPolicy"
    - path: "nexus/packages/core/src/api.ts"
      provides: "Approval API endpoints (list, resolve, audit)"
      contains: "/api/approvals"
    - path: "nexus/packages/core/src/daemon.ts"
      provides: "ApprovalManager instantiation and wiring to agent runs"
      contains: "approvalManager"
    - path: "nexus/packages/core/src/index.ts"
      provides: "ApprovalManager created and passed to Daemon"
      contains: "ApprovalManager"
  key_links:
    - from: "nexus/packages/core/src/api.ts"
      to: "nexus/packages/core/src/approval-manager.ts"
      via: "API endpoints call approvalManager.resolve(), listPending(), getAuditTrail()"
      pattern: "approvalManager"
    - from: "nexus/packages/core/src/daemon.ts"
      to: "nexus/packages/core/src/agent.ts"
      via: "Pass approvalManager and approvalPolicy to AgentLoop constructor"
      pattern: "approvalManager.*AgentLoop|AgentLoop.*approvalManager"
    - from: "nexus/packages/core/src/index.ts"
      to: "nexus/packages/core/src/approval-manager.ts"
      via: "Instantiation of ApprovalManager with Redis"
      pattern: "new ApprovalManager"
---

<objective>
Complete the HITL system by wiring the ApprovalManager into the application, adding HTTP API endpoints for approval management, configuring approval policy in NexusConfig, adding audit trail logging, and marking destructive built-in tools with `requiresApproval: true`.

Purpose: The approval system needs to be accessible from multiple channels (HTTP API, WebSocket, messaging channels). The API endpoints enable any frontend or integration to resolve approvals. The audit trail provides accountability. The config schema makes the policy user-configurable.

Output: Approval API endpoints in `api.ts`, NexusConfig schema update, ApprovalManager wiring in `daemon.ts` and `index.ts`, destructive tools marked.
</objective>

<execution_context>
@C:\Users\hello\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\hello\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v1.5-04-websocket-gateway-hitl/v1.5-04-01-SUMMARY.md
@.planning/phases/v1.5-04-websocket-gateway-hitl/v1.5-04-03-SUMMARY.md

Key source files:
@nexus/packages/core/src/approval-manager.ts (from Plan 03 — ApprovalManager to extend)
@nexus/packages/core/src/api.ts (add approval API endpoints)
@nexus/packages/core/src/daemon.ts (wire ApprovalManager, mark destructive tools)
@nexus/packages/core/src/index.ts (create ApprovalManager instance)
@nexus/packages/core/src/config/schema.ts (add approval policy schema)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add approval policy to NexusConfig, wire ApprovalManager, mark destructive tools</name>
  <files>nexus/packages/core/src/config/schema.ts, nexus/packages/core/src/daemon.ts, nexus/packages/core/src/index.ts</files>
  <action>
**In config/schema.ts:**

Add approval policy schema:
```typescript
// ─── Approval Configuration ───────────────────────────────────────────────────

export const ApprovalPolicySchema = z.enum(['always', 'destructive', 'never']);

export const ApprovalConfigSchema = z.object({
  /** Policy: 'always' = approve all tools, 'destructive' = only requiresApproval tools, 'never' = auto-approve */
  policy: ApprovalPolicySchema.default('destructive'),
  /** Timeout in milliseconds for approval requests (default: 5 minutes) */
  timeoutMs: z.number().int().min(10000).max(3600000).default(300000),
  /** Whether to log all approvals to audit trail */
  auditEnabled: z.boolean().default(true),
}).strict().optional();
```

Add to NexusConfigSchema:
```typescript
export const NexusConfigSchema = z.object({
  // ... existing fields ...
  // Human-in-the-Loop
  approval: ApprovalConfigSchema,
}).strict();
```

Add to DEFAULT_NEXUS_CONFIG:
```typescript
approval: {
  policy: 'destructive',
  timeoutMs: 300000,
  auditEnabled: true,
},
```

Export the type:
```typescript
export type ApprovalConfig = z.infer<typeof ApprovalConfigSchema>;
```

**In index.ts:**

1. Import ApprovalManager:
```typescript
import { ApprovalManager } from './approval-manager.js';
```

2. Create instance after Redis is connected:
```typescript
const approvalManager = new ApprovalManager(redis);
logger.info('ApprovalManager initialized');
```

3. Pass to Daemon constructor:
```typescript
const daemon = new Daemon({
  // ... existing ...
  approvalManager,
});
```

4. Pass to createApiServer:
```typescript
const apiApp = createApiServer({ daemon, redis, brain, toolRegistry, mcpConfigManager, mcpRegistryClient, mcpClientManager, channelManager, approvalManager });
```

**In daemon.ts:**

1. Add `approvalManager` to DaemonConfig interface:
```typescript
interface DaemonConfig {
  // ... existing ...
  approvalManager?: ApprovalManager;
}
```

2. Expose via getter:
```typescript
get approvalManager(): ApprovalManager | undefined {
  return this.config.approvalManager;
}
```

3. In every place where AgentLoop is instantiated in daemon.ts (search for `new AgentLoop`), pass the approvalManager and policy:
```typescript
const nexusConfig = this.getNexusConfig();
const approvalPolicy = nexusConfig?.approval?.policy ?? 'destructive';

const agent = new AgentLoop({
  // ... existing config ...
  approvalManager: this.config.approvalManager,
  approvalPolicy,
  sessionId: crypto.randomUUID(),
});
```
Import `crypto` from `node:crypto` if not already imported.

4. Mark destructive built-in tools with `requiresApproval: true` in the `registerTools()` method. Find the tool registration calls and add the flag to these tools:
   - `shell` tool (runs arbitrary commands) — set `requiresApproval: true`
   - Any tool whose name/description includes "delete", "remove", "stop", "kill" patterns

   The simplest approach: after all tools are registered, iterate and mark specific ones:
   ```typescript
   // Mark destructive tools for approval
   const destructiveTools = ['shell']; // Shell can run rm, kill, etc.
   for (const toolName of destructiveTools) {
     const tool = this.config.toolRegistry.get(toolName);
     if (tool) {
       tool.requiresApproval = true;
     }
   }
   ```

   Note: The shell tool is the primary destructive tool since it can run any command. Docker management tools are also destructive but may be separate MCP tools. Only mark tools that actually exist in the registry.
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core — zero TypeScript errors.
Grep for `approvalManager` in daemon.ts — should appear in DaemonConfig, getter, and AgentLoop constructors.
Grep for `approvalPolicy` in config/schema.ts — should appear in schema definition.
Grep for `requiresApproval.*true` in daemon.ts — should appear for destructive tools.
  </verify>
  <done>
NexusConfig has approval policy configuration. ApprovalManager is instantiated in index.ts and passed to Daemon. Daemon passes approvalManager and policy to all AgentLoop instances. Shell tool is marked as requiresApproval.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add approval HTTP API endpoints and audit trail</name>
  <files>nexus/packages/core/src/api.ts, nexus/packages/core/src/approval-manager.ts</files>
  <action>
**In approval-manager.ts — add audit trail methods:**

```typescript
const AUDIT_KEY = 'nexus:approval:audit';

/** Log an approval decision to the audit trail (Redis sorted set, scored by timestamp) */
async logAudit(request: ApprovalRequest): Promise<void> {
  const entry = {
    requestId: request.id,
    sessionId: request.sessionId,
    tool: request.tool,
    params: request.params,
    thought: request.thought,
    status: request.status,
    createdAt: request.createdAt,
    resolvedAt: request.resolvedAt,
    resolvedBy: request.resolvedBy,
    resolvedFrom: request.resolvedFrom,
  };
  // Score by resolvedAt (or createdAt if not resolved)
  const score = request.resolvedAt || request.createdAt;
  await this.redis.zadd(AUDIT_KEY, score, JSON.stringify(entry));
  // Trim to last 1000 entries
  await this.redis.zremrangebyrank(AUDIT_KEY, 0, -1001);
}

/** Query audit trail. Returns entries in reverse chronological order. */
async getAuditTrail(opts?: { limit?: number; offset?: number }): Promise<unknown[]> {
  const limit = opts?.limit ?? 50;
  const offset = opts?.offset ?? 0;
  const entries = await this.redis.zrevrange(AUDIT_KEY, offset, offset + limit - 1);
  return entries.map(e => JSON.parse(e));
}
```

Update `updateRequestStatus` to also call `logAudit` after updating the request:
```typescript
// At the end of updateRequestStatus:
await this.logAudit(request);
```

**In api.ts — add approval endpoints:**

Update ApiDeps interface:
```typescript
interface ApiDeps {
  // ... existing ...
  approvalManager?: ApprovalManager;
}
```

Import ApprovalManager:
```typescript
import type { ApprovalManager } from './approval-manager.js';
```

Add approval routes (AFTER the existing authenticated routes section):
```typescript
// ── Approval Management API ────────────────────────────────────────

/** List pending approval requests */
app.get('/api/approvals', async (_req, res) => {
  if (!approvalManager) {
    res.status(503).json({ error: 'Approval system not configured' });
    return;
  }
  try {
    const pending = await approvalManager.listPending();
    res.json({ approvals: pending });
  } catch (err) {
    res.status(500).json({ error: formatErrorMessage(err) });
  }
});

/** Get a specific approval request */
app.get('/api/approvals/:id', async (req, res) => {
  if (!approvalManager) {
    res.status(503).json({ error: 'Approval system not configured' });
    return;
  }
  try {
    const request = await approvalManager.getRequest(req.params.id);
    if (!request) {
      res.status(404).json({ error: 'Approval request not found' });
      return;
    }
    res.json(request);
  } catch (err) {
    res.status(500).json({ error: formatErrorMessage(err) });
  }
});

/** Resolve (approve/deny) an approval request */
app.post('/api/approvals/:id/resolve', async (req, res) => {
  if (!approvalManager) {
    res.status(503).json({ error: 'Approval system not configured' });
    return;
  }
  try {
    const { decision } = req.body;
    if (decision !== 'approve' && decision !== 'deny') {
      res.status(400).json({ error: '"decision" must be "approve" or "deny"' });
      return;
    }
    const resolved = await approvalManager.resolve({
      requestId: req.params.id,
      decision,
      respondedBy: req.headers['x-user-id'] as string || 'api',
      respondedFrom: 'http-api',
    });
    if (!resolved) {
      res.status(404).json({ error: 'Approval request not found or already resolved' });
      return;
    }
    res.json({ ok: true, decision });
  } catch (err) {
    res.status(500).json({ error: formatErrorMessage(err) });
  }
});

/** Get audit trail of approval decisions */
app.get('/api/approvals/audit', async (req, res) => {
  if (!approvalManager) {
    res.status(503).json({ error: 'Approval system not configured' });
    return;
  }
  try {
    const limit = parseInt(req.query.limit as string) || 50;
    const offset = parseInt(req.query.offset as string) || 0;
    const trail = await approvalManager.getAuditTrail({ limit, offset });
    res.json({ audit: trail });
  } catch (err) {
    res.status(500).json({ error: formatErrorMessage(err) });
  }
});
```

IMPORTANT: The `/api/approvals/audit` route must be defined BEFORE the `/api/approvals/:id` route, otherwise Express will match "audit" as an `:id` parameter. Reorder so specific routes come first:
```
GET /api/approvals/audit    <-- specific, define first
GET /api/approvals          <-- list all
GET /api/approvals/:id      <-- parameterized, define last
POST /api/approvals/:id/resolve
```

Also add an `approval.resolve` method to the WebSocket gateway's method router (in ws-gateway.ts) so WebSocket clients can also resolve approvals:
- Method: `approval.resolve`
- Params: `{ requestId: string, decision: 'approve' | 'deny' }`
- Uses the same approvalManager.resolve() call

Update WsGatewayDeps to include approvalManager and add the method handler.
  </action>
  <verify>
Run `npx tsc --noEmit` in nexus/packages/core — zero TypeScript errors.
Grep for `/api/approvals` in api.ts — should appear for list, get, resolve, and audit endpoints.
Grep for `logAudit` in approval-manager.ts — should appear in updateRequestStatus and as a method.
Grep for `approval.resolve` in ws-gateway.ts — should appear as a method handler.
  </verify>
  <done>
Approval API endpoints exist for listing pending requests, resolving them (approve/deny), and querying audit trail. Audit trail logs every approval decision to Redis sorted set with who, what, and when. WebSocket gateway also supports approval.resolve method. ApprovalManager wired into api.ts.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. NexusConfig has `approval` section with policy, timeoutMs, auditEnabled
3. API endpoints exist: GET /api/approvals, GET /api/approvals/audit, GET /api/approvals/:id, POST /api/approvals/:id/resolve
4. ApprovalManager is instantiated in index.ts and wired through Daemon to AgentLoop
5. Shell tool marked with requiresApproval: true in daemon.ts
6. Audit trail stored in Redis sorted set, queryable via API
7. WebSocket gateway has approval.resolve method
</verification>

<success_criteria>
- User can approve/deny pending tool actions via HTTP API or WebSocket
- Approval policy is configurable in NexusConfig (always/destructive/never)
- All approval decisions are logged with who, what, and when
- Audit trail is queryable via API endpoint
- Destructive tools (shell) are pre-marked with requiresApproval flag
- The full HITL pipeline works: agent calls destructive tool -> approval request created -> user resolves via API -> agent proceeds or adapts
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-04-websocket-gateway-hitl/v1.5-04-04-SUMMARY.md`
</output>
