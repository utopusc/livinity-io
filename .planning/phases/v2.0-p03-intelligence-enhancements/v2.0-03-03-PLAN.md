---
phase: v2.0-p03-intelligence-enhancements
plan: 03
type: execute
wave: 2
depends_on: ["v2.0-03-02"]
files_modified:
  - nexus/packages/core/src/multi-agent.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/packages/core/src/index.ts
autonomous: true

must_haves:
  truths:
    - "When sessions_create is called, a BullMQ job is enqueued that runs the sub-agent task through SdkAgentRunner"
    - "Sub-agents are limited to max 8 turns and 50k token budget"
    - "Sub-agents cannot spawn further sub-agents (DAG topology, fork bomb prevention)"
    - "Maximum 2 concurrent sub-agents on the VPS, additional requests queued"
    - "Sub-agent results are written back to the session and visible via sessions_history"
  artifacts:
    - path: "nexus/packages/core/src/index.ts"
      provides: "BullMQ queue and worker for sub-agent execution"
      contains: "nexus-multi-agent"
    - path: "nexus/packages/core/src/daemon.ts"
      provides: "sessions_create tool enqueues BullMQ job instead of just storing state"
      contains: "multiAgentQueue"
    - path: "nexus/packages/core/src/multi-agent.ts"
      provides: "executeSubAgent method that runs SdkAgentRunner with DAG enforcement"
      contains: "executeSubAgent"
  key_links:
    - from: "nexus/packages/core/src/daemon.ts (sessions_create tool)"
      to: "BullMQ queue"
      via: "Tool enqueues job to nexus-multi-agent queue"
      pattern: "multiAgentQueue\\.add"
    - from: "nexus/packages/core/src/index.ts (BullMQ worker)"
      to: "nexus/packages/core/src/multi-agent.ts"
      via: "Worker calls multiAgentManager.executeSubAgent"
      pattern: "executeSubAgent"
    - from: "nexus/packages/core/src/multi-agent.ts (executeSubAgent)"
      to: "nexus/packages/core/src/sdk-agent-runner.ts"
      via: "Creates SdkAgentRunner with restricted config (no sub-agent spawning)"
      pattern: "SdkAgentRunner"
---

<objective>
Wire sub-agent execution through BullMQ with concurrency control, DAG topology enforcement, turn/token limits, and result delivery back to the parent session.

Purpose: Plan 02 created the MCP tools and session management infrastructure. This plan adds the actual execution engine — a BullMQ worker that processes sub-agent tasks through SdkAgentRunner with strict resource limits, preventing fork bombs (no recursive sub-agents) and enforcing a maximum of 2 concurrent sub-agents. Results flow back to the session for the parent agent to read.

Output: BullMQ queue (nexus-multi-agent) with concurrency-2 worker, SdkAgentRunner integration with DAG enforcement, sessions_create tool updated to enqueue jobs, result delivery to session history.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key existing files (read Plan 02 SUMMARY for latest state):
@nexus/packages/core/src/multi-agent.ts — MultiAgentManager from Plan 02
@nexus/packages/core/src/sdk-agent-runner.ts — SdkAgentRunner for Claude Code SDK execution
@nexus/packages/core/src/daemon.ts — sessions_create tool from Plan 02, registerTools()
@nexus/packages/core/src/index.ts — BullMQ patterns (memory extraction, cron, webhook workers)
@nexus/packages/core/src/agent.ts — AgentConfig, AgentResult types
@nexus/packages/core/src/brain.ts — Brain class for LLM calls
@nexus/packages/core/src/tool-registry.ts — ToolRegistry for scoped tool access

Prior plan to reference:
@.planning/phases/v2.0-p03-intelligence-enhancements/v2.0-03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add executeSubAgent to MultiAgentManager and BullMQ worker</name>
  <files>nexus/packages/core/src/multi-agent.ts, nexus/packages/core/src/index.ts</files>
  <action>
**In multi-agent.ts:**

1. Add imports needed for execution:
   ```typescript
   import { SdkAgentRunner } from './sdk-agent-runner.js';
   import type { Brain } from './brain.js';
   import type { ToolRegistry } from './tool-registry.js';
   import type { NexusConfig } from './config/schema.js';
   ```

2. Update constructor config to accept optional execution dependencies:
   ```typescript
   constructor(config: {
     redis: Redis;
     maxConcurrent?: number;
     brain?: Brain;
     toolRegistry?: ToolRegistry;
     nexusConfig?: NexusConfig;
   })
   ```
   Store brain, toolRegistry, nexusConfig as private fields.

3. Add `executeSubAgent(sessionId: string): Promise<void>` method:
   ```typescript
   async executeSubAgent(sessionId: string): Promise<void> {
     const session = await this.get(sessionId);
     if (!session) throw new Error(`Session ${sessionId} not found`);
     if (!this.brain || !this.toolRegistry) throw new Error('Execution dependencies not configured');

     // MULTI-07: DAG topology — sub-agents CANNOT spawn further sub-agents
     // We enforce this by NOT including sessions_create/sessions_send tools
     // and by setting a restricted system prompt.

     // Update status to running
     await this.updateStatus(sessionId, { status: 'running', updatedAt: Date.now() });

     try {
       // Build a restricted tool registry — exclude multi-agent tools to prevent fork bombs
       const restrictedToolNames = this.toolRegistry.list().filter(
         name => !name.startsWith('sessions_')
       );

       // Build context from session history (messages sent to this sub-agent)
       const history = await this.getHistory(sessionId);
       const historyContext = history.length > 0
         ? history.map(m => `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`).join('\n\n')
         : '';

       const taskWithContext = historyContext
         ? `## Prior Context\n${historyContext}\n\n## Task\n${session.task}`
         : session.task;

       // Create SdkAgentRunner with restricted config
       const runner = new SdkAgentRunner({
         brain: this.brain,
         toolRegistry: this.toolRegistry,
         nexusConfig: this.nexusConfig,
         maxTurns: session.maxTurns, // MULTI-05: Limited to 8 turns
         tier: 'sonnet',
         stream: false, // Sub-agents don't stream
         systemPromptOverride: `You are a focused sub-agent working on a specific task. Complete the task efficiently and provide a clear, concise result. You do NOT have access to session management tools — you cannot spawn further sub-agents. Focus only on the task assigned to you.`,
       });

       const result = await runner.run(taskWithContext);

       // Store result in session
       await this.updateStatus(sessionId, {
         status: result.success ? 'completed' : 'failed',
         result: result.answer,
         error: result.success ? undefined : result.answer,
         turns: result.turns,
         inputTokens: result.totalInputTokens,
         outputTokens: result.totalOutputTokens,
         updatedAt: Date.now(),
       });

       // Add the result as an assistant message in history
       await this.addMessage(sessionId, {
         role: 'assistant',
         content: result.answer,
         timestamp: Date.now(),
       });

       logger.info('MultiAgentManager: sub-agent completed', {
         sessionId: sessionId.slice(0, 8),
         success: result.success,
         turns: result.turns,
         inputTokens: result.totalInputTokens,
         outputTokens: result.totalOutputTokens,
       });
     } catch (err: any) {
       await this.updateStatus(sessionId, {
         status: 'failed',
         error: err.message,
         updatedAt: Date.now(),
       });

       await this.addMessage(sessionId, {
         role: 'assistant',
         content: `Sub-agent error: ${err.message}`,
         timestamp: Date.now(),
       });

       logger.error('MultiAgentManager: sub-agent execution failed', {
         sessionId: sessionId.slice(0, 8),
         error: err.message,
       });
     }
   }
   ```

**In index.ts:**

1. Import MultiAgentManager: `import { MultiAgentManager } from './multi-agent.js';`

2. Update the MultiAgentManager initialization to include execution dependencies:
   ```typescript
   const multiAgentManager = new MultiAgentManager({
     redis,
     maxConcurrent: 2,
     brain,
     toolRegistry,
     nexusConfig: configManager.get(),
   });
   ```

3. After the MultiAgentManager initialization, create BullMQ queue and worker:
   ```typescript
   // ── Multi-agent sub-agent execution queue (BullMQ) ──────────
   const multiAgentQueue = new Queue('nexus-multi-agent', {
     connection: bullConnection,
     defaultJobOptions: {
       removeOnComplete: { count: 50 },
       removeOnFail: { count: 25 },
     },
   });

   const multiAgentWorker = new Worker(
     'nexus-multi-agent',
     async (job) => {
       const { sessionId } = job.data;
       logger.info('Multi-agent worker: executing sub-agent', { sessionId: sessionId?.slice(0, 8) });
       try {
         await multiAgentManager.executeSubAgent(sessionId);
       } catch (err: any) {
         logger.error('Multi-agent worker: job failed', { sessionId: sessionId?.slice(0, 8), error: err.message });
         throw err; // Let BullMQ handle retry/fail
       }
     },
     {
       connection: bullConnection,
       concurrency: 2, // MULTI-06: Maximum 2 concurrent sub-agents
     },
   );

   multiAgentWorker.on('failed', (job, err) => {
     logger.error('Multi-agent worker: job failed', { jobId: job?.id, error: err.message });
   });

   logger.info('Multi-agent execution pipeline initialized', { concurrency: 2 });
   ```

4. Add `multiAgentQueue` to the Daemon constructor call:
   Add the queue to the DaemonConfig so the sessions_create tool can enqueue jobs.
  </action>
  <verify>
Run `npx tsc --noEmit --project nexus/packages/core/tsconfig.json` to verify TypeScript compiles. Grep for `nexus-multi-agent` in index.ts to confirm BullMQ queue and worker are created. Grep for `executeSubAgent` in multi-agent.ts to confirm the execution method exists.
  </verify>
  <done>
BullMQ queue (nexus-multi-agent) with concurrency-2 worker processes sub-agent tasks via SdkAgentRunner. DAG topology enforced by excluding sessions_* tools from sub-agent's available tools. Results written back to session Redis state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire sessions_create to enqueue BullMQ jobs</name>
  <files>nexus/packages/core/src/daemon.ts</files>
  <action>
1. Add to DaemonConfig interface:
   ```typescript
   multiAgentQueue?: Queue;
   ```

2. Update the `sessions_create` tool in registerTools() to enqueue a BullMQ job after creating the session:

   After the `this.config.multiAgentManager.create(...)` call succeeds, add:
   ```typescript
   // Enqueue BullMQ job for sub-agent execution
   if (this.config.multiAgentQueue) {
     await this.config.multiAgentQueue.add('execute-sub-agent', {
       sessionId: session.id,
     }, {
       removeOnComplete: { count: 50 },
       removeOnFail: { count: 25 },
     });
     logger.info('Sub-agent job enqueued', { sessionId: session.id.slice(0, 8), task: session.task.slice(0, 80) });
   } else {
     logger.warn('sessions_create: multiAgentQueue not available, sub-agent will not execute');
   }
   ```

   Update the success output to indicate the sub-agent is being processed:
   ```typescript
   return {
     success: true,
     output: `Sub-agent session created and queued for execution.\nID: ${session.id}\nTask: ${session.task}\nMax turns: ${session.maxTurns}\nStatus: pending\n\nUse sessions_history with this ID to check progress and results.`,
     data: session,
   };
   ```

3. Update the `sessions_send` tool to also enqueue a BullMQ job after adding the message:

   After the `addMessage` and `updateStatus` calls, add:
   ```typescript
   // Enqueue job for the sub-agent to process the new message
   if (this.config.multiAgentQueue) {
     await this.config.multiAgentQueue.add('execute-sub-agent', {
       sessionId: params.session_id as string,
     }, {
       removeOnComplete: { count: 50 },
       removeOnFail: { count: 25 },
     });
   }
   ```

4. In index.ts, add `multiAgentQueue` to the Daemon constructor call, right after `multiAgentManager`:
   ```typescript
   multiAgentManager,
   multiAgentQueue,
   ```
  </action>
  <verify>
Run `npx tsc --noEmit --project nexus/packages/core/tsconfig.json` to verify TypeScript compiles. Grep for `multiAgentQueue` in daemon.ts to confirm it is used in sessions_create and sessions_send tools. Grep for `execute-sub-agent` to confirm BullMQ job names.
  </verify>
  <done>
sessions_create and sessions_send tools enqueue BullMQ jobs that trigger sub-agent execution. The worker picks up jobs with concurrency 2, runs them through SdkAgentRunner with DAG-enforced restrictions, and writes results back to the session. The full loop is complete: create session -> enqueue job -> worker executes -> results in session history.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles cleanly: `npx tsc --noEmit --project nexus/packages/core/tsconfig.json`
2. BullMQ queue 'nexus-multi-agent' created in index.ts with concurrency 2
3. executeSubAgent() in MultiAgentManager creates SdkAgentRunner without sessions_* tools (DAG enforcement)
4. sessions_create tool enqueues BullMQ job after creating session
5. sessions_send tool enqueues BullMQ job after adding message
6. Sub-agent results are written to session state (status, result, turns, tokens)
7. Sub-agent system prompt explicitly states it cannot spawn further sub-agents
8. Turn limit enforced at 8, token budget at 50k
</verification>

<success_criteria>
- MULTI-05: Sub-agents are limited to max 8 turns and 50k token budget (enforced in create() and SdkAgentRunner config)
- MULTI-06: Maximum 2 concurrent sub-agents on the VPS (BullMQ worker concurrency 2)
- MULTI-07: DAG topology enforced — sub-agents cannot spawn further sub-agents (sessions_* tools excluded, system prompt restriction)
- End-to-end flow: sessions_create -> BullMQ job -> SdkAgentRunner execution -> result in sessions_history
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p03-intelligence-enhancements/v2.0-03-03-SUMMARY.md`
</output>
