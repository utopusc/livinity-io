---
phase: v2.0-p03-intelligence-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/session-manager.ts
  - nexus/packages/core/src/commands.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/packages/core/src/index.ts
autonomous: true

must_haves:
  truths:
    - "When a session exceeds 100k tokens, older messages are automatically summarized while the last 10 messages are preserved verbatim"
    - "Critical facts (file paths, error codes, user preferences) are never lost during compaction"
    - "User can send /compact and see a report with token savings percentage"
    - "Compacted session state is stored in Redis with the session"
  artifacts:
    - path: "nexus/packages/core/src/session-manager.ts"
      provides: "compactSession() method with tiered summarization, critical fact pinning, token estimation"
      contains: "compactSession"
    - path: "nexus/packages/core/src/commands.ts"
      provides: "Full /compact command implementation with token savings report"
      contains: "handleCompact"
  key_links:
    - from: "nexus/packages/core/src/session-manager.ts"
      to: "Brain.think()"
      via: "SessionManager calls brain.think with haiku tier for summarization"
      pattern: "brain\\.think.*haiku"
    - from: "nexus/packages/core/src/daemon.ts"
      to: "nexus/packages/core/src/session-manager.ts"
      via: "processInboxItem checks token count after agent run and calls compactSession"
      pattern: "compactSession"
    - from: "nexus/packages/core/src/commands.ts"
      to: "nexus/packages/core/src/session-manager.ts"
      via: "/compact command calls compactSession and reports savings"
      pattern: "compactSession"
---

<objective>
Implement session compaction that automatically summarizes old conversation history to prevent context window exhaustion, with manual /compact command support.

Purpose: Long conversations currently grow unbounded in the session history, risking context window limits. This plan adds automatic compaction at 100k tokens and a manual /compact command, using the Brain (haiku tier) to summarize older messages while preserving the last 10 messages and critical facts verbatim.

Output: SessionManager gains compactSession() method, /compact command becomes functional, auto-compaction triggers after agent runs when session exceeds 100k tokens, compacted state stored in Redis.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key existing files:
@nexus/packages/core/src/session-manager.ts â€” SessionManager with history, getHistory, addToHistory, pruneHistory
@nexus/packages/core/src/commands.ts â€” handleCompact stub returning "coming soon"
@nexus/packages/core/src/daemon.ts â€” processInboxItem, agent run, usage tracking
@nexus/packages/core/src/brain.ts â€” Brain.think() for LLM calls with tier selection
@nexus/packages/core/src/usage-tracker.ts â€” UsageTracker with token counting patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement compactSession() in SessionManager</name>
  <files>nexus/packages/core/src/session-manager.ts</files>
  <action>
Add the following to SessionManager:

1. **Token estimation helper**: Add a `estimateTokenCount(text: string): number` method that estimates tokens as `Math.ceil(text.length / 4)` (standard approximation for English text). This is used to check the 100k threshold and report savings.

2. **Critical fact extraction**: Add a `extractCriticalFacts(messages: Array<{role, content, timestamp}>): string[]` method that scans messages for:
   - File paths (regex: `/\/[\w\/\-\.]+\.\w+/g` and `C:\\` Windows paths)
   - Error codes/patterns (regex: `/\b(ERR_\w+|E\d{4,}|error\s*code\s*[:=]\s*\S+)/gi`)
   - User preferences explicitly stated (messages containing "prefer", "always", "never", "don't like", "I want")
   - IP addresses, port numbers, URLs
   - Return as array of strings like `"[PINNED] <fact>"`

3. **compactSession() method**: Add `async compactSession(senderId: string | undefined, brain: Brain): Promise<{savedTokens: number, originalTokens: number, compactedMessages: number}>`:
   - Get full history via `getHistory(senderId)`
   - If history has <= 10 messages, return `{savedTokens: 0, originalTokens: estimateTokenCount(...), compactedMessages: 0}` (nothing to compact)
   - Split into: `preservedMessages` (last 10) and `olderMessages` (everything before)
   - Extract critical facts from ALL messages (both older and preserved)
   - Calculate `originalTokens` from all messages
   - Build summarization prompt: "Summarize the following conversation history concisely, preserving key decisions, outcomes, and context. Focus on WHAT was discussed and decided, not the back-and-forth.\n\n" + formatted older messages
   - Call `brain.think({ prompt: summarizationPrompt, systemPrompt: 'You are a conversation summarizer. Return a concise summary preserving key facts, decisions, and outcomes. Keep it under 500 words.', tier: 'haiku', maxTokens: 1000 })`
   - Build compacted history: `[{role: 'user', content: '[COMPACTED SUMMARY]\n' + summary + '\n\n[CRITICAL FACTS]\n' + facts.join('\n'), timestamp: Date.now()}]` + preservedMessages
   - Clear existing history key and write the compacted history back
   - Store compaction metadata in the session state's `context` field: `{ lastCompactedAt: Date.now(), compactionCount: (prev + 1), savedTokens }`
   - Calculate `savedTokens = originalTokens - newTokens`
   - Return the savings report

4. **getSessionTokenCount() method**: Add `async getSessionTokenCount(senderId: string | undefined): Promise<number>` that gets the full history and returns `estimateTokenCount` of all messages concatenated. This is used by the auto-compact check.

5. **Update SessionState interface**: Add optional `compactedSummary?: string` field for the stored summary text.

6. **Redis storage**: The compacted state is stored via the existing `saveSession()` and `addToHistory()` methods (the compacted history replaces the full history in the same Redis list key). No new Redis keys needed.

IMPORTANT: The Brain instance is NOT stored on SessionManager. It is passed as a parameter to compactSession() to avoid adding a dependency to the constructor. This matches the existing pattern where SessionManager only depends on Redis.
  </action>
  <verify>
Run `npx tsc --noEmit --project nexus/packages/core/tsconfig.json` to verify TypeScript compiles without errors. Grep for `compactSession` in session-manager.ts to confirm the method exists.
  </verify>
  <done>
SessionManager has compactSession() that summarizes older messages via Brain haiku, preserves last 10 messages verbatim, extracts and pins critical facts, stores compacted state in Redis, and returns token savings report.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement /compact command and auto-compact trigger</name>
  <files>nexus/packages/core/src/commands.ts, nexus/packages/core/src/daemon.ts</files>
  <action>
**In commands.ts:**

1. Update the `CommandContext` interface to add:
   - `brain?: Brain` (import Brain from './brain.js')
   - These are needed for compactSession() call

2. Replace the `handleCompact()` stub with a full implementation:
   ```
   async function handleCompact(ctx: CommandContext): Promise<CommandResult> {
     if (!ctx.sessionManager || !ctx.brain) {
       return { handled: true, response: 'Session compaction is not available.' };
     }

     try {
       const result = await ctx.sessionManager.compactSession(ctx.jid, ctx.brain);

       if (result.savedTokens === 0) {
         return {
           handled: true,
           response: 'ðŸ“¦ *Compact*\n\nConversation is already compact (â‰¤10 messages). Nothing to compact.',
         };
       }

       const savingsPercent = Math.round((result.savedTokens / result.originalTokens) * 100);
       const response = `ðŸ“¦ *Compact Complete*\n\n` +
         `Messages compacted: ${result.compactedMessages}\n` +
         `Original tokens: ~${result.originalTokens.toLocaleString()}\n` +
         `Saved tokens: ~${result.savedTokens.toLocaleString()} (${savingsPercent}%)\n` +
         `Last 10 messages preserved verbatim.\n` +
         `Critical facts pinned.`;

       return { handled: true, response };
     } catch (err: any) {
       return {
         handled: true,
         response: `ðŸ“¦ *Compact Failed*\n\n${err.message}`,
       };
     }
   }
   ```

3. Update the handleCompact call in the switch statement to pass `ctx`: change `return handleCompact()` to `return handleCompact(ctx)`.

4. Update the /help command text: change `\`/compact\` - Compact conversation context (coming soon)` to `\`/compact\` - Compact conversation context`.

**In daemon.ts:**

1. In the `processInboxItem()` method (and the duplicate in `cycle()`), AFTER the usage tracking block (after `this.config.usageTracker.recordSession(...)` call), add auto-compaction check:
   ```
   // COMP-05: Auto-compact when session exceeds 100k token threshold
   if (this.config.sessionManager && intent.from) {
     const sessionTokens = await this.config.sessionManager.getSessionTokenCount(intent.from);
     if (sessionTokens > 100_000) {
       logger.info('Auto-compact triggered', { senderId: intent.from, sessionTokens });
       try {
         const compactResult = await this.config.sessionManager.compactSession(intent.from, this.config.brain);
         logger.info('Auto-compact complete', {
           senderId: intent.from,
           savedTokens: compactResult.savedTokens,
           compactedMessages: compactResult.compactedMessages,
         });
       } catch (err: any) {
         logger.error('Auto-compact failed', { senderId: intent.from, error: err.message });
       }
     }
   }
   ```
   This goes in the agent handler registered in `registerHandlers()` (the 'agent' route handler), after the usageTracker.recordSession block around line 1108.

2. In the command handling blocks (both in `cycle()` and `processInboxItem()`), update the `handleCommand` call to pass `brain` in the context:
   Add `brain: this.config.brain` to the CommandContext object passed to handleCommand. This is needed so /compact can call compactSession().
  </action>
  <verify>
Run `npx tsc --noEmit --project nexus/packages/core/tsconfig.json` to verify TypeScript compiles. Grep for `handleCompact(ctx)` in commands.ts and `Auto-compact` in daemon.ts to confirm both are wired.
  </verify>
  <done>
/compact command produces a token savings report showing messages compacted, original tokens, saved tokens with percentage, and confirmation that last 10 messages and critical facts are preserved. Auto-compact triggers when session exceeds 100k tokens after any agent run.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles cleanly: `npx tsc --noEmit --project nexus/packages/core/tsconfig.json`
2. SessionManager.compactSession() exists and accepts (senderId, brain) parameters
3. /compact command no longer returns "coming soon" stub
4. Auto-compact check exists in daemon's agent handler after usage tracking
5. Brain dependency is passed as parameter, not stored on SessionManager
6. Critical fact extraction covers file paths, error codes, user preferences, IPs/URLs
</verification>

<success_criteria>
- COMP-01: SessionManager.compactSession() summarizes old conversation history using Brain (haiku tier)
- COMP-02: Last 10 messages are always preserved verbatim; older messages are summarized
- COMP-03: Critical facts (file paths, error codes, user preferences) are pinned and never compacted
- COMP-04: /compact command triggers manual compaction and reports token savings percentage
- COMP-05: Auto-compact triggers when session exceeds 100k token threshold
- COMP-06: Compacted session state is stored in Redis alongside the session (same Redis keys, compacted history replaces full history)
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p03-intelligence-enhancements/v2.0-03-01-SUMMARY.md`
</output>
