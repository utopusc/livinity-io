---
phase: v2.0-p03-intelligence-enhancements
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/multi-agent.ts
  - nexus/packages/core/src/daemon.ts
autonomous: true

must_haves:
  truths:
    - "AI agent can create a sub-agent session via sessions_create MCP tool with a specific task"
    - "AI agent can list active sub-agent sessions via sessions_list MCP tool"
    - "AI agent can send messages to sub-agent sessions via sessions_send MCP tool"
    - "AI agent can read sub-agent session history via sessions_history MCP tool"
    - "Sub-agent sessions are tracked in Redis with proper lifecycle"
  artifacts:
    - path: "nexus/packages/core/src/multi-agent.ts"
      provides: "MultiAgentManager class with create, list, send, getHistory, cleanup methods"
      contains: "class MultiAgentManager"
    - path: "nexus/packages/core/src/daemon.ts"
      provides: "Four MCP tools registered: sessions_create, sessions_list, sessions_send, sessions_history"
      contains: "sessions_create"
  key_links:
    - from: "nexus/packages/core/src/daemon.ts"
      to: "nexus/packages/core/src/multi-agent.ts"
      via: "registerTools() registers MCP tools that delegate to MultiAgentManager"
      pattern: "multiAgentManager"
    - from: "nexus/packages/core/src/multi-agent.ts"
      to: "Redis"
      via: "Session state stored in nexus:multi-agent:session:* keys"
      pattern: "nexus:multi-agent:session"
---

<objective>
Create the multi-agent session management infrastructure and MCP tools that allow the AI agent to spawn, communicate with, and monitor sub-agent sessions.

Purpose: Complex tasks benefit from delegation — the main agent can spawn focused sub-agents for specific subtasks (research, file operations, analysis) and coordinate their results. This plan creates the Redis-backed session schema and four MCP tools (sessions_create, sessions_list, sessions_send, sessions_history) for sub-agent lifecycle management.

Output: MultiAgentManager class with Redis persistence, four registered MCP tools in daemon's tool registry.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key existing files:
@nexus/packages/core/src/daemon.ts — registerTools() pattern for MCP tool registration
@nexus/packages/core/src/tool-registry.ts — Tool and ToolResult types, register() interface
@nexus/packages/core/src/types.ts — Tool, ToolResult, ToolParameter interfaces
@nexus/packages/core/src/sdk-agent-runner.ts — SdkAgentRunner for sub-agent execution (used by Plan 03)
@nexus/packages/core/src/agent.ts — AgentConfig, AgentResult types
@nexus/packages/core/src/index.ts — initialization flow, BullMQ patterns, daemon construction
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MultiAgentManager class</name>
  <files>nexus/packages/core/src/multi-agent.ts</files>
  <action>
Create a new file `nexus/packages/core/src/multi-agent.ts` with:

1. **SubAgentSession interface:**
   ```typescript
   export interface SubAgentSession {
     id: string;               // UUID
     parentSessionId: string;  // Who spawned this
     task: string;             // The assigned task
     status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
     createdAt: number;
     updatedAt: number;
     maxTurns: number;         // Default 8, hard max 8
     maxTokens: number;        // Default 50k, hard max 50k
     result?: string;          // Final answer when completed
     error?: string;           // Error message if failed
     turns: number;            // Turns used so far
     inputTokens: number;      // Input tokens consumed
     outputTokens: number;     // Output tokens consumed
     isSubAgent: true;         // Metadata flag — actual MULTI-07 enforcement is in Plan 03 (sessions_* tools excluded from sub-agent)
   }
   ```

2. **SubAgentMessage interface:**
   ```typescript
   export interface SubAgentMessage {
     role: 'user' | 'assistant';
     content: string;
     timestamp: number;
   }
   ```

3. **MultiAgentManager class:**
   ```typescript
   export class MultiAgentManager {
     private redis: Redis;
     private maxConcurrent: number;

     constructor(config: { redis: Redis; maxConcurrent?: number }) {
       this.redis = config.redis;
       this.maxConcurrent = config.maxConcurrent ?? 2; // MULTI-06: VPS resource constraint
     }
   ```

4. **Redis key patterns:**
   - `nexus:multi-agent:session:{id}` — JSON session state (TTL: 1 hour)
   - `nexus:multi-agent:history:{id}` — List of messages (TTL: 1 hour)
   - `nexus:multi-agent:active` — SET of currently active (running/pending) session IDs
   - `nexus:multi-agent:parent:{parentSessionId}` — SET of child session IDs for a parent

5. **Methods:**

   **`async create(opts: { parentSessionId: string; task: string; maxTurns?: number; maxTokens?: number }): Promise<SubAgentSession>`**
   - Check concurrent count: `SCARD nexus:multi-agent:active`. If >= maxConcurrent, throw Error('Maximum concurrent sub-agents (2) reached. Wait for an existing sub-agent to complete.')
   - Generate UUID for session ID
   - Enforce limits: maxTurns = Math.min(opts.maxTurns ?? 8, 8), maxTokens = Math.min(opts.maxTokens ?? 50_000, 50_000)
   - Create SubAgentSession object with status 'pending'
   - Store in Redis: SET session key (JSON, EX 3600), SADD to active set, SADD to parent's children set
   - Return the session object
   - Log creation

   **`async get(sessionId: string): Promise<SubAgentSession | null>`**
   - GET session key, parse JSON, return null if not found

   **`async list(parentSessionId?: string): Promise<SubAgentSession[]>`**
   - If parentSessionId: SMEMBERS of parent's children set, fetch each session
   - If no parent: SMEMBERS of active set, fetch each session
   - Filter out null (expired) sessions
   - Return sorted by createdAt desc

   **`async updateStatus(sessionId: string, updates: Partial<SubAgentSession>): Promise<void>`**
   - GET current session, merge updates, SET back with remaining TTL
   - If status changed to 'completed' or 'failed' or 'cancelled': SREM from active set

   **`async addMessage(sessionId: string, message: SubAgentMessage): Promise<void>`**
   - LPUSH to history list, LTRIM to keep max 50 messages, EXPIRE 3600

   **`async getHistory(sessionId: string): Promise<SubAgentMessage[]>`**
   - LRANGE 0 -1, parse each entry, reverse to chronological order

   **`async getActiveCount(): Promise<number>`**
   - SCARD of active set

   **`async cleanup(): Promise<number>`**
   - Scan active set, check each session — if expired (not in Redis), SREM from active set
   - Return count of cleaned up sessions

   **`async cancel(sessionId: string): Promise<boolean>`**
   - Get session, if running/pending, update status to 'cancelled', SREM from active set
   - Return true if cancelled, false if not found or already completed

Import Redis type: `import type Redis from 'ioredis';`
Import logger: `import { logger } from './logger.js';`
  </action>
  <verify>
Run `npx tsc --noEmit --project nexus/packages/core/tsconfig.json` to verify TypeScript compiles. Check that MultiAgentManager class exists with create, list, get, updateStatus, addMessage, getHistory methods.
  </verify>
  <done>
MultiAgentManager class exists with Redis-backed session lifecycle management, concurrent session limiting (max 2), and proper TTL-based cleanup. All session state persisted to Redis with 1-hour TTL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register multi-agent MCP tools in daemon</name>
  <files>nexus/packages/core/src/daemon.ts, nexus/packages/core/src/index.ts</files>
  <action>
**In index.ts:**

1. Import MultiAgentManager: `import { MultiAgentManager } from './multi-agent.js';`

2. After the UsageTracker initialization (around line 179), create the MultiAgentManager:
   ```typescript
   const multiAgentManager = new MultiAgentManager({
     redis,
     maxConcurrent: 2, // MULTI-06: VPS resource constraint
   });
   logger.info('MultiAgentManager initialized', { maxConcurrent: 2 });
   ```

3. Add `multiAgentManager` to the DaemonConfig passed to `new Daemon({...})`.

**In daemon.ts:**

1. Import MultiAgentManager type: `import type { MultiAgentManager } from './multi-agent.js';`

2. Add to DaemonConfig interface: `multiAgentManager?: MultiAgentManager;`

3. Add getter for external access:
   ```typescript
   get multiAgentManager(): MultiAgentManager | undefined {
     return this.config.multiAgentManager;
   }
   ```

4. In `registerTools()`, add four MCP tools AFTER the existing tool registrations:

   **sessions_create:**
   ```typescript
   toolRegistry.register({
     name: 'sessions_create',
     description: 'Spawn a sub-agent session to perform a specific task. Sub-agents are limited to 8 turns and 50k tokens. Maximum 2 concurrent sub-agents.',
     parameters: [
       { name: 'task', type: 'string', description: 'Clear description of the task for the sub-agent', required: true },
       { name: 'max_turns', type: 'number', description: 'Maximum turns (default 8, max 8)', required: false },
     ],
     execute: async (params) => {
       if (!this.config.multiAgentManager) {
         return { success: false, output: '', error: 'Multi-agent sessions not available.' };
       }
       try {
         const session = await this.config.multiAgentManager.create({
           parentSessionId: this.currentChannelContext?.chatId || 'web',
           task: params.task as string,
           maxTurns: params.max_turns as number | undefined,
         });
         return {
           success: true,
           output: `Sub-agent session created.\nID: ${session.id}\nTask: ${session.task}\nMax turns: ${session.maxTurns}\nStatus: ${session.status}`,
           data: session,
         };
       } catch (err: any) {
         return { success: false, output: '', error: err.message };
       }
     },
   });
   ```

   **sessions_list:**
   ```typescript
   toolRegistry.register({
     name: 'sessions_list',
     description: 'List active sub-agent sessions, optionally filtered by parent session.',
     parameters: [
       { name: 'parent_session_id', type: 'string', description: 'Filter by parent session ID (optional)', required: false },
     ],
     execute: async (params) => {
       if (!this.config.multiAgentManager) {
         return { success: false, output: '', error: 'Multi-agent sessions not available.' };
       }
       try {
         const sessions = await this.config.multiAgentManager.list(params.parent_session_id as string | undefined);
         if (sessions.length === 0) {
           return { success: true, output: 'No active sub-agent sessions.' };
         }
         const lines = sessions.map(s =>
           `[${s.id.slice(0, 8)}] ${s.status} | Task: ${s.task.slice(0, 80)} | Turns: ${s.turns}/${s.maxTurns} | Tokens: ${s.inputTokens + s.outputTokens}`
         );
         return { success: true, output: lines.join('\n'), data: sessions };
       } catch (err: any) {
         return { success: false, output: '', error: err.message };
       }
     },
   });
   ```

   **sessions_send:**
   ```typescript
   toolRegistry.register({
     name: 'sessions_send',
     description: 'Send a message to a sub-agent session. The sub-agent will process the message and update its state.',
     parameters: [
       { name: 'session_id', type: 'string', description: 'The sub-agent session ID', required: true },
       { name: 'message', type: 'string', description: 'Message to send to the sub-agent', required: true },
     ],
     execute: async (params) => {
       if (!this.config.multiAgentManager) {
         return { success: false, output: '', error: 'Multi-agent sessions not available.' };
       }
       try {
         const session = await this.config.multiAgentManager.get(params.session_id as string);
         if (!session) {
           return { success: false, output: '', error: `Session ${params.session_id} not found or expired.` };
         }
         if (session.status === 'completed' || session.status === 'failed' || session.status === 'cancelled') {
           return { success: false, output: '', error: `Session ${params.session_id} is already ${session.status}. Result: ${session.result || session.error || 'N/A'}` };
         }

         // Add the message to session history
         await this.config.multiAgentManager.addMessage(params.session_id as string, {
           role: 'user',
           content: params.message as string,
           timestamp: Date.now(),
         });

         // Note: Actual sub-agent execution is handled by Plan 03's BullMQ worker.
         // For now, the message is queued in the session history. Plan 03 will add
         // a BullMQ job that picks up pending sessions and runs them through SdkAgentRunner.
         // Mark session as pending for the worker to pick up.
         await this.config.multiAgentManager.updateStatus(params.session_id as string, {
           status: 'pending',
           updatedAt: Date.now(),
         });

         return {
           success: true,
           output: `Message sent to session ${(params.session_id as string).slice(0, 8)}. Sub-agent will process it.`,
         };
       } catch (err: any) {
         return { success: false, output: '', error: err.message };
       }
     },
   });
   ```

   **sessions_history:**
   ```typescript
   toolRegistry.register({
     name: 'sessions_history',
     description: 'Read the conversation history of a sub-agent session, including its result if completed.',
     parameters: [
       { name: 'session_id', type: 'string', description: 'The sub-agent session ID', required: true },
     ],
     execute: async (params) => {
       if (!this.config.multiAgentManager) {
         return { success: false, output: '', error: 'Multi-agent sessions not available.' };
       }
       try {
         const session = await this.config.multiAgentManager.get(params.session_id as string);
         if (!session) {
           return { success: false, output: '', error: `Session ${params.session_id} not found or expired.` };
         }

         const history = await this.config.multiAgentManager.getHistory(params.session_id as string);
         const lines: string[] = [
           `Session: ${session.id.slice(0, 8)}`,
           `Status: ${session.status}`,
           `Task: ${session.task}`,
           `Turns: ${session.turns}/${session.maxTurns}`,
           `Tokens: ${session.inputTokens} in / ${session.outputTokens} out`,
           '',
         ];

         if (history.length > 0) {
           lines.push('--- History ---');
           for (const msg of history) {
             lines.push(`[${msg.role}] ${msg.content.slice(0, 500)}`);
           }
         }

         if (session.result) {
           lines.push('', '--- Result ---', session.result);
         }
         if (session.error) {
           lines.push('', '--- Error ---', session.error);
         }

         return { success: true, output: lines.join('\n'), data: { session, history } };
       } catch (err: any) {
         return { success: false, output: '', error: err.message };
       }
     },
   });
   ```
  </action>
  <verify>
Run `npx tsc --noEmit --project nexus/packages/core/tsconfig.json` to verify TypeScript compiles. Grep for `sessions_create`, `sessions_list`, `sessions_send`, `sessions_history` in daemon.ts to confirm all four tools are registered.
  </verify>
  <done>
Four MCP tools (sessions_create, sessions_list, sessions_send, sessions_history) are registered in the daemon's tool registry. MultiAgentManager is initialized in index.ts and passed to the daemon. The AI agent can create, list, message, and read sub-agent sessions.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles cleanly: `npx tsc --noEmit --project nexus/packages/core/tsconfig.json`
2. MultiAgentManager exists in multi-agent.ts with proper Redis key patterns
3. Four session tools registered in daemon's registerTools()
4. Concurrent limit enforced (max 2) in MultiAgentManager.create()
5. Session TTL set to 1 hour for auto-cleanup
6. sessions_create includes isSubAgent flag for DAG enforcement (MULTI-07)
</verification>

<success_criteria>
- MULTI-01: AI agent can spawn sub-agents via sessions_create MCP tool with a specific task
- MULTI-02: AI agent can list active sessions via sessions_list MCP tool
- MULTI-03: AI agent can send messages to other sessions via sessions_send MCP tool
- MULTI-04: AI agent can read session history via sessions_history MCP tool
- MULTI-06: Maximum 2 concurrent sub-agents enforced via MultiAgentManager.create() check
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p03-intelligence-enhancements/v2.0-03-02-SUMMARY.md`
</output>
