---
phase: 06-typescript-quality
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - livos/packages/livinityd/source/modules/ai/routes.ts
  - livos/packages/livinityd/source/modules/ai/index.ts
  - livos/packages/livinityd/source/modules/utilities/logger.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "catch (error: any) patterns replaced with proper typing in ai/routes.ts"
    - "Error logging uses proper type narrowing in livinityd"
    - "Logger utility accepts unknown instead of any for errors"
  artifacts:
    - path: "livos/packages/livinityd/source/modules/ai/routes.ts"
      provides: "Typed catch blocks with proper error extraction"
      contains: "error instanceof Error"
    - path: "livos/packages/livinityd/source/modules/ai/index.ts"
      provides: "Typed event handling and catch blocks"
      contains: "error instanceof Error"
    - path: "livos/packages/livinityd/source/modules/utilities/logger.ts"
      provides: "Logger that accepts unknown errors"
      contains: "error?: unknown"
  key_links:
    - from: "livos/packages/livinityd/source/modules/ai/routes.ts"
      to: "logger"
      via: "error logging calls"
      pattern: "logger\\.(error|warn)"
---

<objective>
Improve TypeScript type safety in livinityd AI modules by replacing `catch (error: any)` with properly typed patterns.

Purpose: Reduce `any` type usage in livinityd modules (QUAL-05), establish consistent error handling pattern.
Output: ai/routes.ts and ai/index.ts with typed catch blocks, logger.ts accepting unknown.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-typescript-quality/06-RESEARCH.md
@.planning/phases/06-typescript-quality/06-01-SUMMARY.md
@livos/packages/livinityd/source/modules/utilities/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update logger.ts to accept unknown</name>
  <files>livos/packages/livinityd/source/modules/utilities/logger.ts</files>
  <action>
Update the logger utility to accept `unknown` instead of `any` for error parameters.

Find the logger method signatures with `error?: any` and update them:

BEFORE:
```typescript
error(message: string, error?: any): void
warn(message: string, error?: any): void
```

AFTER:
```typescript
error(message: string, error?: unknown): void
warn(message: string, error?: unknown): void
```

Also update any internal handling of the error parameter to use type narrowing:

BEFORE:
```typescript
// If error is logged directly
console.error(message, error);
```

AFTER:
```typescript
// Still works - console.error accepts unknown
console.error(message, error);
```

If the logger extracts error.message internally, update it:

BEFORE:
```typescript
const errorMsg = error?.message || String(error);
```

AFTER:
```typescript
const errorMsg = error instanceof Error ? error.message : String(error);
```

This change is safe because `unknown` is assignable from any type, and the logger's job is to handle whatever is thrown.
  </action>
  <verify>
Check for remaining `any` in logger parameters:
```bash
grep -n "error?: any" livos/packages/livinityd/source/modules/utilities/logger.ts || echo "No any found"
```
Should return "No any found".

TypeScript compiles:
```bash
cd livos/packages/livinityd && npx tsc --noEmit
```
  </verify>
  <done>
logger.ts accepts `error?: unknown` instead of `error?: any`. All internal error handling uses proper type narrowing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace catch (error: any) in ai/routes.ts</name>
  <files>livos/packages/livinityd/source/modules/ai/routes.ts</files>
  <action>
Replace all `catch (error: any)` patterns with typed patterns.

1. Create a helper at the top of the file (or use inline):
```typescript
// Helper for consistent error message extraction
const getErrorMessage = (error: unknown): string =>
  error instanceof Error ? error.message : String(error);
```

2. Replace all catch blocks:

BEFORE:
```typescript
} catch (error: any) {
  logger.error('Operation failed', error);
  return { success: false, error: error.message };
}
```

AFTER:
```typescript
} catch (error) {
  logger.error('Operation failed', error);
  return { success: false, error: getErrorMessage(error) };
}
```

Key patterns to update:
- `catch (error: any)` -> `catch (error)`
- `error.message` -> `getErrorMessage(error)` or inline `error instanceof Error ? error.message : String(error)`
- `error?.message` -> same pattern

For TRPCError handling (if used):
```typescript
// If code throws specific TRPC errors, keep instanceof checks
if (error instanceof TRPCError) {
  throw error; // rethrow as-is
}
```

Expected count: ~17 catch blocks need updating based on research.

Note: livinityd uses different logging than Nexus. Don't try to import Nexus's formatErrorMessage - use the inline helper or instanceof pattern instead.
  </action>
  <verify>
Count remaining `catch (error: any)`:
```bash
grep -c "catch (error: any)" livos/packages/livinityd/source/modules/ai/routes.ts || echo "0"
```
Should return 0.

TypeScript compiles:
```bash
cd livos/packages/livinityd && npx tsc --noEmit
```
  </verify>
  <done>
ai/routes.ts has 0 instances of `catch (error: any)`. Error message extraction uses type narrowing. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 3: Replace any types in ai/index.ts</name>
  <files>livos/packages/livinityd/source/modules/ai/index.ts</files>
  <action>
Update ai/index.ts to replace `any` types with proper typing.

1. For event handlers with `event: any`:

BEFORE:
```typescript
socket.on('message', (event: any) => {
  // ...
});
```

AFTER - Option A (if event structure is known):
```typescript
interface MessageEvent {
  type: string;
  data: unknown;
  // add other known fields
}

socket.on('message', (event: MessageEvent) => {
  // ...
});
```

AFTER - Option B (if event structure varies):
```typescript
socket.on('message', (event: unknown) => {
  // Use type guards inside handler
  if (typeof event === 'object' && event !== null && 'type' in event) {
    // ...
  }
});
```

2. For catch blocks with `catch (error: any)`:

BEFORE:
```typescript
} catch (error: any) {
  logger.error('Failed', error);
}
```

AFTER:
```typescript
} catch (error) {
  logger.error('Failed', error);
}
```

The logger already accepts `unknown` from Task 1, so this just removes the `: any` annotation.

3. If there are `as any` casts, evaluate each:
- If casting to silence type errors, investigate the actual types
- If casting for external library compatibility, keep but add comment explaining why
  </action>
  <verify>
Count remaining `: any` patterns:
```bash
grep -c ": any" livos/packages/livinityd/source/modules/ai/index.ts || echo "0"
```
Should be 0 or minimal (only justified cases with comments).

TypeScript compiles:
```bash
cd livos/packages/livinityd && npx tsc --noEmit
```
  </verify>
  <done>
ai/index.ts has no unjustified `any` types. Event handlers use proper types or `unknown`. Catch blocks are properly typed. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. No `catch (error: any)` in target files:
   ```bash
   grep -c "catch (error: any)" livos/packages/livinityd/source/modules/ai/routes.ts livos/packages/livinityd/source/modules/ai/index.ts || echo "0"
   ```
2. Logger accepts unknown: `grep "error?: unknown" livos/packages/livinityd/source/modules/utilities/logger.ts`
3. TypeScript compiles: `cd livos/packages/livinityd && npx tsc --noEmit`
</verification>

<success_criteria>
- logger.ts: Accepts `error?: unknown` instead of `error?: any`
- ai/routes.ts: 0 instances of `catch (error: any)`, uses type narrowing for error messages
- ai/index.ts: No unjustified `any` types, event handlers properly typed
- All files compile with TypeScript
- Existing functionality preserved (error messages still logged properly)
</success_criteria>

<output>
After completion, create `.planning/phases/06-typescript-quality/06-03-SUMMARY.md`
</output>
