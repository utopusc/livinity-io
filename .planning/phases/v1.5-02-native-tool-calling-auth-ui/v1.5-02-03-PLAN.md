---
phase: v1.5-02-native-tool-calling-auth-ui
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - livos/packages/ui/src/routes/settings/_components/settings-content.tsx
  - livos/packages/livinityd/source/modules/ai/routes.ts
  - livos/install.sh
autonomous: true

must_haves:
  truths:
    - "Settings UI has separate fields for Anthropic and Gemini API keys with independent save/validation"
    - "tRPC backend has getConfig and setConfig endpoints for both Anthropic and Gemini keys"
    - "API key validation makes a lightweight API call before saving (Claude messages.create with max_tokens:1, Gemini models.list)"
    - "Settings UI has a provider selection dropdown for primary provider (Claude or Gemini)"
    - "install.sh setup wizard prompts for Anthropic API key alongside Gemini key"
  artifacts:
    - path: "livos/packages/ui/src/routes/settings/_components/settings-content.tsx"
      provides: "AiConfigSection with Anthropic key, Gemini key, and provider selection"
      contains: "anthropicApiKey"
    - path: "livos/packages/livinityd/source/modules/ai/routes.ts"
      provides: "tRPC endpoints for Anthropic key get/set/validate and provider selection"
      contains: "anthropicApiKey"
    - path: "livos/install.sh"
      provides: "Setup wizard prompt for Anthropic API key"
      contains: "CONFIG_ANTHROPIC_KEY"
  key_links:
    - from: "livos/packages/ui/src/routes/settings/_components/settings-content.tsx"
      to: "livos/packages/livinityd/source/modules/ai/routes.ts"
      via: "trpcReact.ai.setConfig calls tRPC setConfig mutation with anthropicApiKey"
      pattern: "anthropicApiKey"
    - from: "livos/packages/livinityd/source/modules/ai/routes.ts"
      to: "nexus/packages/core/src/providers/claude.ts"
      via: "Stores key in Redis nexus:config:anthropic_api_key, ClaudeProvider reads it"
      pattern: "nexus:config:anthropic_api_key"
---

<objective>
Add Settings UI for API key management (Anthropic + Gemini), API key validation on save, provider selection, and install.sh update to prompt for Anthropic API key.

Purpose: Users need a way to configure their AI provider keys and choose their preferred provider. Without this, only Gemini keys can be configured through the UI, and Anthropic keys must be set manually in Redis.

Output: AiConfigSection expanded with dual-key management, validation, and provider selection. tRPC routes handle both keys. install.sh prompts for Anthropic key.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Phase 1 outputs
@.planning/phases/v1.5-01-provider-abstraction-claude/v1.5-01-02-SUMMARY.md

# Source files to modify
@livos/packages/ui/src/routes/settings/_components/settings-content.tsx
@livos/packages/livinityd/source/modules/ai/routes.ts
@livos/install.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand tRPC routes for Anthropic key, key validation, and provider selection</name>
  <files>
    livos/packages/livinityd/source/modules/ai/routes.ts
  </files>
  <action>
**Goal:** Update the tRPC AI routes to handle Anthropic API key storage/retrieval, validate keys before saving, and manage provider selection preference.

**1. Update `getConfig` to return Anthropic key status and provider selection:**

```typescript
getConfig: privateProcedure.query(async ({ctx}) => {
    const redis = ctx.livinityd.ai.redis
    const geminiKey = await redis.get('livos:config:gemini_api_key') || process.env.GEMINI_API_KEY || ''
    const anthropicKey = await redis.get('nexus:config:anthropic_api_key') || process.env.ANTHROPIC_API_KEY || ''
    const primaryProvider = await redis.get('nexus:config:primary_provider') || 'claude'
    return {
        geminiApiKey: maskKey(geminiKey),
        hasGeminiKey: geminiKey.length > 0,
        anthropicApiKey: maskKey(anthropicKey),
        hasAnthropicKey: anthropicKey.length > 0,
        primaryProvider,
    }
}),
```

**2. Update `setConfig` to accept both keys and provider selection:**

Replace the existing `setConfig` mutation with:

```typescript
setConfig: privateProcedure
    .input(
        z.object({
            geminiApiKey: z.string().min(1).max(256).optional(),
            anthropicApiKey: z.string().min(1).max(256).optional(),
            primaryProvider: z.enum(['claude', 'gemini']).optional(),
        }),
    )
    .mutation(async ({ctx, input}) => {
        const redis = ctx.livinityd.ai.redis

        if (input.geminiApiKey) {
            await redis.set('livos:config:gemini_api_key', input.geminiApiKey)
            await redis.publish('livos:config:updated', 'gemini_api_key')
            ctx.livinityd.logger.log('Gemini API key updated via Settings UI')
        }

        if (input.anthropicApiKey) {
            await redis.set('nexus:config:anthropic_api_key', input.anthropicApiKey)
            await redis.publish('livos:config:updated', 'anthropic_api_key')
            ctx.livinityd.logger.log('Anthropic API key updated via Settings UI')
        }

        if (input.primaryProvider) {
            await redis.set('nexus:config:primary_provider', input.primaryProvider)
            await redis.publish('livos:config:updated', 'primary_provider')
            ctx.livinityd.logger.log(`Primary provider set to ${input.primaryProvider} via Settings UI`)
        }

        return {success: true}
    }),
```

**3. Add a `validateKey` mutation for testing API keys before save:**

Add this new endpoint after `setConfig`:

```typescript
/** Validate an API key by making a lightweight test call */
validateKey: privateProcedure
    .input(
        z.object({
            provider: z.enum(['claude', 'gemini']),
            apiKey: z.string().min(1).max(256),
        }),
    )
    .mutation(async ({ctx, input}) => {
        try {
            if (input.provider === 'claude') {
                // Lightweight validation: create a minimal message request
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': input.apiKey,
                        'anthropic-version': '2023-06-01',
                    },
                    body: JSON.stringify({
                        model: 'claude-haiku-4-5-20250610',
                        max_tokens: 1,
                        messages: [{role: 'user', content: 'Hi'}],
                    }),
                })

                if (response.status === 401) {
                    return {valid: false, error: 'Invalid API key'}
                }
                if (response.status === 403) {
                    return {valid: false, error: 'API key does not have permission'}
                }
                // 200 or 429 (rate limited) both mean the key is valid
                if (response.ok || response.status === 429) {
                    return {valid: true}
                }
                // Other errors
                const data = (await response.json().catch(() => ({}))) as {error?: {message?: string}}
                return {valid: false, error: data.error?.message || `Unexpected status: ${response.status}`}

            } else if (input.provider === 'gemini') {
                // Lightweight validation: list models
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models?key=${input.apiKey}`,
                )

                if (response.status === 400 || response.status === 403) {
                    return {valid: false, error: 'Invalid API key'}
                }
                if (response.ok) {
                    return {valid: true}
                }
                return {valid: false, error: `Unexpected status: ${response.status}`}
            }

            return {valid: false, error: 'Unknown provider'}
        } catch (error) {
            ctx.livinityd.logger.error('API key validation failed', error)
            return {valid: false, error: getErrorMessage(error)}
        }
    }),
```

NOTE: The `anthropic-version` header and `claude-haiku-4-5-20250610` model are used for the lightest possible validation call. The 429 status is treated as valid because it means the key authenticated but hit a rate limit.
  </action>
  <verify>
Run `cd livos && npx tsc --noEmit` — zero errors. Grep for `anthropicApiKey` in routes.ts. Grep for `validateKey` in routes.ts. Grep for `primaryProvider` in routes.ts.
  </verify>
  <done>
tRPC AI routes return both Anthropic and Gemini key status. setConfig accepts both keys and provider selection. validateKey endpoint tests keys with lightweight API calls (Claude messages.create with max_tokens:1, Gemini models.list). Provider selection stored in Redis nexus:config:primary_provider.
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand AiConfigSection UI with dual-key management, validation, and provider selection</name>
  <files>
    livos/packages/ui/src/routes/settings/_components/settings-content.tsx
  </files>
  <action>
**Goal:** Rebuild the AiConfigSection to support both Anthropic and Gemini API keys with validation, plus a provider selection dropdown.

**1. Update the MENU_ITEMS description:**

Change the ai-config menu item description from `'Gemini API key'` to `'API keys & provider'`:

```typescript
{id: 'ai-config', icon: TbKey, label: 'AI Configuration', description: 'API keys & provider'},
```

**2. Replace the entire `AiConfigSection` function** with the expanded version:

```typescript
function AiConfigSection() {
    const [anthropicKey, setAnthropicKey] = useState('')
    const [geminiKey, setGeminiKey] = useState('')
    const [anthropicSaved, setAnthropicSaved] = useState(false)
    const [geminiSaved, setGeminiSaved] = useState(false)
    const [anthropicValidating, setAnthropicValidating] = useState(false)
    const [geminiValidating, setGeminiValidating] = useState(false)
    const [anthropicError, setAnthropicError] = useState('')
    const [geminiError, setGeminiError] = useState('')

    const configQ = trpcReact.ai.getConfig.useQuery()
    const utils = trpcReact.useUtils()

    const validateKeyMutation = trpcReact.ai.validateKey.useMutation()

    const setConfigMutation = trpcReact.ai.setConfig.useMutation({
        onSuccess: () => {
            utils.ai.getConfig.invalidate()
        },
    })

    const handleSaveAnthropicKey = async () => {
        if (!anthropicKey.trim()) return
        setAnthropicError('')
        setAnthropicValidating(true)

        try {
            const result = await validateKeyMutation.mutateAsync({
                provider: 'claude',
                apiKey: anthropicKey.trim(),
            })

            if (!result.valid) {
                setAnthropicError(result.error || 'Invalid API key')
                setAnthropicValidating(false)
                return
            }

            await setConfigMutation.mutateAsync({anthropicApiKey: anthropicKey.trim()})
            setAnthropicSaved(true)
            setAnthropicKey('')
            setAnthropicValidating(false)
            setTimeout(() => setAnthropicSaved(false), 2000)
        } catch {
            setAnthropicError('Failed to validate key')
            setAnthropicValidating(false)
        }
    }

    const handleSaveGeminiKey = async () => {
        if (!geminiKey.trim()) return
        setGeminiError('')
        setGeminiValidating(true)

        try {
            const result = await validateKeyMutation.mutateAsync({
                provider: 'gemini',
                apiKey: geminiKey.trim(),
            })

            if (!result.valid) {
                setGeminiError(result.error || 'Invalid API key')
                setGeminiValidating(false)
                return
            }

            await setConfigMutation.mutateAsync({geminiApiKey: geminiKey.trim()})
            setGeminiSaved(true)
            setGeminiKey('')
            setGeminiValidating(false)
            setTimeout(() => setGeminiSaved(false), 2000)
        } catch {
            setGeminiError('Failed to validate key')
            setGeminiValidating(false)
        }
    }

    const handleProviderChange = async (provider: string) => {
        await setConfigMutation.mutateAsync({primaryProvider: provider as 'claude' | 'gemini'})
    }

    return (
        <div className='max-w-lg space-y-8'>
            {/* Provider Selection */}
            <div className='space-y-3'>
                <h3 className='text-body font-medium text-text-primary'>Primary Provider</h3>
                <p className='text-caption text-text-secondary'>
                    Choose which AI provider to use by default. The other will serve as fallback.
                </p>
                <Select
                    value={configQ.data?.primaryProvider || 'claude'}
                    onValueChange={handleProviderChange}
                >
                    <SelectTrigger className='w-[240px]'>
                        <SelectValue placeholder='Select provider' />
                    </SelectTrigger>
                    <SelectContent>
                        <SelectItem value='claude'>Claude (Anthropic)</SelectItem>
                        <SelectItem value='gemini'>Gemini (Google)</SelectItem>
                    </SelectContent>
                </Select>
            </div>

            <div className='border-t border-border-subtle' />

            {/* Anthropic API Key */}
            <div className='space-y-4'>
                <h3 className='text-body font-medium text-text-primary'>Anthropic API Key</h3>

                <SettingsInfoCard
                    icon={TbKey}
                    title='Current Key'
                    description={configQ.isLoading ? 'Loading...' : configQ.data?.hasAnthropicKey ? configQ.data.anthropicApiKey : 'Not configured'}
                >
                    {configQ.data?.hasAnthropicKey && (
                        <div className='rounded-full bg-green-500/20 px-3 py-1 text-caption text-green-400'>Active</div>
                    )}
                </SettingsInfoCard>

                <div className='space-y-3'>
                    <label className='text-caption text-text-secondary'>Enter new API key</label>
                    <Input
                        placeholder='sk-ant-...'
                        value={anthropicKey}
                        onValueChange={(v) => { setAnthropicKey(v); setAnthropicError(''); }}
                        onKeyDown={(e) => e.key === 'Enter' && handleSaveAnthropicKey()}
                        className='font-mono'
                    />
                    {anthropicError && (
                        <p className='text-caption-sm text-red-400'>{anthropicError}</p>
                    )}
                    <p className='text-caption-sm text-text-tertiary'>
                        Your API key is validated before saving and stored securely.
                    </p>
                </div>

                <a
                    href='https://console.anthropic.com/settings/keys'
                    target='_blank'
                    rel='noopener noreferrer'
                    className='flex items-center gap-2 text-body-sm text-blue-400 hover:text-blue-300'
                >
                    <TbExternalLink className='h-4 w-4' />
                    Get your API key from Anthropic Console
                </a>

                <Button
                    variant='primary'
                    onClick={handleSaveAnthropicKey}
                    disabled={!anthropicKey.trim() || anthropicValidating}
                >
                    {anthropicSaved ? (
                        <>
                            <TbCheck className='h-4 w-4' />
                            Saved
                        </>
                    ) : anthropicValidating ? (
                        'Validating...'
                    ) : (
                        'Save API Key'
                    )}
                </Button>
            </div>

            <div className='border-t border-border-subtle' />

            {/* Gemini API Key */}
            <div className='space-y-4'>
                <h3 className='text-body font-medium text-text-primary'>Gemini API Key</h3>

                <SettingsInfoCard
                    icon={TbKey}
                    title='Current Key'
                    description={configQ.isLoading ? 'Loading...' : configQ.data?.hasGeminiKey ? configQ.data.geminiApiKey : 'Not configured'}
                >
                    {configQ.data?.hasGeminiKey && (
                        <div className='rounded-full bg-green-500/20 px-3 py-1 text-caption text-green-400'>Active</div>
                    )}
                </SettingsInfoCard>

                <div className='space-y-3'>
                    <label className='text-caption text-text-secondary'>Enter new API key</label>
                    <Input
                        placeholder='AIzaSy...'
                        value={geminiKey}
                        onValueChange={(v) => { setGeminiKey(v); setGeminiError(''); }}
                        onKeyDown={(e) => e.key === 'Enter' && handleSaveGeminiKey()}
                        className='font-mono'
                    />
                    {geminiError && (
                        <p className='text-caption-sm text-red-400'>{geminiError}</p>
                    )}
                    <p className='text-caption-sm text-text-tertiary'>
                        Your API key is validated before saving and stored securely.
                    </p>
                </div>

                <a
                    href='https://aistudio.google.com/app/apikey'
                    target='_blank'
                    rel='noopener noreferrer'
                    className='flex items-center gap-2 text-body-sm text-blue-400 hover:text-blue-300'
                >
                    <TbExternalLink className='h-4 w-4' />
                    Get your API key from Google AI Studio
                </a>

                <Button
                    variant='primary'
                    onClick={handleSaveGeminiKey}
                    disabled={!geminiKey.trim() || geminiValidating}
                >
                    {geminiSaved ? (
                        <>
                            <TbCheck className='h-4 w-4' />
                            Saved
                        </>
                    ) : geminiValidating ? (
                        'Validating...'
                    ) : (
                        'Save API Key'
                    )}
                </Button>
            </div>
        </div>
    )
}
```

**Key design decisions:**
- Each key has its own save button and validation state (independent operations)
- Validation happens before save: the button shows "Validating..." then "Saved" or shows error
- Error messages clear when the user starts typing a new key
- Provider selection is at the top with a Select dropdown
- The existing `SettingsInfoCard`, `Input`, `Button`, `Select` components are reused
- Uses existing `trpcReact.ai.*` hooks — the tRPC router changes from Task 1 make these available
  </action>
  <verify>
Run `cd livos && npx tsc --noEmit` — zero errors. Verify `anthropicApiKey` appears in settings-content.tsx. Verify `validateKey` is used. Verify `primaryProvider` Select component exists.
  </verify>
  <done>
AiConfigSection has separate Anthropic and Gemini API key fields, each with independent validation-before-save flow. Provider selection dropdown at top lets user choose Claude or Gemini as primary. Error states shown inline. Menu description updated to "API keys & provider".
  </done>
</task>

<task type="auto">
  <name>Task 3: Update install.sh to prompt for Anthropic API key during setup wizard</name>
  <files>
    livos/install.sh
  </files>
  <action>
**Goal:** Add an Anthropic API key prompt to the install.sh setup wizard, alongside the existing Gemini key prompt. Update the .env generation to use the collected key.

**1. Add CONFIG_ANTHROPIC_KEY initialization** alongside the existing CONFIG_GEMINI_KEY:

Find the line:
```bash
CONFIG_GEMINI_KEY=""
```

Add after it:
```bash
CONFIG_ANTHROPIC_KEY=""
```

**2. Add Anthropic API key prompt** after the Gemini key prompt block. Find the block that ends with:
```bash
            CONFIG_GEMINI_KEY=$(wizard_input "Gemini API Key" \
                "Enter your Gemini API key:" \
                "")
        fi
```

Add after it:
```bash

        # Anthropic API Key
        if wizard_yesno "AI Configuration" \
            "Configure an Anthropic API key now?\n\nThis enables Claude as your primary AI provider.\n(You can also add this later in Settings > AI Configuration)\n\nGet a key at: https://console.anthropic.com/settings/keys"; then
            CONFIG_ANTHROPIC_KEY=$(wizard_input "Anthropic API Key" \
                "Enter your Anthropic API key:" \
                "")
        fi
```

**3. Update the configuration summary** to include Anthropic key status. Find:
```bash
        summary+="Gemini API Key: $([ -n "$CONFIG_GEMINI_KEY" ] && echo "Configured" || echo "Not set")\n"
```

Add after it:
```bash
        summary+="Anthropic API Key: $([ -n "$CONFIG_ANTHROPIC_KEY" ] && echo "Configured" || echo "Not set")\n"
```

**4. Update the .env generation** to use the collected Anthropic key. Find:
```bash
ANTHROPIC_API_KEY=
```

Replace with:
```bash
ANTHROPIC_API_KEY=${CONFIG_ANTHROPIC_KEY:-}
```

**5. Update the post-install message** to mention Settings for both keys. Find the block:
```bash
        if [[ -z "${CONFIG_GEMINI_KEY:-}" ]]; then
            echo -e "  ${YELLOW}Next step:${NC} Open Settings > AI Configuration"
            echo -e "  and add your Gemini API key."
            echo ""
        fi
```

Replace with:
```bash
        if [[ -z "${CONFIG_GEMINI_KEY:-}" ]] || [[ -z "${CONFIG_ANTHROPIC_KEY:-}" ]]; then
            echo -e "  ${YELLOW}Next step:${NC} Open Settings > AI Configuration"
            echo -e "  and add your API keys for AI providers."
            echo ""
        fi
```
  </action>
  <verify>
Grep for `CONFIG_ANTHROPIC_KEY` in install.sh — should appear in initialization, wizard prompt, summary, and .env generation. Grep for `ANTHROPIC_API_KEY=\${CONFIG_ANTHROPIC_KEY` in install.sh to verify .env template uses the variable.
  </verify>
  <done>
install.sh setup wizard prompts for Anthropic API key after Gemini key. Configuration summary shows both keys. Generated .env includes the collected Anthropic key. Post-install message updated to mention both providers.
  </done>
</task>

</tasks>

<verification>
1. `cd livos && npx tsc --noEmit` compiles with zero errors
2. `grep -n "anthropicApiKey" livos/packages/livinityd/source/modules/ai/routes.ts` shows tRPC endpoints
3. `grep -n "validateKey" livos/packages/livinityd/source/modules/ai/routes.ts` shows validation endpoint
4. `grep -n "anthropicApiKey" livos/packages/ui/src/routes/settings/_components/settings-content.tsx` shows UI
5. `grep -n "primaryProvider" livos/packages/ui/src/routes/settings/_components/settings-content.tsx` shows provider selection
6. `grep -n "CONFIG_ANTHROPIC_KEY" livos/install.sh` shows install.sh wizard prompt
7. `grep -n "ANTHROPIC_API_KEY=\${CONFIG" livos/install.sh` shows .env generation uses variable
</verification>

<success_criteria>
- Settings UI has separate Anthropic and Gemini API key fields
- API key validation makes lightweight test call before saving (AUTH-02)
- Provider selection dropdown in Settings (AUTH-03)
- tRPC routes handle both Anthropic and Gemini keys with validation
- install.sh prompts for Anthropic API key during setup wizard (AUTH-04)
- Provider selection stored in Redis nexus:config:primary_provider
- TypeScript compiles with zero errors for both livos and nexus
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-02-native-tool-calling-auth-ui/v1.5-02-03-SUMMARY.md`
</output>
