---
phase: v1.5-02-native-tool-calling-auth-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/tool-registry.ts
  - nexus/packages/core/src/providers/types.ts
  - nexus/packages/core/src/providers/claude.ts
autonomous: true

must_haves:
  truths:
    - "ToolRegistry.toClaudeTools() returns tool definitions in Claude input_schema format"
    - "ClaudeProvider.chatStream() can accept tools parameter and return tool_use content blocks"
    - "Provider types include ToolDefinition, ToolUseBlock, and ToolResultBlock for native tool calling"
  artifacts:
    - path: "nexus/packages/core/src/tool-registry.ts"
      provides: "toClaudeTools() and toClaudeToolsFiltered() methods"
      contains: "toClaudeTools"
    - path: "nexus/packages/core/src/providers/types.ts"
      provides: "ClaudeToolDefinition, ToolUseBlock, ToolResultBlock, ProviderToolCallResult types"
      contains: "ToolUseBlock"
    - path: "nexus/packages/core/src/providers/claude.ts"
      provides: "ClaudeProvider with tools support in chat() and chatStream()"
      contains: "tool_use"
  key_links:
    - from: "nexus/packages/core/src/tool-registry.ts"
      to: "nexus/packages/core/src/providers/types.ts"
      via: "toClaudeTools returns ClaudeToolDefinition[]"
      pattern: "ClaudeToolDefinition"
    - from: "nexus/packages/core/src/providers/claude.ts"
      to: "nexus/packages/core/src/providers/types.ts"
      via: "chatStream returns ToolUseBlock[] in streaming chunks"
      pattern: "ToolUseBlock"
---

<objective>
Add Claude native tool calling infrastructure: ToolRegistry schema conversion, provider type definitions for tool_use blocks, and ClaudeProvider support for passing tools and receiving tool_use responses.

Purpose: This is the foundation for Phase 2's dual-mode AgentLoop. Without these building blocks, the AgentLoop cannot send tools to Claude or parse tool_use content blocks from responses.

Output: ToolRegistry gains `toClaudeTools()`, provider types gain tool calling types, ClaudeProvider accepts tools in chat/chatStream options.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Phase 1 outputs (provider abstraction)
@.planning/phases/v1.5-01-provider-abstraction-claude/v1.5-01-02-SUMMARY.md
@.planning/phases/v1.5-01-provider-abstraction-claude/v1.5-01-03-SUMMARY.md

# Source files to modify
@nexus/packages/core/src/tool-registry.ts
@nexus/packages/core/src/providers/types.ts
@nexus/packages/core/src/providers/claude.ts
@nexus/packages/core/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool calling types to provider types and toClaudeTools() to ToolRegistry</name>
  <files>
    nexus/packages/core/src/providers/types.ts
    nexus/packages/core/src/tool-registry.ts
  </files>
  <action>
**In `nexus/packages/core/src/providers/types.ts`**, add the following types AFTER the existing `ProviderConfig` type:

```typescript
/** Claude tool definition format (input_schema, not parameters) */
export interface ClaudeToolDefinition {
  name: string;
  description: string;
  input_schema: {
    type: 'object';
    properties: Record<string, unknown>;
    required: string[];
  };
}

/** A tool_use content block from Claude's response */
export interface ToolUseBlock {
  type: 'tool_use';
  id: string;        // tool_use_id for matching tool_result
  name: string;
  input: Record<string, unknown>;
}

/** A tool_result content block to send back to Claude */
export interface ToolResultBlock {
  type: 'tool_result';
  tool_use_id: string;
  content: string;
  is_error?: boolean;
}

/** Result from provider when response contains tool calls */
export interface ProviderToolCallResult {
  text: string;                    // Any text content blocks concatenated
  toolCalls: ToolUseBlock[];       // tool_use blocks from Claude
  stopReason: string;              // 'end_turn', 'tool_use', 'max_tokens'
  inputTokens: number;
  outputTokens: number;
  provider: string;
  model: string;
}
```

Also update `ProviderChatOptions` to accept optional tools:

```typescript
export interface ProviderChatOptions {
  systemPrompt: string;
  messages: ProviderMessage[];
  tier?: ModelTier;
  maxOutputTokens?: number;
  /** Provider-specific options (extended thinking, cache control, etc.) */
  providerOptions?: Record<string, unknown>;
  /** Tool definitions for native tool calling (Claude tool_use) */
  tools?: ClaudeToolDefinition[];
}
```

Also update `ProviderStreamChunk` to carry optional tool_use block data:

```typescript
export interface ProviderStreamChunk {
  text: string;
  done: boolean;
  /** Tool use block completed during streaming */
  toolUse?: ToolUseBlock;
  /** Stop reason from the provider */
  stopReason?: string;
}
```

**In `nexus/packages/core/src/tool-registry.ts`**, add a `toClaudeTools()` method to the `ToolRegistry` class. Add `import type { ClaudeToolDefinition } from './providers/types.js';` at the top.

The method converts the existing `ToolParameter[]` format to Claude's `input_schema` format:

```typescript
/** Convert all tools to Claude's native tool definition format (input_schema) */
toClaudeTools(): ClaudeToolDefinition[] {
  return this.listAll().map((t) => {
    const properties: Record<string, unknown> = {};
    const required: string[] = [];

    for (const p of t.parameters) {
      const prop: Record<string, unknown> = {
        type: p.type,
        description: p.description,
      };
      if (p.enum) prop.enum = p.enum;
      if (p.default !== undefined) prop.default = p.default;
      properties[p.name] = prop;
      if (p.required) required.push(p.name);
    }

    return {
      name: t.name,
      description: t.description,
      input_schema: {
        type: 'object' as const,
        properties,
        required,
      },
    };
  });
}

/** Convert filtered tools to Claude's native tool definition format */
toClaudeToolsFiltered(policy?: ToolPolicy): ClaudeToolDefinition[] {
  return this.listAllFiltered(policy).map((t) => {
    const properties: Record<string, unknown> = {};
    const required: string[] = [];

    for (const p of t.parameters) {
      const prop: Record<string, unknown> = {
        type: p.type,
        description: p.description,
      };
      if (p.enum) prop.enum = p.enum;
      if (p.default !== undefined) prop.default = p.default;
      properties[p.name] = prop;
      if (p.required) required.push(p.name);
    }

    return {
      name: t.name,
      description: t.description,
      input_schema: {
        type: 'object' as const,
        properties,
        required,
      },
    };
  });
}
```

Also re-export the type from the providers barrel: ensure `nexus/packages/core/src/providers/index.ts` exports `ClaudeToolDefinition` (it already does `export * from './types.js'`).
  </action>
  <verify>
Run `cd nexus && npx tsc --noEmit` — zero errors. Grep for `toClaudeTools` in tool-registry.ts. Grep for `ToolUseBlock` in types.ts.
  </verify>
  <done>
ToolRegistry has toClaudeTools() and toClaudeToolsFiltered() methods that return ClaudeToolDefinition[]. Provider types include ToolUseBlock, ToolResultBlock, ProviderToolCallResult, and ClaudeToolDefinition. ProviderChatOptions accepts optional tools array. ProviderStreamChunk can carry toolUse blocks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ClaudeProvider to support native tool calling in chat() and chatStream()</name>
  <files>
    nexus/packages/core/src/providers/claude.ts
  </files>
  <action>
Update `ClaudeProvider` to pass tools to the Claude API when provided in options, and extract tool_use content blocks from responses.

**chat() method changes:**
- If `options.tools` is provided and non-empty, pass `tools: options.tools` to `client.messages.create()`.
- After the response, iterate `response.content` blocks. For each block:
  - If `block.type === 'text'`, concatenate to text output.
  - If `block.type === 'tool_use'`, collect into a `toolCalls` array as `ToolUseBlock` objects.
- Return a `ProviderChatResult` that includes the text. But ALSO, the method needs to convey tool calls. Since the existing `ProviderChatResult` only has `text`, add a new method `chatWithTools()` that returns `ProviderToolCallResult`.

Actually, the cleaner approach: Add a **new method** `chatWithTools()` to the AIProvider interface and implement it only in ClaudeProvider. But that changes the interface. Instead, use `providerOptions` to pass tools and encode tool calls in the result.

**Simpler approach — keep chat() signature, use providerOptions:**

In `chat()`:
```typescript
async chat(options: ProviderChatOptions): Promise<ProviderChatResult> {
  const tier = options.tier || 'sonnet';
  const model = CLAUDE_MODELS[tier] || CLAUDE_MODELS.sonnet;
  const maxTokens = options.maxOutputTokens || 4096;
  const claudeMessages = prepareForProvider(options.messages, 'claude') as Anthropic.MessageParam[];

  const client = await this.getClient();

  const createParams: any = {
    model,
    max_tokens: maxTokens,
    system: options.systemPrompt,
    messages: claudeMessages,
  };

  // Pass tools if provided
  if (options.tools && options.tools.length > 0) {
    createParams.tools = options.tools;
  }

  const response = await client.messages.create(createParams);

  // Extract text and tool_use blocks from content
  let text = '';
  const toolCalls: ToolUseBlock[] = [];
  for (const block of response.content) {
    if (block.type === 'text') {
      text += block.text;
    } else if (block.type === 'tool_use') {
      toolCalls.push({
        type: 'tool_use',
        id: block.id,
        name: block.name,
        input: block.input as Record<string, unknown>,
      });
    }
  }

  return {
    text,
    inputTokens: response.usage.input_tokens,
    outputTokens: response.usage.output_tokens,
    provider: 'claude',
    model,
    // Encode tool calls and stop reason in the result for the AgentLoop to extract
    toolCalls: toolCalls.length > 0 ? toolCalls : undefined,
    stopReason: response.stop_reason,
  } as any; // We'll extend the type properly
}
```

Wait — to keep types clean, extend `ProviderChatResult` in types.ts:

```typescript
export interface ProviderChatResult {
  text: string;
  inputTokens: number;
  outputTokens: number;
  provider: string;
  model: string;
  /** Native tool calls from the provider (Claude tool_use blocks) */
  toolCalls?: ToolUseBlock[];
  /** Provider's stop reason (end_turn, tool_use, max_tokens) */
  stopReason?: string;
}
```

**chatStream() method changes:**

Update the streaming generator to handle tool_use events:
- Track tool_use blocks being accumulated during streaming.
- When a `content_block_start` event with `type: 'tool_use'` arrives, start accumulating the tool input.
- When `input_json_delta` events arrive, accumulate the JSON string.
- When `content_block_stop` fires for a tool_use block, parse the accumulated JSON and yield a chunk with `toolUse` populated.
- Track stop_reason from `message_delta` events.

Implementation for chatStream():
```typescript
chatStream(options: ProviderChatOptions): ProviderStreamResult {
  const tier = options.tier || 'sonnet';
  const model = CLAUDE_MODELS[tier] || CLAUDE_MODELS.sonnet;
  const maxTokens = options.maxOutputTokens || 4096;
  const claudeMessages = prepareForProvider(options.messages, 'claude') as Anthropic.MessageParam[];

  let finalInputTokens = 0;
  let finalOutputTokens = 0;
  const self = this;

  async function* generate(): AsyncGenerator<ProviderStreamChunk> {
    const client = await self.getClient();

    const createParams: any = {
      model,
      max_tokens: maxTokens,
      system: options.systemPrompt,
      messages: claudeMessages,
    };

    if (options.tools && options.tools.length > 0) {
      createParams.tools = options.tools;
    }

    const stream = client.messages.stream(createParams);

    // Track tool_use accumulation
    let currentToolUse: { id: string; name: string; inputJson: string } | null = null;
    let stopReason = '';

    try {
      for await (const event of stream) {
        if (event.type === 'content_block_delta') {
          if (event.delta.type === 'text_delta') {
            yield { text: event.delta.text, done: false };
          } else if (event.delta.type === 'input_json_delta') {
            // Accumulate tool input JSON
            if (currentToolUse) {
              currentToolUse.inputJson += event.delta.partial_json;
            }
          }
        } else if (event.type === 'content_block_start') {
          if (event.content_block.type === 'tool_use') {
            currentToolUse = {
              id: event.content_block.id,
              name: event.content_block.name,
              inputJson: '',
            };
          }
        } else if (event.type === 'content_block_stop') {
          if (currentToolUse) {
            // Parse accumulated tool input and yield as toolUse chunk
            let input: Record<string, unknown> = {};
            try {
              input = currentToolUse.inputJson ? JSON.parse(currentToolUse.inputJson) : {};
            } catch {
              logger.warn('ClaudeProvider: failed to parse tool input JSON', { raw: currentToolUse.inputJson.slice(0, 200) });
            }
            yield {
              text: '',
              done: false,
              toolUse: {
                type: 'tool_use',
                id: currentToolUse.id,
                name: currentToolUse.name,
                input,
              },
            };
            currentToolUse = null;
          }
        } else if (event.type === 'message_delta') {
          stopReason = (event as any).delta?.stop_reason || '';
        }
      }

      // Get final usage
      const finalMessage = await stream.finalMessage();
      finalInputTokens = finalMessage.usage.input_tokens;
      finalOutputTokens = finalMessage.usage.output_tokens;

      yield { text: '', done: true, stopReason: stopReason || finalMessage.stop_reason || '' };
    } catch (err: any) {
      logger.error('ClaudeProvider.chatStream error', { error: err.message });
      yield { text: '', done: true };
      throw err;
    }
  }

  return {
    stream: generate(),
    getUsage: () => ({ inputTokens: finalInputTokens, outputTokens: finalOutputTokens }),
    provider: 'claude',
    model,
  };
}
```

Add `import type { ToolUseBlock } from './types.js';` at the top of claude.ts (alongside existing imports from types.js).

NOTE: Do NOT change the existing GeminiProvider — it does not support native tool calling in this codebase and will continue using JSON-in-text via the AgentLoop.
  </action>
  <verify>
Run `cd nexus && npx tsc --noEmit` — zero errors. Verify that `claude.ts` references `tool_use`, `content_block_start`, `input_json_delta`, and `content_block_stop` events. Verify `ProviderChatResult` has optional `toolCalls` and `stopReason` fields.
  </verify>
  <done>
ClaudeProvider.chat() passes tools to Claude API when provided, extracts tool_use blocks into ProviderChatResult.toolCalls. ClaudeProvider.chatStream() accumulates input_json_delta events, yields completed tool_use blocks as ProviderStreamChunk.toolUse, and includes stopReason. ProviderChatResult extended with optional toolCalls and stopReason.
  </done>
</task>

</tasks>

<verification>
1. `cd nexus && npx tsc --noEmit` compiles with zero errors
2. `grep -n "toClaudeTools" nexus/packages/core/src/tool-registry.ts` shows the method
3. `grep -n "ToolUseBlock" nexus/packages/core/src/providers/types.ts` shows the type
4. `grep -n "tool_use" nexus/packages/core/src/providers/claude.ts` shows tool handling
5. `grep -n "input_json_delta" nexus/packages/core/src/providers/claude.ts` shows streaming tool input accumulation
</verification>

<success_criteria>
- ToolRegistry.toClaudeTools() converts all registered tools to Claude input_schema format
- ToolRegistry.toClaudeToolsFiltered() respects ToolPolicy
- ClaudeProvider.chat() accepts tools, returns tool_use blocks in result
- ClaudeProvider.chatStream() accumulates input_json_delta, yields complete ToolUseBlock objects
- Provider types define ClaudeToolDefinition, ToolUseBlock, ToolResultBlock
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-02-native-tool-calling-auth-ui/v1.5-02-01-SUMMARY.md`
</output>
