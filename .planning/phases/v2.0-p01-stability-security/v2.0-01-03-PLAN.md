---
phase: v2.0-01-stability-security
plan: 03
type: execute
wave: 2
depends_on: ["v2.0-01-01"]
files_modified:
  - nexus/packages/core/src/commands.ts
  - nexus/packages/core/src/session-manager.ts
  - nexus/packages/core/src/daemon.ts
autonomous: true

must_haves:
  truths:
    - "/new resets the current session and optionally switches model tier"
    - "/new responds with confirmation including the new model tier"
    - "/compact responds with a stub message explaining it will be available in a future update"
    - "/activation toggles group trigger mode between mention and always"
    - "All new commands work identically via Telegram and Discord"
    - "Commands are parsed before reaching the AI agent — zero token cost"
    - "Unrecognized commands still pass through to the AI agent (existing behavior preserved)"
  artifacts:
    - path: "nexus/packages/core/src/commands.ts"
      provides: "New /new, /compact, /activation command handlers"
      contains: "handleNew"
    - path: "nexus/packages/core/src/session-manager.ts"
      provides: "Session reset method used by /new"
      contains: "resetSession"
  key_links:
    - from: "nexus/packages/core/src/commands.ts"
      to: "nexus/packages/core/src/session-manager.ts"
      via: "/new command calls session reset"
      pattern: "resetSession|reset"
    - from: "nexus/packages/core/src/daemon.ts"
      to: "nexus/packages/core/src/commands.ts"
      via: "isCommand check before agent processing"
      pattern: "isCommand.*handleCommand"
---

<objective>
Add /new, /compact (stub), and /activation chat commands that work identically in Telegram and Discord, parsed before the AI agent at zero token cost.

Purpose: Users need session control (/new to start fresh), future compaction access (/compact as stub), and group trigger mode control (/activation). These commands extend the existing command system in commands.ts and must be cross-channel compatible.

Output: Extended commands.ts with three new command handlers, updated session manager for /new support, and daemon integration for activation mode.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@nexus/packages/core/src/commands.ts
@nexus/packages/core/src/session-manager.ts
@nexus/packages/core/src/daemon.ts
@nexus/packages/core/src/user-session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add /new, /compact (stub), and /activation commands</name>
  <files>
    nexus/packages/core/src/commands.ts
    nexus/packages/core/src/session-manager.ts
  </files>
  <action>
1. **Extend CommandContext in `commands.ts`:**
   - Add `sessionManager?: SessionManager` to the `CommandContext` interface (import SessionManager type).
   - Add `channelId?: string` to track which channel the command came from (for activation mode).
   - Add `redis?: Redis` to the context for reading/writing activation settings.

2. **Add /new command handler:**
   - Add cases to the switch statement in `handleCommand`:
     ```typescript
     case 'new':
     case 'yeni':
       return handleNew(args, ctx);
     ```
   - Implement `handleNew`:
     ```typescript
     async function handleNew(args: string[], ctx: CommandContext): Promise<CommandResult> {
       // Reset user session
       await ctx.userSession.reset(ctx.jid);

       // Reset conversation session if sessionManager available
       if (ctx.sessionManager) {
         await ctx.sessionManager.resetSession(ctx.jid);
       }

       // Optionally switch model tier
       const validTiers = ['flash', 'haiku', 'sonnet', 'opus'];
       let modelMsg = '';
       let newModelTier: ModelTier | undefined;

       if (args.length > 0) {
         const tier = args[0].toLowerCase();
         if (validTiers.includes(tier)) {
           await ctx.userSession.setModelTier(ctx.jid, tier as ModelTier);
           newModelTier = tier as ModelTier;
           modelMsg = `\nModel: *${tier}*`;
         } else {
           return {
             handled: true,
             response: `Invalid model: "${args[0]}"\n\nValid models: ${validTiers.join(' | ')}\n\nUsage: \`/new\` or \`/new sonnet\``,
           };
         }
       }

       return {
         handled: true,
         response: `Session reset! Fresh conversation started.${modelMsg}\n\nAll context cleared. Ready for a new task.`,
         modelTier: newModelTier,
       };
     }
     ```

3. **Add /compact command handler (stub):**
   - Add cases:
     ```typescript
     case 'compact':
     case 'sikistir':
     case 'sıkıştır':
       return handleCompact(args, ctx);
     ```
   - Implement `handleCompact`:
     ```typescript
     async function handleCompact(_args: string[], _ctx: CommandContext): Promise<CommandResult> {
       return {
         handled: true,
         response: `Session compaction is not yet available.\n\nThis feature will automatically summarize older messages to save tokens while preserving key context. Coming in a future update.`,
       };
     }
     ```

4. **Add /activation command handler:**
   - Add cases:
     ```typescript
     case 'activation':
     case 'aktivasyon':
       return handleActivation(args, ctx);
     ```
   - Implement `handleActivation`:
     ```typescript
     async function handleActivation(args: string[], ctx: CommandContext): Promise<CommandResult> {
       // Activation mode controls how the bot responds in groups:
       // - "mention" (default): Only respond when @mentioned
       // - "always": Respond to all messages in the group
       const redisKey = `nexus:activation:${ctx.jid}`;

       if (args.length === 0) {
         // Show current mode
         const current = ctx.redis ? await ctx.redis.get(redisKey) : 'mention';
         return {
           handled: true,
           response: `Group activation mode: *${current || 'mention'}*\n\nModes:\n- \`mention\` — Only respond when @mentioned (default)\n- \`always\` — Respond to all messages in the group\n\nUsage: \`/activation mention\` or \`/activation always\``,
         };
       }

       const mode = args[0].toLowerCase();
       if (mode !== 'mention' && mode !== 'always') {
         return {
           handled: true,
           response: `Invalid mode: "${args[0]}"\n\nValid modes: mention | always`,
         };
       }

       if (ctx.redis) {
         await ctx.redis.set(redisKey, mode);
       }

       const desc = mode === 'mention'
         ? 'Bot will only respond when @mentioned in groups.'
         : 'Bot will respond to ALL messages in groups.';

       return {
         handled: true,
         response: `Activation mode: *${mode}*\n${desc}`,
       };
     }
     ```

5. **Update the `/help` command to include new commands:**
   - Add to the help text in `handleHelp`:
     ```
     *Session*
     `/new [model]` - Start fresh session, optionally switch model
     `/compact` - Compact conversation history (coming soon)

     *Group Activation*
     `/activation [mention|always]` - Control group trigger mode
     ```

6. **Update `listCommands()` to include new commands:**
   - Add `/new`, `/compact`, `/activation` to the returned array.

7. **Update `CommandContext` usage in `daemon.ts`:**
   - In both the `cycle()` method (line ~282-297) and `processInboxItem()` method (line ~474-492), where `handleCommand` is called, pass the additional context:
     ```typescript
     const cmdResult = await handleCommand(item.message, {
       jid: item.from,
       userSession: this.config.userSessionManager,
       currentThink: session.thinkLevel,
       currentVerbose: session.verboseLevel,
       currentModel: session.modelTier,
       sessionManager: this.config.sessionManager,  // NEW
       redis: this.config.redis,                      // NEW
     });
     ```
   - This requires updating both places in daemon.ts where `handleCommand` is called (once in `cycle()` around line 284, and once in `processInboxItem()` around line 477).
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes.
    - `grep -n 'handleNew\|handleCompact\|handleActivation' nexus/packages/core/src/commands.ts` shows all three handler functions.
    - `grep -n "case 'new'" nexus/packages/core/src/commands.ts` shows the switch case.
    - `grep -n "case 'compact'" nexus/packages/core/src/commands.ts` shows the switch case.
    - `grep -n "case 'activation'" nexus/packages/core/src/commands.ts` shows the switch case.
    - `grep -n 'sessionManager' nexus/packages/core/src/commands.ts` shows it in the CommandContext interface.
  </verify>
  <done>
    - /new command resets session and optionally switches model tier (CMD-01).
    - /compact command returns a stub message explaining the feature is coming (CMD-02 stub).
    - /activation command toggles group trigger mode between mention and always (CMD-04).
    - All commands work identically in Telegram and Discord (CMD-05) because they go through the same handleCommand function.
    - Commands are parsed before reaching the AI agent at zero token cost (CMD-06) because isCommand/handleCommand runs before skill/agent processing in daemon.ts.
    - Help text updated with new commands.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire activation mode into channel message handlers</name>
  <files>
    nexus/packages/core/src/channels/telegram.ts
    nexus/packages/core/src/channels/discord.ts
    nexus/packages/core/src/daemon.ts
  </files>
  <action>
1. **Read activation mode in daemon's channel message handler:**
   - In `index.ts`, where `channelManager.onMessage(async (msg) => { ... })` is called (around line 390-411), before adding to inbox, check the activation mode:
     ```typescript
     // Check activation mode for group messages
     if (msg.isGroup) {
       const activationMode = await redis.get(`nexus:activation:${msg.chatId}`) || 'mention';
       if (activationMode === 'mention') {
         // Default behavior: only respond when mentioned
         // The channel providers already handle this (Telegram checks @botName, Discord checks mentions)
         // No change needed here — the providers already filter by mention
       } else if (activationMode === 'always') {
         // Always mode: the message has already passed through the provider
         // But the providers currently filter out non-mentioned messages in groups
         // We need to tell the provider to pass ALL group messages through
         // Set a flag in the IncomingMessage or handle in the provider
       }
     }
     ```
   - Actually, the activation mode needs to be checked IN the channel providers, not in daemon, because the providers are the ones that filter group messages.

2. **Update TelegramProvider to respect activation mode:**
   - Add a `private activationRedis: Redis | null = null;` (use the existing `this.redis`).
   - In the `bot.on('message:text', ...)` handler, modify the group mention check (currently lines 110-115):
     ```typescript
     // In groups, check activation mode
     if (isGroup) {
       const activationMode = this.redis ? await this.redis.get(`nexus:activation:${String(msg.chat.id)}`) : 'mention';
       if (activationMode !== 'always') {
         // Default "mention" mode: only respond if mentioned
         const botUsername = this.status.botName;
         if (botUsername && !msg.text.includes(`@${botUsername}`)) {
           return;
         }
       }
       // If "always" mode, process all group messages
     }
     ```

3. **Update DiscordProvider to respect activation mode:**
   - Modify the guild mention check (currently lines 92-94):
     ```typescript
     // In guilds, check activation mode
     if (isGuild) {
       const activationMode = this.redis ? await this.redis.get(`nexus:activation:${message.channelId}`) : 'mention';
       if (activationMode !== 'always') {
         // Default "mention" mode: only respond if mentioned
         if (!message.mentions.has(this.client!.user!)) {
           return;
         }
       }
       // If "always" mode, process all guild messages
     }
     ```

4. **Cross-channel parity (CMD-05):**
   - Both Telegram and Discord now use the same activation mode Redis key pattern: `nexus:activation:{chatId}`.
   - Both read the mode and apply the same logic: `mention` = respond only when @mentioned (default), `always` = respond to all messages.
   - The `/activation` command sets the mode for the current chat ID, which is passed as `ctx.jid` (which is the chatId in the channel message handler).
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes.
    - `grep -n 'activationMode' nexus/packages/core/src/channels/telegram.ts` shows activation mode check.
    - `grep -n 'activationMode' nexus/packages/core/src/channels/discord.ts` shows activation mode check.
  </verify>
  <done>
    - /activation mode is respected by both Telegram and Discord providers.
    - "mention" mode (default) requires @mention in groups.
    - "always" mode responds to all group messages.
    - Cross-channel parity achieved: same Redis key pattern, same behavior.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors.
2. /new resets session and optionally switches model. Confirmation message includes new model if specified.
3. /compact returns a stub message about future availability.
4. /activation shows current mode or sets new mode (mention/always).
5. All commands are parsed in handleCommand before agent processing (zero token cost).
6. Activation mode is read by both Telegram and Discord providers in their group message handlers.
7. Unrecognized commands still pass through to the AI agent.
</verification>

<success_criteria>
- Requirements CMD-01 through CMD-06 are addressed (CMD-02 as stub, full implementation in Phase 3).
- All commands work identically in Telegram and Discord via the shared handleCommand function.
- No tokens are consumed by command processing.
- /help text includes all new commands.
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p01-stability-security/v2.0-01-03-SUMMARY.md`
</output>
