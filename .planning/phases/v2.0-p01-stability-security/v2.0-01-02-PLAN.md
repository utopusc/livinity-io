---
phase: v2.0-01-stability-security
plan: 02
type: execute
wave: 2
depends_on: ["v2.0-01-01"]
files_modified:
  - nexus/packages/core/src/dm-pairing.ts
  - nexus/packages/core/src/channels/telegram.ts
  - nexus/packages/core/src/channels/discord.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/packages/core/src/index.ts
  - nexus/packages/core/src/api.ts
  - livos/packages/ui/src/routes/settings/dm-pairing.tsx
autonomous: true

must_haves:
  truths:
    - "An unknown Telegram DM user receives a 6-digit activation code and their message is NOT processed by the AI"
    - "An unknown Discord DM user receives a 6-digit activation code and their message is NOT processed by the AI"
    - "Activation codes expire after 1 hour"
    - "Maximum 3 pending activation codes exist per channel at any time"
    - "Server owner can approve or deny pairing requests via the web UI Settings page"
    - "Approved users are stored in a Redis allowlist that persists across restarts"
    - "DM policy is configurable per channel: pairing, allowlist, open, disabled"
    - "Group messages bypass the DM pairing check entirely"
  artifacts:
    - path: "nexus/packages/core/src/dm-pairing.ts"
      provides: "DM pairing manager with activation code generation, verification, and allowlist"
      exports: ["DmPairingManager"]
    - path: "nexus/packages/core/src/api.ts"
      provides: "API endpoints for listing/approving/denying pairing requests"
      contains: "pairing"
    - path: "livos/packages/ui/src/routes/settings/dm-pairing.tsx"
      provides: "Settings UI panel for DM pairing management"
      contains: "DmPairing"
  key_links:
    - from: "nexus/packages/core/src/channels/telegram.ts"
      to: "nexus/packages/core/src/dm-pairing.ts"
      via: "DM check before message handler"
      pattern: "dmPairing.*check"
    - from: "nexus/packages/core/src/channels/discord.ts"
      to: "nexus/packages/core/src/dm-pairing.ts"
      via: "DM check before message handler"
      pattern: "dmPairing.*check"
    - from: "nexus/packages/core/src/api.ts"
      to: "nexus/packages/core/src/dm-pairing.ts"
      via: "REST endpoints for admin approval"
      pattern: "approve|deny"
---

<objective>
Implement DM pairing security so unknown users cannot interact with the bot without going through an activation code approval flow.

Purpose: Without DM pairing, anyone who discovers the bot's Telegram/Discord handle can run AI agent commands on the server. This is a critical security gap. The OpenClaw model (6-digit code, 1-hour TTL, admin approval, Redis allowlist) provides a proven pattern.

Output: DmPairingManager class, Telegram/Discord DM checks, admin approval API endpoints, and Settings UI panel for managing pairing requests.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@nexus/packages/core/src/channels/telegram.ts
@nexus/packages/core/src/channels/discord.ts
@nexus/packages/core/src/channels/types.ts
@nexus/packages/core/src/daemon.ts
@nexus/packages/core/src/api.ts
@livos/packages/ui/src/routes/settings/integrations.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: DmPairingManager and channel integration</name>
  <files>
    nexus/packages/core/src/dm-pairing.ts
    nexus/packages/core/src/channels/telegram.ts
    nexus/packages/core/src/channels/discord.ts
    nexus/packages/core/src/daemon.ts
    nexus/packages/core/src/index.ts
  </files>
  <action>
1. **Create `nexus/packages/core/src/dm-pairing.ts`:**
   - Export `DmPairingManager` class.
   - Constructor takes `redis: Redis`.
   - **DM policy modes** (per channel):
     - `pairing`: Unknown users get activation code flow (default for Telegram/Discord DMs).
     - `allowlist`: Only pre-approved users can interact (no activation flow — admin adds manually).
     - `open`: Anyone can interact (no checks).
     - `disabled`: Bot ignores all DMs on this channel.
   - **Redis keys:**
     - `nexus:dm:allowlist:{channel}` — SET of approved user IDs (e.g., `nexus:dm:allowlist:telegram`).
     - `nexus:dm:pending:{channel}` — HASH of pending requests: field = userId, value = JSON `{ code, userName, createdAt, channelChatId }`.
     - `nexus:dm:policy:{channel}` — STRING of policy mode (`pairing|allowlist|open|disabled`).
   - **Methods:**
     - `async getPolicy(channel: string): Promise<DmPolicy>` — Read from Redis, default to `'pairing'` for telegram/discord, `'open'` for others.
     - `async setPolicy(channel: string, policy: DmPolicy): Promise<void>` — Write to Redis.
     - `async isAllowed(channel: string, userId: string): Promise<boolean>` — Check if userId is in the allowlist SET.
     - `async checkAndInitiatePairing(channel: string, userId: string, userName: string, chatId: string): Promise<{ allowed: boolean; message?: string }>`:
       - If policy is `open`, return `{ allowed: true }`.
       - If policy is `disabled`, return `{ allowed: false, message: 'DM messages are disabled on this channel.' }`.
       - If user is in allowlist, return `{ allowed: true }`.
       - If user already has a pending request, return `{ allowed: false, message: 'Your activation request is pending. Code: {existingCode}. Please wait for admin approval.' }`.
       - Check pending count: `await redis.hlen('nexus:dm:pending:{channel}')`. If >= 3, return `{ allowed: false, message: 'Too many pending requests. Please try again later.' }`.
       - Generate 6-digit code: `Math.floor(100000 + Math.random() * 900000).toString()`.
       - Store in pending hash with 1-hour TTL on the hash entry:
         ```
         await redis.hset('nexus:dm:pending:{channel}', userId, JSON.stringify({ code, userName, createdAt: Date.now(), channelChatId: chatId }));
         await redis.expire('nexus:dm:pending:{channel}', 3600);
         ```
       - Return `{ allowed: false, message: 'Activation required. Your code: **{code}**. The server admin will review your request.' }`.
     - `async approvePairing(channel: string, userId: string): Promise<boolean>`:
       - Get pending entry. If not found, return false.
       - Add userId to allowlist: `await redis.sadd('nexus:dm:allowlist:{channel}', userId)`.
       - Remove from pending: `await redis.hdel('nexus:dm:pending:{channel}', userId)`.
       - Return true.
     - `async denyPairing(channel: string, userId: string): Promise<boolean>`:
       - Remove from pending: `await redis.hdel('nexus:dm:pending:{channel}', userId)`.
       - Return true.
     - `async getPendingRequests(channel?: string): Promise<PairingRequest[]>`:
       - If channel specified, get pending for that channel.
       - If not, get pending for all channels (telegram, discord).
       - Return array of `{ channel, userId, userName, code, createdAt, channelChatId }`.
     - `async removeFromAllowlist(channel: string, userId: string): Promise<void>`:
       - Remove from SET.
     - `async getAllowlist(channel: string): Promise<string[]>`:
       - Return all members of the SET.

   - **Types:**
     ```typescript
     export type DmPolicy = 'pairing' | 'allowlist' | 'open' | 'disabled';
     export interface PairingRequest {
       channel: string;
       userId: string;
       userName: string;
       code: string;
       createdAt: number;
       channelChatId: string;
     }
     ```

2. **Integrate into TelegramProvider (`channels/telegram.ts`):**
   - Add `private dmPairing: DmPairingManager | null = null;` property.
   - Add `setDmPairing(manager: DmPairingManager)` method.
   - In the `bot.on('message:text', ...)` handler, AFTER the dedup and stale checks, BEFORE the existing message handler call:
     ```typescript
     // DM pairing check — only for non-group (private) messages
     if (!isGroup && this.dmPairing) {
       const userId = String(msg.from?.id || 0);
       const pairingResult = await this.dmPairing.checkAndInitiatePairing(
         'telegram', userId, userName, String(msg.chat.id)
       );
       if (!pairingResult.allowed) {
         // Send activation message and do NOT pass to handler
         if (pairingResult.message) {
           await ctx.reply(pairingResult.message);
         }
         logger.info('TelegramProvider: DM pairing required', { userId, userName });
         return;
       }
     }
     ```

3. **Integrate into DiscordProvider (`channels/discord.ts`):**
   - Same pattern as Telegram:
   - Add `private dmPairing: DmPairingManager | null = null;` and `setDmPairing(manager)`.
   - In the `client.on(Events.MessageCreate, ...)` handler, AFTER the bot-message check, BEFORE the guild mention check:
     ```typescript
     // DM pairing check — only for DMs (non-guild messages)
     if (!isGuild && this.dmPairing) {
       const pairingResult = await this.dmPairing.checkAndInitiatePairing(
         'discord', message.author.id, message.author.username, message.channelId
       );
       if (!pairingResult.allowed) {
         if (pairingResult.message) {
           await message.reply(pairingResult.message);
         }
         logger.info('DiscordProvider: DM pairing required', { userId: message.author.id });
         return;
       }
     }
     ```

4. **Wire DmPairingManager in `index.ts`:**
   - Create `const dmPairingManager = new DmPairingManager(redis);` after UserSessionManager initialization.
   - After `channelManager.connectAll()`, wire the DM pairing into the providers:
     ```typescript
     // Wire DM pairing into channel providers
     const telegramProvider = channelManager.getProvider('telegram');
     if (telegramProvider && 'setDmPairing' in telegramProvider) {
       (telegramProvider as any).setDmPairing(dmPairingManager);
     }
     const discordProvider = channelManager.getProvider('discord');
     if (discordProvider && 'setDmPairing' in discordProvider) {
       (discordProvider as any).setDmPairing(dmPairingManager);
     }
     ```
   - Pass `dmPairingManager` to the `createApiServer()` call (add to the options object).

5. **Group messages bypass:**
   - The integration already handles this: the DM pairing check is guarded by `if (!isGroup ...)` in Telegram and `if (!isGuild ...)` in Discord. Group/guild messages skip the check entirely (DM-06).
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes.
    - `grep -rn 'DmPairingManager' nexus/packages/core/src/` shows class definition and usage in index.ts.
    - `grep -n 'dmPairing' nexus/packages/core/src/channels/telegram.ts` shows DM check integration.
    - `grep -n 'dmPairing' nexus/packages/core/src/channels/discord.ts` shows DM check integration.
  </verify>
  <done>
    - DmPairingManager class exists with activation code generation, approval/deny, allowlist, and per-channel policy.
    - Telegram DMs from unknown users trigger activation code and block message processing.
    - Discord DMs from unknown users trigger activation code and block message processing.
    - Group/guild messages bypass DM pairing entirely.
    - Max 3 pending codes per channel, codes expire after 1 hour.
  </done>
</task>

<task type="auto">
  <name>Task 2: Admin approval API and Settings UI</name>
  <files>
    nexus/packages/core/src/api.ts
    livos/packages/ui/src/routes/settings/dm-pairing.tsx
  </files>
  <action>
1. **Add API endpoints in `api.ts`:**
   - Add `dmPairingManager` to the `createApiServer` options type.
   - Add the following REST endpoints (follow the existing pattern of the api.ts file for route structure, auth middleware, etc.):

   ```
   GET /api/dm-pairing/pending
   ```
   - Returns all pending pairing requests across channels.
   - Response: `{ requests: PairingRequest[] }`

   ```
   GET /api/dm-pairing/allowlist/:channel
   ```
   - Returns the allowlist for a specific channel.
   - Response: `{ users: string[] }`

   ```
   POST /api/dm-pairing/approve
   ```
   - Body: `{ channel: string, userId: string }`
   - Calls `dmPairingManager.approvePairing(channel, userId)`.
   - On success, send a notification to the user via the appropriate channel: "Your access has been approved! You can now send messages."
   - Response: `{ success: boolean }`

   ```
   POST /api/dm-pairing/deny
   ```
   - Body: `{ channel: string, userId: string }`
   - Calls `dmPairingManager.denyPairing(channel, userId)`.
   - Response: `{ success: boolean }`

   ```
   GET /api/dm-pairing/policy/:channel
   ```
   - Returns the current DM policy for the channel.
   - Response: `{ policy: DmPolicy }`

   ```
   PUT /api/dm-pairing/policy/:channel
   ```
   - Body: `{ policy: DmPolicy }`
   - Sets the DM policy for the channel.
   - Response: `{ success: boolean }`

   ```
   DELETE /api/dm-pairing/allowlist/:channel/:userId
   ```
   - Removes a user from the allowlist.
   - Response: `{ success: boolean }`

   All endpoints should be behind the existing auth middleware (JWT/API key check used by other settings endpoints).

2. **Create Settings UI component at `livos/packages/ui/src/routes/settings/dm-pairing.tsx`:**
   - Follow the existing settings page pattern (look at `integrations.tsx` or `ai-config.tsx` for component structure, imports, and styling patterns).
   - The component should show:
     - **Pending Requests section:** A list of pending pairing requests with columns: Channel, User, Code, Time, and Approve/Deny buttons.
     - **Allowlist section:** Per-channel tabs (Telegram, Discord) showing approved users with a Remove button.
     - **Policy section:** Per-channel dropdown to select DM policy (pairing, allowlist, open, disabled) with a description for each option.
   - Use the existing UI components: buttons, cards, badges from the project's shadcn/ui setup.
   - Fetch data from the API endpoints above using `fetch` with the JWT token from the auth context.
   - Auto-refresh pending requests every 10 seconds.
   - Wire this component into the Settings navigation — find the settings router or sidebar that lists settings pages (check `livos/packages/ui/src/routes/settings/index.tsx` or the settings content component) and add a "DM Security" or "DM Pairing" entry.
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes.
    - `grep -n '/api/dm-pairing' nexus/packages/core/src/api.ts` shows all 6 endpoint registrations.
    - The Settings UI component file exists at `livos/packages/ui/src/routes/settings/dm-pairing.tsx`.
    - `npx tsc --noEmit` in `livos/packages/ui` passes (or Vite build succeeds).
  </verify>
  <done>
    - Six REST API endpoints exist for DM pairing management (pending list, approve, deny, allowlist, policy get/set, remove from allowlist).
    - Settings UI page shows pending requests with approve/deny buttons, allowlist with remove, and per-channel policy selection.
    - The DM pairing settings page is accessible from the Settings navigation.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors for both nexus/packages/core and livos/packages/ui.
2. DmPairingManager class handles all 4 policy modes: pairing, allowlist, open, disabled.
3. Telegram private messages from unknown users trigger activation code.
4. Discord DM messages from unknown users trigger activation code.
5. Group/guild messages bypass DM checks.
6. API endpoints exist for all CRUD operations on pairing requests and allowlists.
7. Settings UI displays pending requests and allows approve/deny.
</verification>

<success_criteria>
- Requirements DM-01 through DM-06 are fully addressed.
- Unknown DM users receive a 6-digit activation code and their message is not processed by the AI.
- Server owner can approve or deny in the web UI.
- Approved users persist in Redis across restarts.
- Group messages always bypass pairing.
- DM policy is configurable per channel.
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p01-stability-security/v2.0-01-02-SUMMARY.md`
</output>
