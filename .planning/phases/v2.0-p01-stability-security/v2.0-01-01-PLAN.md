---
phase: v2.0-01-stability-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/index.ts
  - nexus/packages/core/src/sdk-agent-runner.ts
  - nexus/packages/core/src/channels/telegram.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/deploy/ecosystem.config.cjs
  - nexus/packages/core/src/infra/circuit-breaker.ts
autonomous: true

must_haves:
  truths:
    - "nexus-core survives unhandled promise rejections without crashing"
    - "nexus-core survives uncaught exceptions from known-recoverable errors without crashing"
    - "setTimeout-based cron handler in daemon.ts is replaced with BullMQ repeatable job"
    - "Redis connection failures do not crash the process"
    - "grammy Telegram polling offset is persisted to Redis and restored on restart"
    - "SdkAgentRunner stops after max 15 turns even if the SDK keeps running"
    - "PM2 config includes max_memory_restart and exponential backoff restart delay"
  artifacts:
    - path: "nexus/packages/core/src/index.ts"
      provides: "Enhanced global error handlers with broader recoverable pattern matching"
      contains: "unhandledRejection"
    - path: "nexus/packages/core/src/infra/circuit-breaker.ts"
      provides: "Redis circuit breaker that prevents cascade failures"
      exports: ["CircuitBreaker"]
    - path: "nexus/packages/core/src/sdk-agent-runner.ts"
      provides: "Agent turn cap enforcement"
      contains: "maxTurns"
    - path: "nexus/packages/core/src/channels/telegram.ts"
      provides: "Polling offset persistence to Redis"
      contains: "nexus:telegram:offset"
    - path: "nexus/deploy/ecosystem.config.cjs"
      provides: "PM2 config with memory limits and exponential backoff"
      contains: "exp_backoff_restart_delay"
  key_links:
    - from: "nexus/packages/core/src/infra/circuit-breaker.ts"
      to: "nexus/packages/core/src/index.ts"
      via: "Redis connection wrapped with circuit breaker"
      pattern: "CircuitBreaker"
    - from: "nexus/packages/core/src/daemon.ts"
      to: "BullMQ repeatable job"
      via: "cron handler replaced with queue.add with repeat option"
      pattern: "repeat.*every"
---

<objective>
Harden the nexus-core process so it runs for 24+ hours without a single PM2 restart under normal load.

Purpose: The current nexus-core process restarts ~3.3 times per hour (153 restarts in 47 hours). Root causes are unhandled promise rejections, setTimeout-based crons leaking on restart, Redis cascade failures, and no memory limits. Every subsequent Phase 1 feature (DM pairing, commands, usage tracking) requires a stable process foundation.

Output: Hardened index.ts with broader exception handling, Redis circuit breaker, BullMQ repeatable crons replacing setTimeout, grammy offset persistence, agent turn cap, and PM2 ecosystem config with exponential backoff.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@nexus/packages/core/src/index.ts
@nexus/packages/core/src/daemon.ts
@nexus/packages/core/src/sdk-agent-runner.ts
@nexus/packages/core/src/channels/telegram.ts
@nexus/packages/core/src/infra/errors.ts
@nexus/packages/core/src/scheduler.ts
@nexus/deploy/ecosystem.config.cjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Global error handlers, Redis circuit breaker, and PM2 config</name>
  <files>
    nexus/packages/core/src/index.ts
    nexus/packages/core/src/infra/circuit-breaker.ts
    nexus/deploy/ecosystem.config.cjs
  </files>
  <action>
1. **Create `nexus/packages/core/src/infra/circuit-breaker.ts`:**
   - Export a `CircuitBreaker` class that wraps Redis operations.
   - States: CLOSED (normal), OPEN (failing — reject fast), HALF_OPEN (testing recovery).
   - Config: `failureThreshold: 5`, `resetTimeoutMs: 30000` (30s), `halfOpenMaxAttempts: 3`.
   - When OPEN, Redis calls throw immediately with a descriptive error instead of hanging/crashing.
   - When failure count exceeds threshold, transition to OPEN and log `logger.error('CircuitBreaker: OPEN — Redis unreachable')`.
   - After resetTimeoutMs, transition to HALF_OPEN and allow one test call.
   - On success in HALF_OPEN, transition back to CLOSED.
   - Export from `nexus/packages/core/src/infra/index.ts` barrel file.

2. **Enhance `nexus/packages/core/src/index.ts` global error handlers:**
   - The existing `process.on('unhandledRejection')` handler already logs. Enhance the `uncaughtException` handler to expand the `recoverable` pattern list. Add these patterns to the recoverable check:
     - `'AbortError'` (SDK abort signals)
     - `'EPIPE'` (broken pipe)
     - `'ECONNREFUSED'` (Redis or service down)
     - `'ERR_STREAM'` (stream errors)
     - `'write after end'` (stream race conditions)
     - `'Cannot read properties of null'` (common grammy race condition on shutdown)
   - After the existing Redis constructor, wrap the redis instance's command methods with the CircuitBreaker. Import CircuitBreaker and create an instance. Add an `error` event handler on redis that reports to the circuit breaker: `redis.on('error', (err) => { circuitBreaker.recordFailure(); logger.error('Redis error (circuit breaker notified)', { error: err.message }); })`. On successful Redis reconnection (`redis.on('connect', ...)` — already exists), call `circuitBreaker.recordSuccess()`.
   - NOTE: Do NOT change the main Redis connection constructor or options. The circuit breaker wraps around the error handling, not the connection itself. The main goal is preventing cascade crashes when Redis goes down temporarily.

3. **Update `nexus/deploy/ecosystem.config.cjs`:**
   - Add `exp_backoff_restart_delay: 100` to the nexus-core app config (PM2 exponential backoff: 100ms, 200ms, 400ms...).
   - Ensure `max_memory_restart: '500M'` is present (it already is, verify).
   - Add `kill_timeout: 5000` so PM2 gives the process 5 seconds to clean up on restart.
   - Add `listen_timeout: 10000` so PM2 waits 10 seconds before considering the process ready.
   - Add `autorestart: true` (explicit).
   - Keep all other app entries (nexus-mcp, nexus-whatsapp, nexus-worker, nexus-memory) unchanged.
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes (no type errors).
    - The CircuitBreaker class exists and exports correctly.
    - ecosystem.config.cjs contains `exp_backoff_restart_delay` and `kill_timeout`.
  </verify>
  <done>
    - CircuitBreaker class exists at `nexus/packages/core/src/infra/circuit-breaker.ts` with CLOSED/OPEN/HALF_OPEN states.
    - Global error handlers catch broader exception patterns without crashing.
    - PM2 ecosystem config has exponential backoff, kill timeout, and memory limits.
  </done>
</task>

<task type="auto">
  <name>Task 2: BullMQ cron replacement, grammy offset persistence, and agent turn cap</name>
  <files>
    nexus/packages/core/src/daemon.ts
    nexus/packages/core/src/channels/telegram.ts
    nexus/packages/core/src/sdk-agent-runner.ts
  </files>
  <action>
1. **Replace setTimeout-based cron handler in `daemon.ts`:**
   - In `registerHandlers()`, find the `router.register('cron', ...)` handler (around line 634-657).
   - Currently it uses `setTimeout()` to schedule tasks. Replace this with a BullMQ delayed job.
   - The daemon already has access to `this.config.redis` and BullMQ is already imported in `index.ts`.
   - Add a new property to DaemonConfig: `cronQueue?: Queue` (from BullMQ).
   - In `index.ts`, create a `cronQueue = new Queue('nexus-cron', { connection: bullConnection, ... })` and a corresponding Worker that calls `daemon.addToInbox(...)` when the job fires.
   - In daemon's cron handler, instead of `setTimeout(() => { this.addToInbox(...) }, ms)`, do:
     ```typescript
     await this.config.cronQueue?.add('cron-task', {
       task: scheduledTask,
       source: scheduledSource,
       from: scheduledFrom,
       params: scheduledParams,
     }, { delay: ms, removeOnComplete: true, removeOnFail: true });
     ```
   - This ensures cron jobs survive process restarts and don't leak timers.

2. **Also replace the self-reflection setTimeout pattern in `daemon.ts`:**
   - The `cycle()` method (around line 414) has `if (this.cycleCount % 480 === 0) { await this.selfReflect() }`. This is fine as-is since it runs within the main loop, but the Docker cleanup (`this.cycleCount % 10 === 0`) and hourly stats (`this.cycleCount % 120 === 0`) similarly depend on the loop interval being consistent. These are acceptable as-is since they're within the main loop, not standalone setTimeout calls. Leave them unchanged.

3. **Persist grammy Telegram polling offset to Redis in `channels/telegram.ts`:**
   - In the `connect()` method, before calling `this.bot.start()`, set the `offset` option:
     ```typescript
     // Load persisted offset from Redis
     const savedOffset = await this.redis?.get('nexus:telegram:offset');
     const offsetNum = savedOffset ? parseInt(savedOffset, 10) : undefined;
     ```
   - Pass the offset to `this.bot.start()`:
     ```typescript
     this.bot.start({
       onStart: () => { logger.info('TelegramProvider: polling started', { botName: this.status.botName }); },
       ...(offsetNum ? { offset: offsetNum } : {}),
     });
     ```
   - After each message is processed (in the `bot.on('message:text', ...)` handler), persist the update_id + 1 as the new offset:
     ```typescript
     // Persist polling offset for restart recovery
     if (this.redis) {
       await this.redis.set('nexus:telegram:offset', String(msgUpdateId + 1));
     }
     ```
   - Place this AFTER the dedup check (line 87-93) but BEFORE the stale message drop, so even stale messages advance the offset.

4. **Cap SdkAgentRunner turns in `sdk-agent-runner.ts`:**
   - The `maxTurns` default is already `30` (line 154). Change the fallback chain to cap at 15:
     ```typescript
     const maxTurns = Math.min(this.config.maxTurns ?? agentDefaults?.maxTurns ?? 15, 25);
     ```
   - This means: use config value, fall back to nexus config, fall back to 15, and never exceed 25 regardless of config.
   - In the `for await (const message of messages)` loop, add a safety check after incrementing turns:
     ```typescript
     turns++;
     if (turns > maxTurns) {
       logger.warn('SdkAgentRunner: turn limit reached, stopping', { turns, maxTurns });
       break;
     }
     ```
   - After the loop completes (whether normally or via break), if the loop was broken due to turn limit, set `stoppedReason: 'turn_limit'` in the return value.
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes.
    - `grep -n 'setTimeout' nexus/packages/core/src/daemon.ts` in the cron handler section shows NO setTimeout calls for scheduled tasks (the sleep helper `setTimeout` in the sleep method is fine).
    - `grep -n 'nexus:telegram:offset' nexus/packages/core/src/channels/telegram.ts` returns matches for both get and set operations.
    - `grep -n 'turn_limit' nexus/packages/core/src/sdk-agent-runner.ts` returns a match.
  </verify>
  <done>
    - The cron handler in daemon.ts uses BullMQ delayed jobs instead of setTimeout.
    - A corresponding BullMQ worker in index.ts processes cron jobs by calling daemon.addToInbox().
    - Telegram polling offset is persisted to Redis key `nexus:telegram:offset` and restored on restart.
    - SdkAgentRunner defaults to 15 turns with a hard cap of 25, and breaks the loop if exceeded.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in `nexus/packages/core` with zero type errors.
2. CircuitBreaker class exists and is exported from infra barrel.
3. Global error handlers cover at least 8 recoverable error patterns.
4. PM2 ecosystem.config.cjs has `exp_backoff_restart_delay`, `kill_timeout`, `max_memory_restart`.
5. Cron handler uses BullMQ delayed jobs (no setTimeout for scheduled tasks).
6. Telegram offset persisted to and loaded from Redis.
7. Agent turn cap defaults to 15 with hard maximum of 25.
</verification>

<success_criteria>
- All 7 STAB requirements (STAB-01 through STAB-07) are addressed by the code changes.
- TypeScript compilation passes without errors.
- No setTimeout-based scheduling remains in the cron handler.
- The process is structurally more resilient: broader exception handling, circuit breaker for Redis, turn limits, offset persistence, BullMQ crons.
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p01-stability-security/v2.0-01-01-SUMMARY.md`
</output>
