---
phase: v2.0-01-stability-security
plan: 04
type: execute
wave: 3
depends_on: ["v2.0-01-01", "v2.0-01-03"]
files_modified:
  - nexus/packages/core/src/usage-tracker.ts
  - nexus/packages/core/src/commands.ts
  - nexus/packages/core/src/daemon.ts
  - nexus/packages/core/src/sdk-agent-runner.ts
  - nexus/packages/core/src/index.ts
  - nexus/packages/core/src/api.ts
  - livos/packages/ui/src/routes/settings/usage-dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "Every agent session records input tokens, output tokens, turn count, and tool call count"
    - "Per-user cumulative usage is tracked in Redis with daily rollup"
    - "/usage command shows current session and cumulative token counts"
    - "/usage cost shows estimated cost breakdown by model tier"
    - "/usage off hides usage display, /usage tokens shows minimal, /usage full shows everything"
    - "Web UI Settings page shows a usage dashboard with daily token consumption data"
    - "TTFB latency is tracked per agent request"
  artifacts:
    - path: "nexus/packages/core/src/usage-tracker.ts"
      provides: "Usage tracking service with Redis counters and daily rollup"
      exports: ["UsageTracker"]
    - path: "nexus/packages/core/src/commands.ts"
      provides: "/usage command handler"
      contains: "handleUsage"
    - path: "nexus/packages/core/src/api.ts"
      provides: "Usage API endpoints for dashboard"
      contains: "/api/usage"
    - path: "livos/packages/ui/src/routes/settings/usage-dashboard.tsx"
      provides: "Usage dashboard component with daily charts"
      contains: "UsageDashboard"
  key_links:
    - from: "nexus/packages/core/src/daemon.ts"
      to: "nexus/packages/core/src/usage-tracker.ts"
      via: "Records usage after each agent run"
      pattern: "usageTracker.*record"
    - from: "nexus/packages/core/src/sdk-agent-runner.ts"
      to: "nexus/packages/core/src/daemon.ts"
      via: "Returns token counts and TTFB in AgentResult"
      pattern: "totalInputTokens|totalOutputTokens|ttfbMs"
    - from: "nexus/packages/core/src/commands.ts"
      to: "nexus/packages/core/src/usage-tracker.ts"
      via: "/usage command reads from usage tracker"
      pattern: "usageTracker.*get"
    - from: "livos/packages/ui/src/routes/settings/usage-dashboard.tsx"
      to: "nexus/packages/core/src/api.ts"
      via: "Fetches daily usage data from API"
      pattern: "fetch.*api/usage"
---

<objective>
Instrument every agent session with usage metrics (tokens, turns, tools, TTFB), build Redis-based tracking with daily rollup, implement the /usage command, and create a Settings page usage dashboard.

Purpose: Users need visibility into their token consumption and session costs. Without usage tracking, there is no way to detect budget overruns, identify expensive sessions, or understand usage patterns. The SdkAgentRunner already returns input/output token counts — this plan wires them through to persistent storage and user-facing displays.

Output: UsageTracker class, /usage command with multiple display modes, usage API endpoints, and Settings dashboard component.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@nexus/packages/core/src/sdk-agent-runner.ts
@nexus/packages/core/src/daemon.ts
@nexus/packages/core/src/session-manager.ts
@nexus/packages/core/src/user-session.ts
@nexus/packages/core/src/commands.ts
@nexus/packages/core/src/api.ts
@.planning/phases/v2.0-p01-stability-security/v2.0-01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: UsageTracker class, TTFB instrumentation, and daemon wiring</name>
  <files>
    nexus/packages/core/src/usage-tracker.ts
    nexus/packages/core/src/sdk-agent-runner.ts
    nexus/packages/core/src/daemon.ts
    nexus/packages/core/src/index.ts
  </files>
  <action>
1. **Create `nexus/packages/core/src/usage-tracker.ts`:**
   - Export `UsageTracker` class.
   - Constructor takes `redis: Redis`.

   **Types:**
   ```typescript
   export interface SessionUsage {
     sessionId: string;
     userId: string;
     channel: string;
     modelTier: string;
     inputTokens: number;
     outputTokens: number;
     turnCount: number;
     toolCallCount: number;
     ttfbMs: number;
     startedAt: number;
     completedAt: number;
   }

   export interface DailyUsage {
     date: string; // YYYY-MM-DD
     inputTokens: number;
     outputTokens: number;
     totalSessions: number;
     totalTurns: number;
     totalToolCalls: number;
     avgTtfbMs: number;
     byModel: Record<string, { inputTokens: number; outputTokens: number; sessions: number }>;
   }

   export interface UserUsageSummary {
     userId: string;
     currentSession: SessionUsage | null;
     today: DailyUsage;
     cumulative: {
       totalInputTokens: number;
       totalOutputTokens: number;
       totalSessions: number;
       totalTurns: number;
     };
   }

   export type UsageDisplayMode = 'off' | 'tokens' | 'full' | 'cost';
   ```

   **Redis key patterns:**
   - `nexus:usage:session:{userId}` — HASH storing current session usage (overwritten each session).
   - `nexus:usage:daily:{YYYY-MM-DD}:{userId}` — HASH storing daily aggregated usage. TTL: 90 days.
   - `nexus:usage:cumulative:{userId}` — HASH storing all-time cumulative usage.
   - `nexus:usage:display:{userId}` — STRING storing display mode preference.

   **Methods:**
   - `async recordSession(usage: SessionUsage): Promise<void>`:
     - Store as current session: `redis.hset('nexus:usage:session:{userId}', { ...fields })`.
     - Increment daily counters: `redis.hincrby('nexus:usage:daily:{date}:{userId}', 'inputTokens', usage.inputTokens)` etc. Set TTL 90 days on first write for the day.
     - Increment cumulative counters: `redis.hincrby('nexus:usage:cumulative:{userId}', 'totalInputTokens', usage.inputTokens)` etc.
     - Log: `logger.info('UsageTracker: session recorded', { userId, inputTokens, outputTokens, turnCount, ttfbMs })`.

   - `async getCurrentSession(userId: string): Promise<SessionUsage | null>`:
     - Read from `nexus:usage:session:{userId}`. Parse and return.

   - `async getDailyUsage(userId: string, date?: string): Promise<DailyUsage>`:
     - Default date = today (YYYY-MM-DD).
     - Read from `nexus:usage:daily:{date}:{userId}`. Parse and return with defaults for missing fields.

   - `async getDailyRange(userId: string, days: number): Promise<DailyUsage[]>`:
     - Read daily usage for the last N days. Return array sorted by date ascending.

   - `async getCumulative(userId: string): Promise<{ totalInputTokens: number; totalOutputTokens: number; totalSessions: number; totalTurns: number }>`:
     - Read from `nexus:usage:cumulative:{userId}`.

   - `async getUserSummary(userId: string): Promise<UserUsageSummary>`:
     - Combine current session, today's usage, and cumulative into a single summary object.

   - `async setDisplayMode(userId: string, mode: UsageDisplayMode): Promise<void>`:
     - Store in `nexus:usage:display:{userId}`.

   - `async getDisplayMode(userId: string): Promise<UsageDisplayMode>`:
     - Read from `nexus:usage:display:{userId}`, default to `'tokens'`.

   - `estimateCost(inputTokens: number, outputTokens: number, modelTier: string): { inputCost: number; outputCost: number; totalCost: number }`:
     - Static method. Estimated costs per 1M tokens:
       - haiku: input $0.25, output $1.25
       - sonnet: input $3.00, output $15.00
       - opus: input $15.00, output $75.00
     - Return costs in USD rounded to 4 decimal places.

2. **Add TTFB tracking to `sdk-agent-runner.ts`:**
   - At the start of `run()`, record start time: `const startTime = Date.now();`.
   - Add a `let ttfbMs = 0;` variable.
   - In the `for await` loop, when the first `assistant` message with text content arrives, record TTFB:
     ```typescript
     if (ttfbMs === 0 && block.type === 'text' && block.text) {
       ttfbMs = Date.now() - startTime;
     }
     ```
   - Include `ttfbMs` in the returned `AgentResult`. Add `ttfbMs?: number` to the `AgentResult` interface in `agent.ts` (or wherever it is defined).

3. **Wire UsageTracker in daemon.ts:**
   - Add `usageTracker?: UsageTracker` to `DaemonConfig`.
   - In the agent execution flow within daemon.ts (after the SdkAgentRunner returns a result), record usage:
     - Find where `SdkAgentRunner.run()` results are processed (search for `totalInputTokens` or `agentResult`).
     - After getting the result, call:
       ```typescript
       if (this.config.usageTracker && item.from) {
         const session = await this.config.userSessionManager?.get(item.from);
         await this.config.usageTracker.recordSession({
           sessionId: randomUUID(),
           userId: item.from,
           channel: item.source,
           modelTier: session?.modelTier || 'sonnet',
           inputTokens: agentResult.totalInputTokens,
           outputTokens: agentResult.totalOutputTokens,
           turnCount: agentResult.turns,
           toolCallCount: agentResult.toolCalls?.length || 0,
           ttfbMs: agentResult.ttfbMs || 0,
           startedAt: startTime,
           completedAt: Date.now(),
         });
       }
       ```

4. **Initialize UsageTracker in `index.ts`:**
   - Create `const usageTracker = new UsageTracker(redis);` after UserSessionManager initialization.
   - Pass `usageTracker` to the Daemon constructor.
   - Pass `usageTracker` to `createApiServer()`.
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes.
    - `grep -n 'UsageTracker' nexus/packages/core/src/usage-tracker.ts` shows class definition.
    - `grep -n 'ttfbMs' nexus/packages/core/src/sdk-agent-runner.ts` shows TTFB tracking.
    - `grep -n 'usageTracker' nexus/packages/core/src/daemon.ts` shows usage recording after agent runs.
    - `grep -n 'usageTracker' nexus/packages/core/src/index.ts` shows initialization and wiring.
  </verify>
  <done>
    - UsageTracker class exists with session recording, daily aggregation, cumulative tracking, and cost estimation.
    - SdkAgentRunner tracks TTFB for each agent request.
    - Daemon records usage after every agent run.
    - UsageTracker is initialized and wired into the system.
  </done>
</task>

<task type="auto">
  <name>Task 2: /usage command, API endpoints, and Settings dashboard</name>
  <files>
    nexus/packages/core/src/commands.ts
    nexus/packages/core/src/api.ts
    livos/packages/ui/src/routes/settings/usage-dashboard.tsx
  </files>
  <action>
1. **Add /usage command to `commands.ts`:**
   - Add `usageTracker?: UsageTracker` to `CommandContext` (import UsageTracker type).
   - Add cases to the switch statement:
     ```typescript
     case 'usage':
     case 'kullanim':
     case 'kullanım':
       return handleUsage(args, ctx);
     ```
   - Implement `handleUsage`:
     ```typescript
     async function handleUsage(args: string[], ctx: CommandContext): Promise<CommandResult> {
       if (!ctx.usageTracker) {
         return { handled: true, response: 'Usage tracking is not available.' };
       }

       // Handle display mode subcommands
       if (args.length > 0) {
         const subcommand = args[0].toLowerCase();

         if (['off', 'tokens', 'full', 'cost'].includes(subcommand)) {
           await ctx.usageTracker.setDisplayMode(ctx.jid, subcommand as UsageDisplayMode);
           const descriptions: Record<string, string> = {
             off: 'Usage display disabled',
             tokens: 'Show token counts after each response',
             full: 'Show tokens, turns, and tools after each response',
             cost: 'Show estimated cost breakdown after each response',
           };
           return {
             handled: true,
             response: `Usage display: *${subcommand}*\n${descriptions[subcommand]}`,
           };
         }
       }

       // Default: show usage summary
       const summary = await ctx.usageTracker.getUserSummary(ctx.jid);

       let response = `*Usage Summary*\n\n`;

       // Current session
       if (summary.currentSession) {
         const s = summary.currentSession;
         response += `*Current Session*\n`;
         response += `Input: ${s.inputTokens.toLocaleString()} tokens\n`;
         response += `Output: ${s.outputTokens.toLocaleString()} tokens\n`;
         response += `Turns: ${s.turnCount} | Tools: ${s.toolCallCount}\n`;
         if (s.ttfbMs > 0) {
           response += `TTFB: ${s.ttfbMs}ms\n`;
         }
         response += `\n`;
       }

       // Today
       response += `*Today*\n`;
       response += `Input: ${summary.today.inputTokens.toLocaleString()} tokens\n`;
       response += `Output: ${summary.today.outputTokens.toLocaleString()} tokens\n`;
       response += `Sessions: ${summary.today.totalSessions} | Turns: ${summary.today.totalTurns}\n`;
       response += `\n`;

       // Cumulative
       response += `*All Time*\n`;
       response += `Input: ${summary.cumulative.totalInputTokens.toLocaleString()} tokens\n`;
       response += `Output: ${summary.cumulative.totalOutputTokens.toLocaleString()} tokens\n`;
       response += `Sessions: ${summary.cumulative.totalSessions} | Turns: ${summary.cumulative.totalTurns}\n`;

       // Cost estimate
       if (summary.currentSession) {
         const cost = UsageTracker.estimateCost(
           summary.cumulative.totalInputTokens,
           summary.cumulative.totalOutputTokens,
           summary.currentSession.modelTier,
         );
         response += `\n*Estimated Total Cost*\n`;
         response += `$${cost.totalCost.toFixed(4)} (input: $${cost.inputCost.toFixed(4)}, output: $${cost.outputCost.toFixed(4)})`;
       }

       response += `\n\nDisplay modes: \`/usage off|tokens|full|cost\``;

       return { handled: true, response };
     }
     ```

   - Update the `/help` text to include `/usage`:
     ```
     *Usage*
     `/usage` - Show token usage summary
     `/usage off|tokens|full|cost` - Set usage display mode
     ```

   - Update `listCommands()` to include `/usage`.

   - Pass `usageTracker` in daemon.ts where `handleCommand` is called (both in `cycle()` and `processInboxItem()`):
     ```typescript
     const cmdResult = await handleCommand(item.message, {
       // ...existing fields...
       usageTracker: this.config.usageTracker,  // NEW
     });
     ```

2. **Add usage API endpoints in `api.ts`:**
   - Add `usageTracker` to the `createApiServer` options type.
   - Add endpoints:

   ```
   GET /api/usage/summary/:userId
   ```
   - Returns `UserUsageSummary` for the given user.
   - Response: `{ summary: UserUsageSummary }`

   ```
   GET /api/usage/daily/:userId?days=30
   ```
   - Returns daily usage for the last N days (default 30).
   - Response: `{ daily: DailyUsage[] }`

   ```
   GET /api/usage/overview
   ```
   - Returns aggregate usage across all users for the dashboard.
   - Scans `nexus:usage:cumulative:*` keys and aggregates.
   - Response: `{ totalInputTokens, totalOutputTokens, totalSessions, userCount }`

   All endpoints behind existing auth middleware.

3. **Create Settings dashboard at `livos/packages/ui/src/routes/settings/usage-dashboard.tsx`:**
   - Follow the existing settings page pattern (check `ai-config.tsx` or `integrations.tsx` for structure).
   - The dashboard should show:
     - **Overview cards:** Total tokens (input + output), total sessions, estimated cost. Use large number displays.
     - **Daily chart:** A simple bar chart or area chart showing daily token usage over the last 30 days. Use Recharts if already in the project, or create a simple SVG/CSS-based chart. Check if Recharts is in `livos/packages/ui/package.json` — if not, use a simple CSS bar chart (div widths proportional to values).
     - **Per-model breakdown:** Table or card showing usage broken down by model tier (haiku, sonnet, opus).
     - **Recent sessions:** List of recent sessions with timestamp, model, tokens, turns, TTFB.
   - Fetch data from `/api/usage/overview` and `/api/usage/daily/{userId}` using fetch with JWT auth.
   - For the user ID, use a fixed value like `'all'` for the overview, or the current user's chat ID if available.
   - Wire this component into the Settings navigation — add a "Usage" or "Token Usage" entry in the settings sidebar/menu.
  </action>
  <verify>
    - `npx tsc --noEmit` in `nexus/packages/core` passes.
    - `grep -n 'handleUsage' nexus/packages/core/src/commands.ts` shows the handler function.
    - `grep -n '/api/usage' nexus/packages/core/src/api.ts` shows API endpoint registrations.
    - The Settings dashboard file exists at `livos/packages/ui/src/routes/settings/usage-dashboard.tsx`.
    - `npx tsc --noEmit` in `livos/packages/ui` passes (or Vite build succeeds).
  </verify>
  <done>
    - /usage command shows current session, today, and all-time token usage (USAGE-03).
    - /usage cost shows estimated cost breakdown by model tier (USAGE-04).
    - /usage off|tokens|full controls usage display mode (CMD-03).
    - API endpoints serve usage data for the dashboard.
    - Settings page shows usage dashboard with daily charts (USAGE-05).
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors for both nexus/packages/core and livos/packages/ui.
2. UsageTracker records sessions with input/output tokens, turn count, tool calls, and TTFB.
3. /usage command returns formatted usage summary with tokens, turns, and cost estimate.
4. /usage off|tokens|full|cost sets the display mode.
5. TTFB is measured in SdkAgentRunner from task start to first text content.
6. API endpoints return usage data for dashboard consumption.
7. Settings page has a usage dashboard with daily token visualization.
</verification>

<success_criteria>
- Requirements USAGE-01 through USAGE-06 are fully addressed.
- CMD-03 (/usage display modes) is fully addressed.
- Every agent session automatically records usage metrics.
- /usage command shows session, daily, and cumulative data.
- Web UI Settings page shows a usage dashboard with daily charts.
- TTFB is tracked and displayed per agent request.
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p01-stability-security/v2.0-01-04-SUMMARY.md`
</output>
