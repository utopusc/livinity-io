---
phase: v2.0-p04-voice-pipeline
plan: 03
subsystem: voice
tags: [cartesia, tts, websocket, streaming, redis-pubsub, pcm-audio]

# Dependency graph
requires:
  - phase: v2.0-04-01
    provides: VoiceSession state machine, VoiceGateway, sendAudio(), config schema
  - phase: v2.0-04-02
    provides: DeepgramRelay STT integration, onTranscript callback, voiceConfig wiring
provides:
  - CartesiaRelay class for real-time TTS via WebSocket
  - VoiceSession TTS lifecycle (startTts, speakText, closeTtsRelay)
  - Daemon voice response routing via Redis pub/sub with sentence-boundary buffering
  - Voice source type in Intent union
affects: [v2.0-04-04-browser-audio, v2.0-p05-voice-ui]

# Tech tracking
tech-stack:
  added: [cartesia-tts-api]
  patterns: [redis-pubsub-decoupling, sentence-boundary-buffering, lazy-init-relay]

key-files:
  created:
    - nexus/packages/core/src/voice/cartesia-relay.ts
  modified:
    - nexus/packages/core/src/voice/voice-session.ts
    - nexus/packages/core/src/voice/index.ts
    - nexus/packages/core/src/daemon.ts
    - nexus/packages/core/src/index.ts
    - nexus/packages/core/src/router.ts

key-decisions:
  - "Redis pub/sub decouples daemon from VoiceGateway for voice response routing"
  - "Sentence-boundary buffering sends text to TTS at punctuation marks for natural speech"
  - "Lazy TTS init: CartesiaRelay created on first speakText() call, not on session creation"
  - "context_id per CartesiaRelay instance ensures voice continuity within a session"

patterns-established:
  - "Redis pub/sub for cross-component communication: daemon publishes to nexus:voice:response, VoiceGateway subscribes"
  - "Sentence buffering: accumulate text until .!? boundary or 100+ chars before sending to TTS"
  - "Lazy relay init: avoid creating expensive WebSocket connections until needed"

# Metrics
duration: 5min
completed: 2026-02-20
---

# Phase 4 Plan 03: Cartesia TTS Integration Summary

**CartesiaRelay streaming TTS via WebSocket with sentence-boundary buffering and Redis pub/sub voice response routing**

## Performance

- **Duration:** 5 min
- **Started:** 2026-02-20T23:56:53Z
- **Completed:** 2026-02-21T00:02:29Z
- **Tasks:** 2
- **Files modified:** 6

## Accomplishments
- CartesiaRelay class (284 lines) connects to Cartesia TTS WebSocket, sends text, receives base64 audio chunks
- VoiceSession manages TTS lifecycle with lazy initialization and state transitions processing->speaking->idle
- Daemon routes AI responses to active voice sessions via Redis pub/sub with sentence-boundary text buffering
- Voice source added to Intent union type for proper type safety

## Task Commits

Each task was committed atomically:

1. **Task 1: CartesiaRelay class -- streaming TTS WebSocket** - `0114ad8` (feat)
2. **Task 2: Wire TTS into VoiceSession + daemon response routing** - `54f8fa8` (feat)

## Files Created/Modified
- `nexus/packages/core/src/voice/cartesia-relay.ts` - CartesiaRelay class: WebSocket to Cartesia TTS, base64 audio decode, context_id continuity (284 lines)
- `nexus/packages/core/src/voice/voice-session.ts` - Added TTS integration: startTts(), speakText(), closeTtsRelay(), CartesiaRelay import and config fields
- `nexus/packages/core/src/voice/index.ts` - Added redisSub for voice response channel, getSession(), TTS config pass-through, pub/sub subscription
- `nexus/packages/core/src/daemon.ts` - Voice source in realtime list, agent event listener with sentence-boundary buffering, Redis publish to nexus:voice:response
- `nexus/packages/core/src/index.ts` - voiceRedisSub connection, pass to VoiceGateway, shutdown cleanup
- `nexus/packages/core/src/router.ts` - Added 'voice' to Intent source union type

## Decisions Made

| Decision | Context | Choice |
|----------|---------|--------|
| Redis pub/sub decoupling | How daemon sends voice responses to VoiceGateway | Publish to nexus:voice:response channel (daemon doesn't need direct VoiceGateway reference) |
| Sentence-boundary buffering | When to send text to TTS | Buffer until .!? followed by whitespace, or 100+ chars without punctuation |
| Lazy TTS init | When to create CartesiaRelay | On first speakText() call, not on session creation (saves resources for non-voice sessions) |
| context_id per session | Voice continuity | UUID generated once per CartesiaRelay, persists across all utterances in a session |
| Voice as realtime source | How to process voice inbox items | Added to realtime sources list for immediate processing (no polling wait) |

## Deviations from Plan

### Auto-fixed Issues

**1. [Rule 2 - Missing Critical] Added 'voice' to Intent source union type**
- **Found during:** Task 2
- **Issue:** VoiceGateway used `'voice' as any` cast because Intent.source type didn't include 'voice'
- **Fix:** Added 'voice' to the Intent source union in router.ts, removed the `as any` cast
- **Files modified:** nexus/packages/core/src/router.ts, nexus/packages/core/src/voice/index.ts
- **Verification:** TypeScript compiles without errors, no more type casts needed
- **Committed in:** 54f8fa8 (Task 2 commit)

---

**Total deviations:** 1 auto-fixed (1 missing critical)
**Impact on plan:** Type safety improvement, no scope creep.

## Issues Encountered
None

## Next Phase Readiness
Plan 04 (browser audio playback) can proceed immediately:
- CartesiaRelay streams PCM audio chunks (pcm_s16le, 24kHz) via VoiceSession.sendAudio()
- Browser receives binary WebSocket frames ready for AudioWorklet playback
- Control message `{ type: 'tts-done' }` signals end of TTS for UI state management
- State transitions are fully wired: processing -> speaking (first audio chunk) -> idle (TTS done)

---
*Phase: v2.0-p04-voice-pipeline*
*Completed: 2026-02-20*
