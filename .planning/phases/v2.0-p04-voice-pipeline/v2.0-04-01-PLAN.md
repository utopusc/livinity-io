---
phase: v2.0-p04-voice-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/voice/voice-session.ts
  - nexus/packages/core/src/voice/index.ts
  - nexus/packages/core/src/config/schema.ts
  - nexus/packages/core/src/index.ts
  - nexus/packages/core/src/api.ts
autonomous: true
user_setup:
  - service: deepgram
    why: "Speech-to-text transcription"
    env_vars:
      - name: DEEPGRAM_API_KEY
        source: "Deepgram Console -> Settings -> API Keys -> Create"
    dashboard_config: []
  - service: cartesia
    why: "Text-to-speech voice synthesis"
    env_vars:
      - name: CARTESIA_API_KEY
        source: "Cartesia Dashboard -> API Keys -> Create"
    dashboard_config: []

must_haves:
  truths:
    - "Browser can establish a WebSocket connection to /ws/voice with authentication"
    - "Server maintains a VoiceSession state machine (idle -> listening -> processing -> speaking -> idle)"
    - "WebSocket sends/receives binary audio frames (not base64-encoded text)"
    - "Connection stays alive via periodic pings even when no audio is flowing"
    - "Deepgram and Cartesia API keys can be stored in Redis config"
  artifacts:
    - path: "nexus/packages/core/src/voice/voice-session.ts"
      provides: "VoiceSession class with state machine, audio routing, keep-alive"
      min_lines: 100
    - path: "nexus/packages/core/src/voice/index.ts"
      provides: "VoiceGateway class handling /ws/voice upgrade and session lifecycle"
      min_lines: 80
    - path: "nexus/packages/core/src/config/schema.ts"
      provides: "VoiceConfigSchema with deepgramApiKey, cartesiaApiKey, voiceId fields"
      contains: "VoiceConfigSchema"
  key_links:
    - from: "nexus/packages/core/src/index.ts"
      to: "nexus/packages/core/src/voice/index.ts"
      via: "VoiceGateway instantiation and httpServer.on('upgrade') delegation"
      pattern: "VoiceGateway"
    - from: "nexus/packages/core/src/voice/index.ts"
      to: "nexus/packages/core/src/voice/voice-session.ts"
      via: "new VoiceSession() on authenticated connection"
      pattern: "new VoiceSession"
---

<objective>
Create the Voice WebSocket gateway — a /ws/voice binary endpoint with VoiceSession lifecycle, connection state machine, and keep-alive. This is the transport layer that all voice features build on.

Purpose: Establish the WebSocket plumbing for real-time bidirectional binary audio streaming between the browser and the server. Without this, no voice audio can flow.

Output: VoiceSession class, VoiceGateway class, voice config schema additions, wired into nexus-core startup.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key reference files:
@nexus/packages/core/src/ws-gateway.ts — Existing JSON-RPC WebSocket gateway (pattern for auth, upgrade handling, heartbeat)
@nexus/packages/core/src/index.ts — Server startup, httpServer creation, existing WsGateway wiring
@nexus/packages/core/src/config/schema.ts — NexusConfig schema (add voice config here)
@nexus/packages/core/src/auth.ts — verifyApiKey and verifyJwt used for WebSocket auth
@nexus/packages/core/src/api.ts — setupWsGateway function pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Voice config schema + VoiceSession state machine</name>
  <files>
    nexus/packages/core/src/config/schema.ts
    nexus/packages/core/src/voice/voice-session.ts
  </files>
  <action>
1. **Add VoiceConfigSchema to config/schema.ts:**
   - Add a new `VoiceConfigSchema` after `BrowserConfigSchema`:
     ```typescript
     export const VoiceConfigSchema = z.object({
       enabled: z.boolean().default(false),
       deepgramApiKey: z.string().optional(),
       cartesiaApiKey: z.string().optional(),
       cartesiaVoiceId: z.string().default('a0e99841-438c-4a64-b679-ae501e7d6091'), // Cartesia "Barbershop Man" default
       cartesiaModelId: z.string().default('sonic-2'),
       sttLanguage: z.string().default('en'),
       sttModel: z.string().default('nova-3'),
     }).strict().optional();
     ```
   - Add `voice: VoiceConfigSchema` to the `NexusConfigSchema` object (after `browser`).
   - Export `VoiceConfig` type: `export type VoiceConfig = z.infer<typeof VoiceConfigSchema>;`
   - Add default to `DEFAULT_NEXUS_CONFIG`:
     ```typescript
     voice: {
       enabled: false,
       cartesiaVoiceId: 'a0e99841-438c-4a64-b679-ae501e7d6091',
       cartesiaModelId: 'sonic-2',
       sttLanguage: 'en',
       sttModel: 'nova-3',
     },
     ```

2. **Create nexus/packages/core/src/voice/voice-session.ts:**
   - Create the `voice/` directory under `nexus/packages/core/src/`.
   - Define `VoiceState` type: `'idle' | 'listening' | 'processing' | 'speaking'`
   - Define `VoiceSessionEvents` interface for typed EventEmitter:
     - `'audio-in'`: `(chunk: Buffer) => void` — raw audio from browser
     - `'transcript'`: `(text: string, isFinal: boolean) => void` — STT result
     - `'audio-out'`: `(chunk: Buffer) => void` — TTS audio for browser
     - `'state-change'`: `(from: VoiceState, to: VoiceState) => void`
     - `'error'`: `(error: Error) => void`
     - `'close'`: `() => void`
   - Implement `VoiceSession` class extending `EventEmitter`:
     - Constructor takes `{ ws: WebSocket, sessionId: string, redis: Redis }`.
     - Private fields: `state: VoiceState = 'idle'`, `ws: WebSocket`, `sessionId: string`, `redis: Redis`, `lastActivity: number`, `pingInterval: NodeJS.Timeout | null`.
     - `setState(newState: VoiceState)`: validates transitions, emits `'state-change'`.
     - Valid transitions: idle->listening, listening->processing, processing->speaking, speaking->idle, any->idle (reset).
     - `handleBinaryMessage(data: Buffer)`: When state is 'listening', emit `'audio-in'` with the data. Update `lastActivity`.
     - `handleTextMessage(data: string)`: Parse JSON control messages. Support:
       - `{ type: 'start-listening' }` — transition to 'listening'
       - `{ type: 'stop-listening' }` — transition from 'listening' to 'processing'
       - `{ type: 'cancel' }` — reset to 'idle'
     - `sendAudio(chunk: Buffer)`: If ws is open, send binary frame. If state is not 'speaking', transition to 'speaking'.
     - `sendControl(msg: object)`: Send JSON text frame (for state updates, transcript text, latency data).
     - `startKeepAlive(intervalMs = 25000)`: Set up ping interval. Clear on close.
     - `close()`: Clear intervals, close ws if open, emit 'close', remove all listeners.
     - `getState()`: Returns current state.
     - `getSessionId()`: Returns sessionId.
   - Log state transitions at debug level using the project logger.
  </action>
  <verify>
    - `npx tsc --noEmit` in nexus/packages/core passes (no type errors).
    - voice-session.ts exports VoiceSession class and VoiceState type.
    - config/schema.ts includes voice field in NexusConfigSchema.
  </verify>
  <done>
    VoiceSession class exists with state machine (idle/listening/processing/speaking), binary audio routing, JSON control messages, and keep-alive. VoiceConfig added to NexusConfigSchema with Deepgram/Cartesia API key fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: VoiceGateway + wire into nexus-core startup</name>
  <files>
    nexus/packages/core/src/voice/index.ts
    nexus/packages/core/src/index.ts
    nexus/packages/core/src/api.ts
  </files>
  <action>
1. **Create nexus/packages/core/src/voice/index.ts (VoiceGateway class):**
   - Import `WebSocketServer, WebSocket` from 'ws', `Server, IncomingMessage` from 'http', `Duplex` from 'stream'.
   - Import `VoiceSession` from `./voice-session.js`.
   - Import `verifyApiKey, verifyJwt` from `../auth.js`.
   - Import `logger` from `../logger.js`.
   - Import `Redis` from 'ioredis', `randomUUID` from 'node:crypto'.

   - Define `VoiceGatewayDeps` interface:
     ```typescript
     export interface VoiceGatewayDeps {
       redis: Redis;
       daemon: Daemon;  // For addToInbox later
     }
     ```
   - Implement `VoiceGateway` class:
     - Constructor takes `(server: Server, deps: VoiceGatewayDeps)`.
     - Create `WebSocketServer` with `noServer: true`.
     - Register on `server.on('upgrade')` — check if path is `/ws/voice`.
       - **IMPORTANT**: The existing WsGateway already listens on `server.on('upgrade')` for `/ws/agent`. Both can coexist because each checks the pathname and ignores non-matching paths with `return`.
       - Authenticate using same pattern as WsGateway: check `X-Api-Key` header via `verifyApiKey()` or `token` query param via `verifyJwt()`.
       - On auth success: `this.wss.handleUpgrade(req, socket, head, ws => ...)`.
       - On auth fail: `socket.write('HTTP/1.1 401 Unauthorized\r\n\r\n'); socket.destroy();`.
     - On `'connection'`: Create a new `VoiceSession` with a random UUID, store in `Map<string, VoiceSession>`.
     - Wire ws events:
       - `ws.on('message', (data, isBinary) => ...)`: If binary, call `session.handleBinaryMessage(data as Buffer)`. If text, call `session.handleTextMessage(data.toString())`.
       - `ws.on('close', () => ...)`: Call `session.close()`, remove from map.
       - `ws.on('error', (err) => ...)`: Log error, close session.
     - Send initial control message on connect: `{ type: 'connected', sessionId }`.
     - Start keep-alive on the session.
     - `getSessions()`: Returns active session count.
     - `stop()`: Close all sessions, close WSS.

   - Export `VoiceGateway` and re-export from this file.

2. **Wire VoiceGateway into nexus-core startup (index.ts):**
   - Import `VoiceGateway` from `'./voice/index.js'`.
   - After the existing `wsGateway` creation (line ~473), instantiate VoiceGateway:
     ```typescript
     // Voice WebSocket gateway for real-time voice pipeline
     const voiceGateway = new VoiceGateway(httpServer, { redis, daemon });
     logger.info('VoiceGateway initialized');
     ```
   - In the `shutdown` function, add `voiceGateway.stop()` before `wsGateway.stop()`.
   - Pass voiceGateway to `daemon` if needed for future wiring (optional — can defer to Plan 02/03).

3. **Update api.ts ApiDeps (optional):**
   - Only if needed for future REST endpoints (e.g., GET /api/voice/status). For now, skip — the voice gateway is standalone on the httpServer.
  </action>
  <verify>
    - `npx tsc --noEmit` in nexus/packages/core passes.
    - `grep -r "VoiceGateway" nexus/packages/core/src/index.ts` shows import and instantiation.
    - The /ws/voice path is handled in VoiceGateway, /ws/agent continues to work in WsGateway (no conflict).
  </verify>
  <done>
    VoiceGateway is instantiated on server startup, listening on /ws/voice with JWT/API key auth. VoiceSessions are created per connection with state machine, binary audio routing, and keep-alive. Existing /ws/agent WebSocket gateway is unaffected.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd nexus/packages/core && npx tsc --noEmit` — zero errors.
2. VoiceConfigSchema is part of NexusConfigSchema: `grep "voice:" nexus/packages/core/src/config/schema.ts` shows the field.
3. VoiceGateway handles /ws/voice upgrade: `grep "/ws/voice" nexus/packages/core/src/voice/index.ts` shows path check.
4. VoiceSession has all 4 states: `grep "VoiceState" nexus/packages/core/src/voice/voice-session.ts` shows idle|listening|processing|speaking.
5. Startup wiring: `grep "VoiceGateway" nexus/packages/core/src/index.ts` shows instantiation and shutdown.
</verification>

<success_criteria>
- VoiceSession state machine compiles and handles state transitions correctly.
- VoiceGateway authenticates WebSocket upgrades on /ws/voice using existing auth module.
- Voice config schema with Deepgram/Cartesia API key fields is part of NexusConfig.
- nexus-core startup creates VoiceGateway and shuts it down cleanly.
- Existing WsGateway on /ws/agent is completely unaffected.
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p04-voice-pipeline/v2.0-04-01-SUMMARY.md`
</output>
