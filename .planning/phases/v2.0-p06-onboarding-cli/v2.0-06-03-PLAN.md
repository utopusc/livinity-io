---
phase: v2.0-p06-onboarding-cli
plan: 03
type: execute
wave: 3
depends_on: ["v2.0-06-02"]
files_modified:
  - nexus/packages/cli/src/commands/onboard.ts
  - nexus/packages/cli/src/commands/setup.ts
  - nexus/packages/cli/src/lib/pm2.ts
  - nexus/packages/cli/src/lib/rollback.ts
  - nexus/packages/cli/src/index.ts
autonomous: true

must_haves:
  truths:
    - "After onboard completes, PM2 services are started and `livinity status` shows green indicators"
    - "Non-interactive mode (`livinity onboard --config setup.json`) completes full installation without prompts"
    - "If installation fails partway through, completed steps are rolled back leaving the server clean"
    - "PM2 ecosystem file is generated with correct paths from .env configuration"
    - "Health verification checks that all services respond on their expected ports"
  artifacts:
    - path: "nexus/packages/cli/src/commands/setup.ts"
      provides: "Service setup command that installs deps, builds, starts PM2"
      contains: "setup"
    - path: "nexus/packages/cli/src/lib/pm2.ts"
      provides: "PM2 ecosystem generation and service management"
      contains: "generateEcosystem"
    - path: "nexus/packages/cli/src/lib/rollback.ts"
      provides: "Rollback stack for partial failure cleanup"
      contains: "RollbackStack"
  key_links:
    - from: "nexus/packages/cli/src/commands/onboard.ts"
      to: "nexus/packages/cli/src/commands/setup.ts"
      via: "import and call after .env write"
      pattern: "runSetup"
    - from: "nexus/packages/cli/src/commands/setup.ts"
      to: "nexus/packages/cli/src/lib/pm2.ts"
      via: "import generateEcosystem and startServices"
      pattern: "generateEcosystem"
    - from: "nexus/packages/cli/src/commands/setup.ts"
      to: "nexus/packages/cli/src/lib/rollback.ts"
      via: "import RollbackStack"
      pattern: "RollbackStack"
    - from: "nexus/packages/cli/src/commands/onboard.ts"
      to: "--config option"
      via: "commander option parsing"
      pattern: "\\.option.*--config"
---

<objective>
Add PM2 service setup, health verification, non-interactive mode (--config setup.json), and partial rollback on failure to the onboarding CLI.

Purpose: This completes the onboarding experience by taking the .env configuration from Plan 02 and actually setting up the server: installing dependencies, building packages, generating PM2 ecosystem config, starting services, and verifying health. The rollback mechanism ensures that if anything fails mid-install, the server is left clean. Non-interactive mode allows automated deployments.

Output: A complete `livinity onboard` flow that goes from fresh server to running LivOS, plus a standalone `livinity setup` command for re-running the service setup portion.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v2.0-p06-onboarding-cli/v2.0-06-01-SUMMARY.md
@.planning/phases/v2.0-p06-onboarding-cli/v2.0-06-02-SUMMARY.md

Key codebase references:
@livos/ecosystem.config.cjs — existing PM2 config for livos services
@nexus/deploy/ecosystem.config.cjs — existing PM2 config for nexus services
@livos/install.sh — existing bash installer (reference for build steps and service setup)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PM2 ecosystem generator, rollback stack, and setup command</name>
  <files>
    nexus/packages/cli/src/lib/pm2.ts
    nexus/packages/cli/src/lib/rollback.ts
    nexus/packages/cli/src/commands/setup.ts
  </files>
  <action>
    **src/lib/pm2.ts:**

    Export `interface ServiceConfig { livosBaseDir: string; nexusBaseDir: string; logsDir: string }`

    Export `generateEcosystemConfig(config: ServiceConfig): string`
    - Returns a JavaScript string for ecosystem.config.cjs containing:
      - `livos` service: interpreter tsx, script `${livosBaseDir}/packages/livinityd/source/cli.ts`, args `--data-directory ${livosBaseDir}/data --port 8080`, env NODE_ENV=production
      - `nexus-core`: script `packages/core/dist/index.js`, cwd nexusBaseDir, env NODE_ENV=production + DAEMON_INTERVAL_MS=30000
      - `nexus-worker`: script `packages/worker/dist/index.js`, cwd nexusBaseDir
      - `nexus-memory`: interpreter from `${nexusBaseDir}/packages/memory/venv/bin/python3` (if exists) or system python3, script `packages/memory/src/server.py`, env MEMORY_PORT=3300
      - `nexus-mcp`: script `packages/mcp-server/dist/index.js`, cwd nexusBaseDir, env MCP_PORT=3100
    - All services: max_memory_restart 500M, exp_backoff_restart_delay 100, log files in logsDir
    - Add EnvironmentFile reference comment noting .env is loaded via dotenv in each service

    Export `writeEcosystemFile(filePath: string, config: ServiceConfig): void`
    - Calls generateEcosystemConfig and writes to filePath

    Export `async startServices(ecosystemPath: string): Promise<{ started: string[]; failed: string[] }>`
    - Run `pm2 start ${ecosystemPath}` via execSync
    - Parse `pm2 jlist` to verify which services started
    - Return lists of started and failed service names

    Export `async stopServices(): Promise<void>`
    - Run `pm2 delete all` to stop all managed services

    Export `async verifyHealth(ports: { api: number; mcp: number; memory: number; livos: number }): Promise<{ service: string; healthy: boolean; port: number }[]>`
    - For each port, attempt a TCP connection (net.createConnection) with 5s timeout
    - Return health status for each service
    - Services: LivOS (8080), Nexus API (apiPort), MCP (mcpPort), Memory (memoryPort)

    **src/lib/rollback.ts:**

    Export class `RollbackStack`:
    - Private `steps: Array<{ name: string; undo: () => void | Promise<void> }>` stack
    - `push(name: string, undo: () => void | Promise<void>): void` — add a rollback step
    - `async rollback(): Promise<void>` — execute all undo functions in LIFO order, logging each step
    - Each undo should be wrapped in try/catch — if an undo fails, log warning but continue
    - Example usage:
      ```
      rollback.push('created .env', () => fs.unlinkSync(envPath));
      rollback.push('started PM2', () => execSync('pm2 delete all'));
      ```

    **src/commands/setup.ts:**

    Export `registerSetupCommand(program: Command)` for standalone `livinity setup` command.
    Also export `async runSetup(options: { livosBaseDir: string; nexusBaseDir: string; rollback: RollbackStack }): Promise<void>` for use by onboard command.

    The setup flow:
    1. **Create directories** — logs, data dirs (add to rollback)
    2. **Install LivOS deps** — `cd ${livosBaseDir} && pnpm install` (spinner)
    3. **Build @livos/config** — `cd ${livosBaseDir}/packages/config && npx tsc` (spinner)
    4. **Build UI** — `cd ${livosBaseDir}/packages/ui && npm run build` (spinner)
    5. **Symlink UI dist** — `ln -sf ${livosBaseDir}/packages/ui/dist ${livosBaseDir}/packages/livinityd/ui`
    6. **Install Nexus deps** — `cd ${nexusBaseDir} && npm install` (spinner)
    7. **Build Nexus core** — `cd ${nexusBaseDir}/packages/core && npx tsc` (spinner)
    8. **Build Nexus worker** — `cd ${nexusBaseDir}/packages/worker && npx tsc` (spinner, optional)
    9. **Build Nexus MCP** — `cd ${nexusBaseDir}/packages/mcp-server && npx tsc` (spinner, optional)
    10. **Python venv** — if memory/src/requirements.txt exists, create venv and pip install
    11. **Symlink .env** — `ln -sf ${livosBaseDir}/.env ${nexusBaseDir}/.env`
    12. **Generate PM2 ecosystem** — write ecosystem.config.cjs to livosBaseDir
    13. **Start PM2 services** — `pm2 start ecosystem.config.cjs` (add stop to rollback)
    14. **PM2 startup** — `pm2 startup` + `pm2 save` for reboot persistence
    15. **Health verification** — check ports, report results

    Each step that creates state (files, services) pushes onto the RollbackStack. If any step throws, the setup calls rollback.rollback() and rethrows.

    Use @clack/prompts spinners for long-running operations (install, build). Use log.step() for quick operations.

    The standalone `livinity setup` command reads .env from LIVOS_BASE_DIR (default /opt/livos) to determine paths, then calls runSetup().
  </action>
  <verify>
    ```
    cd nexus/packages/cli && npx tsc --noEmit
    ```
    TypeScript compiles. PM2 ecosystem generation produces valid JS. RollbackStack LIFO order verified by code inspection.
  </verify>
  <done>PM2 ecosystem generator creates correct service config. RollbackStack provides LIFO cleanup. Setup command handles full build + service startup with rollback on failure.</done>
</task>

<task type="auto">
  <name>Task 2: Add non-interactive mode and wire setup into onboard command</name>
  <files>
    nexus/packages/cli/src/commands/onboard.ts
    nexus/packages/cli/src/lib/config-file.ts
    nexus/packages/cli/src/index.ts
  </files>
  <action>
    **src/lib/config-file.ts:**

    Export interface `SetupJsonConfig`:
    ```typescript
    interface SetupJsonConfig {
      domain: string;
      useHttps?: boolean;
      telegram?: {
        botToken: string;
        dmPolicy?: 'open' | 'pairing';
      };
      discord?: {
        botToken: string;
        applicationId: string;
      };
      voice?: {
        deepgramApiKey: string;
        cartesiaApiKey: string;
      };
      gmail?: {
        clientId: string;
        clientSecret: string;
      };
      paths?: {
        livosBaseDir?: string;
        nexusBaseDir?: string;
      };
      ports?: {
        api?: number;
        mcp?: number;
        memory?: number;
      };
    }
    ```

    Export `loadConfigFile(filePath: string): SetupJsonConfig`
    - Read JSON file, validate with basic checks (domain required)
    - Throw descriptive error if file not found or invalid

    Export `configFileToEnvConfig(config: SetupJsonConfig): EnvConfig`
    - Convert SetupJsonConfig to EnvConfig (from env-writer.ts)
    - Auto-generate secrets (jwtSecret, apiKey, redisPassword)
    - Apply defaults for missing optional fields

    **Update src/commands/onboard.ts:**

    Add `--config <path>` option to the onboard command:
    ```typescript
    .option('-c, --config <path>', 'Path to setup.json for non-interactive mode')
    ```

    When `--config` is provided:
    - Skip all interactive prompts
    - Load config file via loadConfigFile()
    - Convert to EnvConfig via configFileToEnvConfig()
    - Generate secrets
    - Write .env
    - Call runSetup() from setup.ts
    - Show final health status

    When running interactively (no --config):
    - After the existing wizard writes .env (from Plan 02)
    - Ask: `@clack/prompts.confirm({ message: 'Install dependencies and start services now?' })`
    - If yes: create RollbackStack and call runSetup()
    - If no: show message "Run `livinity setup` later to complete installation"
    - Show final health status and completion banner

    **Update src/index.ts:**
    - Register setupCommand via `registerSetupCommand(program)`
    - Ensure onboard command properly imports and uses runSetup

    **Error handling for onboard command:**
    - Wrap the entire flow in try/catch
    - On error: call rollback.rollback() if available
    - Show clear error message with `@clack/prompts.log.error()`
    - Exit with code 1

    **Final completion banner (both interactive and non-interactive):**
    - Show `livinity status` summary inline (call status check)
    - Display access URLs: `http://{domain}:8080` (or https if configured)
    - Show next steps: "Open Settings to configure additional features"
  </action>
  <verify>
    ```
    cd nexus/packages/cli && npx tsc --noEmit
    ```
    TypeScript compiles. The onboard command handles both interactive and --config modes. Rollback is wired into the error path.
  </verify>
  <done>Non-interactive mode reads setup.json and completes full installation without prompts. Interactive mode offers to run setup after writing .env. Rollback cleans up on partial failure. Final banner shows access URLs and service health.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in nexus/packages/cli
2. PM2 ecosystem config includes all 5 services with correct paths and settings
3. RollbackStack executes undos in LIFO order on failure
4. Non-interactive mode: `livinity onboard --config setup.json` works without prompts
5. Health verification checks TCP connectivity on service ports
6. Setup command: install deps, build, start PM2, verify health
7. Partial failure triggers rollback (files removed, services stopped)
8. Requirements covered: CLI-06 (PM2 setup), CLI-07 (status), CLI-08 (non-interactive), CLI-09 (rollback)
</verification>

<success_criteria>
- `livinity onboard` completes full installation end-to-end (config -> deps -> build -> PM2 -> health check)
- `livinity onboard --config setup.json` runs non-interactively
- `livinity setup` can be run standalone to (re)install services
- PM2 ecosystem generated with correct paths for all 5 services
- Partial failure triggers rollback leaving server clean
- Health verification checks all service ports
- Final banner shows access URL and service status
</success_criteria>

<output>
After completion, create `.planning/phases/v2.0-p06-onboarding-cli/v2.0-06-03-SUMMARY.md`
</output>
