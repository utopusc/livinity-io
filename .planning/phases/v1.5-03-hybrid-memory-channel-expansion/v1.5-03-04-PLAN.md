---
phase: v1.5-03-hybrid-memory-channel-expansion
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/channels/matrix.ts
  - nexus/packages/core/src/channels/index.ts
  - nexus/packages/core/package.json
autonomous: true

must_haves:
  truths:
    - "MatrixProvider implements ChannelProvider interface using matrix-js-sdk"
    - "ChannelManager registers MatrixProvider and can route messages to Matrix"
    - "Matrix homeserver URL, access token, and room ID are read from Redis config"
    - "matrix-js-sdk is added to package.json dependencies"
  artifacts:
    - path: "nexus/packages/core/src/channels/matrix.ts"
      provides: "MatrixProvider implementation"
      contains: "class MatrixProvider"
    - path: "nexus/packages/core/src/channels/index.ts"
      provides: "MatrixProvider registered in ChannelManager"
      contains: "MatrixProvider"
    - path: "nexus/packages/core/package.json"
      provides: "matrix-js-sdk dependency"
      contains: "matrix-js-sdk"
  key_links:
    - from: "nexus/packages/core/src/channels/matrix.ts"
      to: "matrix-js-sdk"
      via: "createClient + startClient"
      pattern: "createClient"
    - from: "nexus/packages/core/src/channels/index.ts"
      to: "nexus/packages/core/src/channels/matrix.ts"
      via: "import and register"
      pattern: "providers.set.*matrix"
---

<objective>
Implement MatrixProvider using matrix-js-sdk, register it in ChannelManager, and add the dependency.

Purpose: Users should be able to connect a Matrix room and interact with the AI through Matrix messages.

Output: Working MatrixProvider following the established channel pattern.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@nexus/packages/core/src/channels/types.ts
@nexus/packages/core/src/channels/index.ts
@nexus/packages/core/src/channels/telegram.ts
@nexus/packages/core/src/channels/slack.ts
@nexus/packages/core/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install matrix-js-sdk dependency</name>
  <files>nexus/packages/core/package.json</files>
  <action>
Run `cd nexus/packages/core && npm install matrix-js-sdk` to add the matrix-js-sdk dependency.

After install, verify it's in package.json dependencies. The version should be ^35.0.0 or latest available.

Also check if `@types/matrix-js-sdk` is needed — matrix-js-sdk includes its own TypeScript types, so no separate @types package should be necessary. Verify by checking if the installed package has a `.d.ts` or `types` field in its package.json.
  </action>
  <verify>
Grep package.json for `matrix-js-sdk` to confirm it's listed. Run `cd nexus/packages/core && npx tsc --noEmit 2>&1 | head -5` to check for any type resolution issues.
  </verify>
  <done>
matrix-js-sdk is installed as a dependency of @nexus/core.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MatrixProvider and register in ChannelManager</name>
  <files>nexus/packages/core/src/channels/matrix.ts, nexus/packages/core/src/channels/index.ts, nexus/packages/core/src/daemon.ts, nexus/packages/core/src/index.ts</files>
  <action>
**Create `nexus/packages/core/src/channels/matrix.ts`:**

Follow the same pattern as TelegramProvider and SlackProvider. Matrix requires:
- A homeserver URL (e.g., https://matrix.org)
- An access token (obtained from a Matrix client or via password login)
- A room ID to listen in (e.g., !abc123:matrix.org)

```typescript
import * as sdk from 'matrix-js-sdk';
import type Redis from 'ioredis';
import { logger } from '../logger.js';
import type {
  ChannelProvider,
  ChannelConfig,
  ChannelStatus,
  IncomingMessage,
} from './types.js';
import { chunkText, CHANNEL_META, getRedisPrefix } from './types.js';

export class MatrixProvider implements ChannelProvider {
  readonly id = 'matrix' as const;
  readonly name = 'Matrix';

  private redis: Redis | null = null;
  private client: sdk.MatrixClient | null = null;
  private config: ChannelConfig = { enabled: false };
  private status: ChannelStatus = { enabled: false, connected: false };
  private messageHandler: ((msg: IncomingMessage) => Promise<void>) | null = null;
  private botUserId: string = '';

  async init(redis: Redis): Promise<void> {
    this.redis = redis;
    await this.loadConfig();
  }

  private async loadConfig(): Promise<void> {
    if (!this.redis) return;
    const configStr = await this.redis.get(`${getRedisPrefix(this.id)}:config`);
    if (configStr) {
      try {
        this.config = JSON.parse(configStr);
      } catch {
        logger.warn('MatrixProvider: invalid config in Redis');
      }
    }
  }

  async updateConfig(config: ChannelConfig): Promise<void> {
    this.config = { ...this.config, ...config };
    if (this.redis) {
      await this.redis.set(`${getRedisPrefix(this.id)}:config`, JSON.stringify(this.config));
    }
    if (config.token && config.homeserverUrl && this.config.enabled) {
      await this.disconnect();
      await this.connect();
    } else if (!this.config.enabled) {
      await this.disconnect();
    }
  }

  async connect(): Promise<void> {
    if (!this.config.enabled || !this.config.token || !this.config.homeserverUrl) {
      this.status = { enabled: false, connected: false, error: 'Not configured (need homeserver URL + access token)' };
      await this.saveStatus();
      return;
    }

    try {
      this.client = sdk.createClient({
        baseUrl: this.config.homeserverUrl,
        accessToken: this.config.token,
        userId: '', // Will be populated after whoami
      });

      // Get bot user ID
      const whoami = await this.client.whoami();
      this.botUserId = whoami.user_id;

      // Listen for room messages
      this.client.on(sdk.RoomEvent.Timeline, (event, room, toStartOfTimeline) => {
        if (toStartOfTimeline) return; // Skip historical messages
        if (event.getType() !== 'm.room.message') return;
        if (event.getSender() === this.botUserId) return; // Skip own messages

        const content = event.getContent();
        if (!content.body || content.msgtype !== 'm.text') return;

        // Only process messages from configured room(s)
        const roomId = room?.roomId || event.getRoomId();
        if (this.config.roomId && roomId !== this.config.roomId) return;

        if (!this.messageHandler) return;

        const incoming: IncomingMessage = {
          channel: 'matrix',
          chatId: roomId || '',
          userId: event.getSender() || 'unknown',
          userName: event.getSender()?.split(':')[0].replace('@', ''),
          text: content.body,
          timestamp: event.getTs() || Date.now(),
          isGroup: true, // Matrix rooms are always "group" context
        };

        // Save last chat ID for heartbeat delivery
        if (this.redis && roomId) {
          this.redis.set(`nexus:matrix:last_chat_id`, roomId).catch(() => {});
        }

        this.messageHandler(incoming).catch(err => {
          logger.error('MatrixProvider: message handler error', { error: err.message });
        });
      });

      // Start syncing — use limited initial sync to avoid processing old messages
      await this.client.startClient({ initialSyncLimit: 0 });

      this.status = {
        enabled: true,
        connected: true,
        botName: this.botUserId.split(':')[0].replace('@', ''),
        botId: this.botUserId,
        lastConnect: new Date().toISOString(),
      };

      await this.saveStatus();
      logger.info('MatrixProvider: connected', { userId: this.botUserId, homeserver: this.config.homeserverUrl });
    } catch (err: any) {
      this.status = {
        enabled: true,
        connected: false,
        error: err.message || 'Connection failed',
      };
      await this.saveStatus();
      logger.error('MatrixProvider: connection failed', { error: err.message });
    }
  }

  async disconnect(): Promise<void> {
    if (this.client) {
      try {
        this.client.stopClient();
      } catch {
        // Ignore stop errors
      }
      this.client = null;
    }
    this.status = { ...this.status, connected: false };
    await this.saveStatus();
  }

  async getStatus(): Promise<ChannelStatus> {
    return this.status;
  }

  async sendMessage(chatId: string, text: string, _replyTo?: string): Promise<boolean> {
    if (!this.client || !this.status.connected) return false;

    try {
      const chunks = chunkText(text, CHANNEL_META.matrix.textLimit);
      for (const chunk of chunks) {
        await this.client.sendTextMessage(chatId, chunk);
      }
      return true;
    } catch (err: any) {
      logger.error('MatrixProvider: send failed', { error: err.message, chatId });
      return false;
    }
  }

  onMessage(handler: (msg: IncomingMessage) => Promise<void>): void {
    this.messageHandler = handler;
  }

  async testConnection(): Promise<{ ok: boolean; error?: string; botName?: string }> {
    if (!this.config.token || !this.config.homeserverUrl) {
      return { ok: false, error: 'Homeserver URL and access token required' };
    }

    try {
      const testClient = sdk.createClient({
        baseUrl: this.config.homeserverUrl,
        accessToken: this.config.token,
        userId: '',
      });
      const whoami = await testClient.whoami();
      testClient.stopClient();
      return {
        ok: true,
        botName: whoami.user_id.split(':')[0].replace('@', ''),
      };
    } catch (err: any) {
      return { ok: false, error: err.message || 'Test failed' };
    }
  }

  private async saveStatus(): Promise<void> {
    if (!this.redis) return;
    try {
      await this.redis.set(`${getRedisPrefix(this.id)}:status`, JSON.stringify(this.status));
    } catch {
      // Ignore Redis errors during status save
    }
  }
}
```

**Important notes on matrix-js-sdk:**
- The import `import * as sdk from 'matrix-js-sdk'` is the standard ESM import pattern.
- `createClient`, `RoomEvent`, `MatrixClient` are the main exports.
- `startClient({ initialSyncLimit: 0 })` prevents processing old messages on connect.
- `client.whoami()` returns `{ user_id: string }`.
- `client.sendTextMessage(roomId, text)` sends a plain text message.
- The `RoomEvent.Timeline` event fires for all timeline events; filter by `m.room.message` type and `m.text` msgtype.
- If `matrix-js-sdk` has ESM issues, the import may need to be `import sdk from 'matrix-js-sdk'` (default) or use dynamic import. Check what works during implementation. Try `import * as sdk from 'matrix-js-sdk'` first, fall back to `import sdk from 'matrix-js-sdk'` if that fails.

**Update `nexus/packages/core/src/channels/index.ts`:**

1. Add import: `import { MatrixProvider } from './matrix.js';`
2. In the ChannelManager constructor, add: `this.providers.set('matrix', new MatrixProvider());`

**Update `nexus/packages/core/src/daemon.ts`:**

Update hardcoded channel lists to include 'matrix':

1. In `sendChannelResponse`: Change to `const channelSources = ['telegram', 'discord', 'slack', 'matrix'] as const;`
2. In the action routing section: Change to `const channelSources = ['telegram', 'discord', 'slack', 'matrix'] as const;`

**Update `nexus/packages/core/src/index.ts`:**

In the heartbeat delivery logic, update channel lists:
- Change `if (target === 'telegram' || target === 'discord' || target === 'slack')` to `if (['telegram', 'discord', 'slack', 'matrix'].includes(target))`
- Change `for (const channelId of ['telegram', 'discord', 'slack'] as const)` to `for (const channelId of ['telegram', 'discord', 'slack', 'matrix'] as const)`
  </action>
  <verify>
Run `cd nexus/packages/core && npx tsc --noEmit` to verify TypeScript compiles. Grep for `class MatrixProvider` in matrix.ts, `MatrixProvider` in channels/index.ts, and `'matrix'` in daemon.ts.
  </verify>
  <done>
MatrixProvider is implemented using matrix-js-sdk with Socket Mode-like sync, registered in ChannelManager, and all hardcoded channel lists in daemon.ts and index.ts include 'matrix'. The provider handles room messages, sends text responses, filters by configured room, and stores last_chat_id for heartbeat delivery.
  </done>
</task>

</tasks>

<verification>
1. `cd nexus/packages/core && npx tsc --noEmit` — zero errors
2. Grep confirms `matrix-js-sdk` in package.json
3. Grep confirms `class MatrixProvider` in matrix.ts
4. Grep confirms `MatrixProvider` imported and registered in channels/index.ts
5. Grep confirms `'matrix'` in daemon.ts sendChannelResponse
6. Grep confirms `'matrix'` in index.ts heartbeat delivery
</verification>

<success_criteria>
- MatrixProvider implements full ChannelProvider interface
- matrix-js-sdk installed as dependency
- Messages from configured Matrix room are routed through standard inbox pipeline
- Responses are sent back to the correct Matrix room
- ChannelManager registers and manages MatrixProvider lifecycle
- Hardcoded channel lists updated across daemon.ts and index.ts
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-03-hybrid-memory-channel-expansion/v1.5-03-04-SUMMARY.md`
</output>
