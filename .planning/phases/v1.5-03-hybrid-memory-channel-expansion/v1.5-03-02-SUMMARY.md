---
phase: v1.5-03-hybrid-memory-channel-expansion
plan: 02
subsystem: memory
tags: [memory, context-injection, token-budget, agent, system-prompt]

dependency-graph:
  requires:
    - v1.5-03-01 (memory extraction pipeline, dedup, time-decay search)
  provides:
    - /context endpoint for token-budgeted memory assembly
    - Automatic memory context injection into agent system prompts
    - Per-user memory isolation for channel conversations
  affects:
    - v1.5-03-05 (Signal channel will automatically get memory context)
    - v1.5-04+ (WebSocket gateway will benefit from memory-enriched agent responses)

tech-stack:
  added: []
  patterns:
    - Greedy token-budget assembly (highest score first, ~4 chars/token heuristic)
    - Best-effort memory fetch with 2s timeout via Promise.race
    - Shared search helper (searchMemories) for /search and /context endpoints

key-files:
  created: []
  modified:
    - nexus/packages/memory/src/index.ts
    - nexus/packages/core/src/daemon.ts

decisions:
  - "[Memory] /context endpoint uses 2000 token default budget, ~4 chars/token heuristic"
  - "[Memory] Memory context injected before user message as 'Known Facts' section"
  - "[Memory] Best-effort fetch with 2s timeout â€” agent proceeds without memory if service unavailable"
  - "[Memory] Subagents get 1000 token budget (half of main agent) for memory context"
  - "[Memory] userId derived from intent.from for per-user isolation across channels"

metrics:
  duration: "~3 minutes"
  completed: "2026-02-15"
---

# Phase v1.5-03 Plan 02: Memory Context Assembly & Agent Injection Summary

Token-budgeted /context endpoint that assembles relevance-scored memories, with automatic injection into agent and subagent system prompts via best-effort 2s-timeout fetch.

## Tasks Completed

### Task 1: Add /context endpoint for token-budgeted memory assembly
**Commit:** `c59c0b0`
**Files:** `nexus/packages/memory/src/index.ts`

Refactored the memory service search logic and added a new context assembly endpoint:

1. **searchMemories() helper** - Extracted the core search logic (embedding lookup, text fallback, time-decay scoring) from the `/search` handler into a reusable `async function searchMemories(userId, query, limit)`. Both `/search` and `/context` now call this shared helper, eliminating code duplication. The `/search` endpoint returns identical results as before.

2. **POST /context endpoint** - Accepts `userId`, `query`, `tokenBudget` (default 2000), and `limit` (default 20). Calls `searchMemories()` to get relevance-scored results, then greedily assembles memories by score using `Math.ceil(content.length / 4)` token estimation (~4 chars per token). Stops adding when budget would be exceeded.

3. **Formatted output** - Returns a structured response with `context` (formatted as `## Known Facts (from memory)\n- fact1\n- fact2\n`), `memoriesUsed`, `tokensUsed`, and `tokenBudget`.

### Task 2: Inject memory context into agent system prompt before conversations
**Commit:** `7b3997b`
**Files:** `nexus/packages/core/src/daemon.ts`

Added automatic memory context injection at two points in the daemon:

1. **Agent handler** (router.register('agent', ...)) - After history injection and before complexity assessment, fetches memory context from `http://localhost:3300/context` using `Promise.race` with a 2000ms timeout. If successful and memories exist, prepends the "Known Facts" block before the user's message. Uses `intent.from || 'default'` for per-user memory isolation.

2. **executeSubagentTask method** - Same pattern but with a smaller 1000-token budget and limit of 10 memories. Memory context is appended to the `contextPrefix` that feeds into the subagent's AgentLoop.

3. **Best-effort resilience** - Both injection points wrap the fetch in try/catch with no rethrow. If the memory service is down, times out (>2s), or returns an error, the agent proceeds without memory context. No user-facing errors.

## Verification Results

| Check | Result |
|-------|--------|
| `npx tsc --noEmit` (memory) | Zero errors |
| `npx tsc --noEmit` (core) | Zero errors |
| `/context` endpoint in memory service | Present (line 344) |
| `searchMemories` helper function | Present (line 243) |
| `memoryContext` injection in agent handler | Present (lines 876-907) |
| Memory context in `executeSubagentTask` | Present (line 2297) |
| 2000ms timeout on memory fetch | Present (lines 892, 2310) |

## Deviations from Plan

### Auto-fixed Issues

**1. [Rule 1 - Bug] Fixed TypeScript type error with intent.source comparison**
- **Found during:** Task 2
- **Issue:** Plan specified `intent.source === 'web'` for userId selection, but `intent.source` is a typed union (`'telegram' | 'discord' | ...`) that does not include `'web'`, causing TS2367
- **Fix:** Changed to `intent.from || 'default'` which correctly uses the user identifier (JID/chatId) or falls back to 'default' for web requests where `intent.from` is undefined
- **Files modified:** `nexus/packages/core/src/daemon.ts`
- **Commit:** `7b3997b`

## Decisions Made

1. **2000 token default budget** - Enough for ~15-20 short memories, keeps prompt overhead manageable
2. **~4 chars/token heuristic** - Simple approximation that works well for English text without needing a tokenizer
3. **2s timeout** - Balances giving the memory service time to respond vs. keeping agent latency low
4. **Subagent 1000 token budget** - Half the main agent budget since subagents are more focused
5. **userId from intent.from** - Ensures WhatsApp/Telegram/Discord/Slack/Matrix users each have isolated memory recall

## Next Phase Readiness

**Ready for v1.5-03-05.** The memory context injection is fully operational. Any new channel provider (Signal, etc.) will automatically benefit from memory context since injection happens at the agent handler level, not per-channel.
