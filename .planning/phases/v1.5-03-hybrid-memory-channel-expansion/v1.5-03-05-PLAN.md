---
phase: v1.5-03-hybrid-memory-channel-expansion
plan: 05
type: execute
wave: 2
depends_on: ["v1.5-03-03", "v1.5-03-04"]
files_modified:
  - livos/packages/ui/src/routes/settings/integrations.tsx
  - nexus/packages/core/src/daemon.ts
autonomous: true

must_haves:
  truths:
    - "User can see Slack and Matrix tabs in Settings > Integrations alongside Telegram and Discord"
    - "Slack tab has fields for Bot Token and App-Level Token with save/connect/disable buttons"
    - "Matrix tab has fields for Homeserver URL, Access Token, and Room ID with save/connect/disable buttons"
    - "Response routing uses per-request context (source + chatId from inbox item) instead of instance state"
  artifacts:
    - path: "livos/packages/ui/src/routes/settings/integrations.tsx"
      provides: "Slack and Matrix configuration panels"
      contains: "SlackPanel"
    - path: "nexus/packages/core/src/daemon.ts"
      provides: "Fixed response routing with per-request context"
      contains: "routeResponse"
  key_links:
    - from: "livos/packages/ui/src/routes/settings/integrations.tsx"
      to: "trpcReact.ai.saveIntegrationConfig"
      via: "mutation call with channel: 'slack'"
      pattern: "channel.*slack"
    - from: "nexus/packages/core/src/daemon.ts"
      to: "channelManager.sendMessage"
      via: "per-request routing context"
      pattern: "sendChannelResponse"
---

<objective>
Add Slack and Matrix configuration panels to the Settings Integrations UI, and fix the response routing race condition by passing source/chatId per-request instead of using instance state.

Purpose: Users need a way to configure Slack and Matrix connections through the UI. The response routing fix ensures messages always go back to the correct channel when multiple channels are active simultaneously.

Output: Updated integrations page with 4 channels, and reliable response routing.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v1.5-03-hybrid-memory-channel-expansion/v1.5-03-03-SUMMARY.md
@.planning/phases/v1.5-03-hybrid-memory-channel-expansion/v1.5-03-04-SUMMARY.md
@livos/packages/ui/src/routes/settings/integrations.tsx
@nexus/packages/core/src/daemon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Slack and Matrix panels to Settings Integrations UI</name>
  <files>livos/packages/ui/src/routes/settings/integrations.tsx</files>
  <action>
Modify `livos/packages/ui/src/routes/settings/integrations.tsx` to add Slack and Matrix tabs alongside the existing Telegram and Discord tabs.

**1. Add icon imports:**
Add to the react-icons/tb import: `TbBrandSlack, TbBrandMatrix` (if available in tabler icons). If `TbBrandMatrix` is not available, use `TbNetwork` as a fallback. Check the actual availability by trying the import — tabler icons v3+ has `TbBrandSlack`. For Matrix, check if `TbBrandMatrix` exists; if not, use `TbMessageCircle` or similar.

**2. Update CHANNELS array:**
```typescript
const CHANNELS = [
  {
    id: 'telegram',
    name: 'Telegram',
    icon: TbBrandTelegram,
    color: 'text-sky-400',
    bgColor: 'bg-sky-500/10',
    borderColor: 'border-sky-500/30',
    description: 'Connect via BotFather token',
    docsUrl: 'https://core.telegram.org/bots#how-do-i-create-a-bot',
  },
  {
    id: 'discord',
    name: 'Discord',
    icon: TbBrandDiscord,
    color: 'text-indigo-400',
    bgColor: 'bg-indigo-500/10',
    borderColor: 'border-indigo-500/30',
    description: 'Connect your Discord bot',
    docsUrl: 'https://discord.com/developers/docs/intro',
  },
  {
    id: 'slack',
    name: 'Slack',
    icon: TbBrandSlack,
    color: 'text-purple-400',
    bgColor: 'bg-purple-500/10',
    borderColor: 'border-purple-500/30',
    description: 'Connect via Slack app with Socket Mode',
    docsUrl: 'https://api.slack.com/start/quickstart',
  },
  {
    id: 'matrix',
    name: 'Matrix',
    icon: TbBrandMatrix, // or TbNetwork fallback
    color: 'text-emerald-400',
    bgColor: 'bg-emerald-500/10',
    borderColor: 'border-emerald-500/30',
    description: 'Connect via Matrix homeserver',
    docsUrl: 'https://matrix.org/docs/guides/',
  },
] as const;
```

**3. Update TabsList:**
Change `grid-cols-2` to `grid-cols-4` to accommodate all channels:
```tsx
<TabsList className='grid w-full grid-cols-4'>
```

**4. Add TabsContent entries:**
After the existing Discord TabsContent, add:
```tsx
<TabsContent value='slack' className='mt-0'>
  <SlackPanel />
</TabsContent>
<TabsContent value='matrix' className='mt-0'>
  <MatrixPanel />
</TabsContent>
```

**5. Create SlackPanel component:**
Follow the same pattern as DiscordPanel but with TWO token fields:

```tsx
function SlackPanel() {
  const [botToken, setBotToken] = useState('')
  const [appToken, setAppToken] = useState('')
  const [showBotToken, setShowBotToken] = useState(false)
  const [showAppToken, setShowAppToken] = useState(false)

  const configQ = trpcReact.ai.getIntegrationConfig.useQuery({channel: 'slack'})
  const statusQ = trpcReact.ai.getIntegrationStatus.useQuery({channel: 'slack'})
  const saveMutation = trpcReact.ai.saveIntegrationConfig.useMutation()
  const testMutation = trpcReact.ai.testIntegration.useMutation()
  const utils = trpcReact.useUtils()

  useEffect(() => {
    if (configQ.data?.token) setBotToken(configQ.data.token)
    if (configQ.data?.appToken) setAppToken(configQ.data.appToken)
  }, [configQ.data])

  const channel = CHANNELS.find((c) => c.id === 'slack')!
  const status = statusQ.data as ChannelStatus | undefined

  const handleSave = async () => {
    await saveMutation.mutateAsync({channel: 'slack', config: {token: botToken, appToken, enabled: true}})
    utils.ai.getIntegrationConfig.invalidate()
    utils.ai.getIntegrationStatus.invalidate()
  }

  return (
    <div className='space-y-4'>
      <ChannelHeader channel={channel} />

      {/* Status */}
      <div className='rounded-radius-md border border-border-default bg-surface-base p-4'>
        <div className='flex items-center justify-between'>
          <div className='text-body font-medium'>Connection Status</div>
          <Button variant='default' size='sm'
            onClick={() => utils.ai.getIntegrationStatus.invalidate({channel: 'slack'})}
            disabled={statusQ.isLoading}>
            <TbRefresh className={cn('h-4 w-4', statusQ.isLoading && 'animate-spin')} />
          </Button>
        </div>
        {statusQ.isLoading ? <LoadingState /> : status ? (
          <div className='mt-4 space-y-3'>
            <StatusRow label='Enabled' connected={status.enabled} />
            <StatusRow label='Connected' connected={status.connected} />
            {status.botName && (
              <div className='flex items-center justify-between text-caption'>
                <span className='text-text-secondary'>Bot</span>
                <span className='text-text-secondary'>{status.botName}</span>
              </div>
            )}
            {status.error && <ErrorBanner message={status.error} />}
          </div>
        ) : <EmptyState message='Not configured' />}
      </div>

      {/* Bot Token */}
      <div className='rounded-radius-md border border-border-default bg-surface-base p-4'>
        <div className='text-body font-medium'>Bot Token</div>
        <div className='mt-1 text-caption text-text-secondary'>
          Bot User OAuth Token (xoxb-...) from your Slack app settings
        </div>
        <div className='mt-3 flex gap-2'>
          <div className='relative flex-1'>
            <Input type={showBotToken ? 'text' : 'password'} value={botToken}
              onChange={(e) => setBotToken(e.target.value)} placeholder='xoxb-...' className='pr-10' />
            <button type='button' onClick={() => setShowBotToken(!showBotToken)}
              className='absolute right-3 top-1/2 -translate-y-1/2 text-text-secondary hover:text-text-secondary'>
              {showBotToken ? <TbEyeOff className='h-4 w-4' /> : <TbEye className='h-4 w-4' />}
            </button>
          </div>
        </div>
      </div>

      {/* App-Level Token */}
      <div className='rounded-radius-md border border-border-default bg-surface-base p-4'>
        <div className='text-body font-medium'>App-Level Token</div>
        <div className='mt-1 text-caption text-text-secondary'>
          App-Level Token (xapp-...) with <code>connections:write</code> scope for Socket Mode
        </div>
        <div className='mt-3 flex gap-2'>
          <div className='relative flex-1'>
            <Input type={showAppToken ? 'text' : 'password'} value={appToken}
              onChange={(e) => setAppToken(e.target.value)} placeholder='xapp-...' className='pr-10' />
            <button type='button' onClick={() => setShowAppToken(!showAppToken)}
              className='absolute right-3 top-1/2 -translate-y-1/2 text-text-secondary hover:text-text-secondary'>
              {showAppToken ? <TbEyeOff className='h-4 w-4' /> : <TbEye className='h-4 w-4' />}
            </button>
          </div>
        </div>
      </div>

      {/* Actions */}
      <div className='flex gap-2'>
        <Button variant='primary' className='flex-1' onClick={handleSave}
          disabled={!botToken || !appToken || saveMutation.isPending}>
          {saveMutation.isPending ? <Loader2 className='mr-2 h-4 w-4 animate-spin' /> : null}
          Save & Connect
        </Button>
        <Button variant='default' onClick={() => testMutation.mutateAsync({channel: 'slack'}).then(() => utils.ai.getIntegrationStatus.invalidate())}
          disabled={!status?.enabled || testMutation.isPending}>
          {testMutation.isPending ? <Loader2 className='mr-2 h-4 w-4 animate-spin' /> : null}
          Test
        </Button>
        {status?.enabled && (
          <Button variant='destructive' onClick={() => saveMutation.mutateAsync({channel: 'slack', config: {enabled: false}}).then(() => {
            utils.ai.getIntegrationConfig.invalidate(); utils.ai.getIntegrationStatus.invalidate()
          })}>Disable</Button>
        )}
      </div>

      <UsageInfo items={[
        'Requires a Slack app with Socket Mode enabled',
        'Bot needs chat:write and app_mentions:read scopes',
        'Message the bot directly or mention it in channels',
      ]} />
    </div>
  )
}
```

**6. Create MatrixPanel component:**
Similar to SlackPanel but with homeserver URL, access token, and room ID fields:

```tsx
function MatrixPanel() {
  const [homeserverUrl, setHomeserverUrl] = useState('')
  const [token, setToken] = useState('')
  const [roomId, setRoomId] = useState('')
  const [showToken, setShowToken] = useState(false)

  const configQ = trpcReact.ai.getIntegrationConfig.useQuery({channel: 'matrix'})
  const statusQ = trpcReact.ai.getIntegrationStatus.useQuery({channel: 'matrix'})
  const saveMutation = trpcReact.ai.saveIntegrationConfig.useMutation()
  const testMutation = trpcReact.ai.testIntegration.useMutation()
  const utils = trpcReact.useUtils()

  useEffect(() => {
    if (configQ.data?.token) setToken(configQ.data.token)
    if (configQ.data?.homeserverUrl) setHomeserverUrl(configQ.data.homeserverUrl)
    if (configQ.data?.roomId) setRoomId(configQ.data.roomId)
  }, [configQ.data])

  const channel = CHANNELS.find((c) => c.id === 'matrix')!
  const status = statusQ.data as ChannelStatus | undefined

  const handleSave = async () => {
    await saveMutation.mutateAsync({
      channel: 'matrix',
      config: {token, homeserverUrl, roomId, enabled: true}
    })
    utils.ai.getIntegrationConfig.invalidate()
    utils.ai.getIntegrationStatus.invalidate()
  }

  return (
    <div className='space-y-4'>
      <ChannelHeader channel={channel} />

      {/* Status */}
      <div className='rounded-radius-md border border-border-default bg-surface-base p-4'>
        {/* Same status display pattern as other channels */}
        <div className='flex items-center justify-between'>
          <div className='text-body font-medium'>Connection Status</div>
          <Button variant='default' size='sm'
            onClick={() => utils.ai.getIntegrationStatus.invalidate({channel: 'matrix'})}
            disabled={statusQ.isLoading}>
            <TbRefresh className={cn('h-4 w-4', statusQ.isLoading && 'animate-spin')} />
          </Button>
        </div>
        {statusQ.isLoading ? <LoadingState /> : status ? (
          <div className='mt-4 space-y-3'>
            <StatusRow label='Enabled' connected={status.enabled} />
            <StatusRow label='Connected' connected={status.connected} />
            {status.botName && (
              <div className='flex items-center justify-between text-caption'>
                <span className='text-text-secondary'>User</span>
                <span className='text-text-secondary'>@{status.botName}</span>
              </div>
            )}
            {status.error && <ErrorBanner message={status.error} />}
          </div>
        ) : <EmptyState message='Not configured' />}
      </div>

      {/* Homeserver URL */}
      <div className='rounded-radius-md border border-border-default bg-surface-base p-4'>
        <div className='text-body font-medium'>Homeserver URL</div>
        <div className='mt-1 text-caption text-text-secondary'>
          Your Matrix homeserver (e.g., https://matrix.org)
        </div>
        <div className='mt-3'>
          <Input type='text' value={homeserverUrl}
            onChange={(e) => setHomeserverUrl(e.target.value)}
            placeholder='https://matrix.org' />
        </div>
      </div>

      {/* Access Token */}
      <div className='rounded-radius-md border border-border-default bg-surface-base p-4'>
        <div className='text-body font-medium'>Access Token</div>
        <div className='mt-1 text-caption text-text-secondary'>
          Bot account access token (get from Element: Settings → Help & About → Access Token)
        </div>
        <div className='mt-3 flex gap-2'>
          <div className='relative flex-1'>
            <Input type={showToken ? 'text' : 'password'} value={token}
              onChange={(e) => setToken(e.target.value)} placeholder='syt_...' className='pr-10' />
            <button type='button' onClick={() => setShowToken(!showToken)}
              className='absolute right-3 top-1/2 -translate-y-1/2 text-text-secondary hover:text-text-secondary'>
              {showToken ? <TbEyeOff className='h-4 w-4' /> : <TbEye className='h-4 w-4' />}
            </button>
          </div>
        </div>
      </div>

      {/* Room ID */}
      <div className='rounded-radius-md border border-border-default bg-surface-base p-4'>
        <div className='text-body font-medium'>Room ID</div>
        <div className='mt-1 text-caption text-text-secondary'>
          The room to listen in (e.g., !abc123:matrix.org). Leave empty to listen in all joined rooms.
        </div>
        <div className='mt-3'>
          <Input type='text' value={roomId}
            onChange={(e) => setRoomId(e.target.value)}
            placeholder='!roomid:matrix.org' />
        </div>
      </div>

      {/* Actions */}
      <div className='flex gap-2'>
        <Button variant='primary' className='flex-1' onClick={handleSave}
          disabled={!token || !homeserverUrl || saveMutation.isPending}>
          {saveMutation.isPending ? <Loader2 className='mr-2 h-4 w-4 animate-spin' /> : null}
          Save & Connect
        </Button>
        <Button variant='default' onClick={() => testMutation.mutateAsync({channel: 'matrix'}).then(() => utils.ai.getIntegrationStatus.invalidate())}
          disabled={!status?.enabled || testMutation.isPending}>
          {testMutation.isPending ? <Loader2 className='mr-2 h-4 w-4 animate-spin' /> : null}
          Test
        </Button>
        {status?.enabled && (
          <Button variant='destructive' onClick={() => saveMutation.mutateAsync({channel: 'matrix', config: {enabled: false}}).then(() => {
            utils.ai.getIntegrationConfig.invalidate(); utils.ai.getIntegrationStatus.invalidate()
          })}>Disable</Button>
        )}
      </div>

      <UsageInfo items={[
        'Create a bot account on your homeserver',
        'Invite the bot to the target room',
        'Messages in the room will be processed by the AI',
      ]} />
    </div>
  )
}
```

The tRPC routes `ai.getIntegrationConfig`, `ai.saveIntegrationConfig`, `ai.getIntegrationStatus`, and `ai.testIntegration` already work with any channel string — they pass through to the ChannelManager. No backend changes needed for the UI to work with 'slack' and 'matrix'.
  </action>
  <verify>
Run `cd livos && pnpm --filter @livos/config build && pnpm --filter ui build 2>&1 | tail -20` to check if the UI builds. Or at minimum check TypeScript: `cd livos/packages/ui && npx tsc --noEmit 2>&1 | head -20`. Grep for `SlackPanel` and `MatrixPanel` in integrations.tsx.
  </verify>
  <done>
Settings > Integrations page shows 4 tabs: Telegram, Discord, Slack, Matrix. Slack panel has Bot Token + App-Level Token fields. Matrix panel has Homeserver URL + Access Token + Room ID fields. All panels follow the existing save/connect/test/disable pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix response routing race condition (CHAN-05)</name>
  <files>nexus/packages/core/src/daemon.ts</files>
  <action>
The current response routing in daemon.ts uses hardcoded channel source checks to determine how to route responses. When multiple channels send messages concurrently, the response could be routed to the wrong channel because the `onAction` callback captures `source` and `chatId` from the enclosing scope.

**The fix:** Ensure that `source` and `chatId` are always passed per-request through the processing pipeline, not captured from instance state.

**Current flow (in `processInboxItem` or equivalent):**
The inbox item contains `source` and `from` fields. The response routing already uses `item.source` and `item.from` in `sendChannelResponse`. The action callback already receives `source` and `chatId` via closure.

**What to verify and fix:**

1. **In the agent action callback** (the `createActionCallback` method around line 2155-2203): This closure captures `source` and `chatId`. Verify it uses these directly and does NOT reference any `this.lastChannel` or `this.currentChannel` instance state. If it does, replace with the closure variables.

2. **Check for any shared mutable state** related to response routing. Search for patterns like:
   - `this.lastChannel`
   - `this.currentSource`
   - `this.responseTarget`
   - Any property on `this` that stores the current channel/chatId

   If found, remove these and ensure each request carries its own routing context.

3. **The `sendChannelResponse` method** (around line 2049-2082): This already takes the `InboxItem` as parameter and reads `item.source` and `item.from` directly. This is correct — verify it does NOT read from any `this.xxx` state.

4. **The WhatsApp response routing**: Check that WhatsApp outbox pushes use `item.from` (the JID) from the inbox item, not from any instance state.

5. **Verify the processInboxItem method** passes `source` and `from` through the entire chain. The critical path is:
   ```
   processInboxItem(item)
     → creates action callback with item.source, item.from in closure
     → runs agent
     → agent calls action callback with source/chatId from closure
     → response sent via sendChannelResponse(item, text) or wa_outbox
   ```

   If this chain is already correct (each request has its own closure with its own source/chatId), add a comment documenting this pattern:
   ```typescript
   // CHAN-05: Response routing uses per-request closure context (source, chatId)
   // to prevent race conditions when multiple channels send concurrent messages.
   // Do NOT replace these with instance state (this.lastChannel, etc.).
   ```

6. **If you find the race condition**: The typical fix is to ensure the action callback and response routing functions receive `source` and `chatId` as parameters or closure variables from the specific inbox item being processed, not from a shared `this` property.

Do NOT restructure the entire processing pipeline. This is a targeted fix to ensure per-request context isolation in response routing.
  </action>
  <verify>
Grep for `this.lastChannel`, `this.currentSource`, `this.responseTarget` in daemon.ts — should find NONE. Grep for `CHAN-05` comment to confirm documentation was added. Run `cd nexus/packages/core && npx tsc --noEmit` to verify TypeScript compiles.
  </verify>
  <done>
Response routing is verified to use per-request closure context (source + chatId from the inbox item). No shared mutable state exists for channel routing. CHAN-05 documentation comment added to prevent future regressions. All TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cd nexus/packages/core && npx tsc --noEmit` — zero errors
2. Grep confirms `SlackPanel` and `MatrixPanel` in integrations.tsx
3. Grep confirms `grid-cols-4` in TabsList
4. Grep confirms no `this.lastChannel` or `this.currentSource` in daemon.ts
5. Grep confirms `CHAN-05` comment in daemon.ts
6. UI builds successfully (or at minimum tsc passes)
</verification>

<success_criteria>
- Settings Integrations page shows 4 channel tabs (Telegram, Discord, Slack, Matrix)
- Slack panel has Bot Token + App-Level Token with save/connect/test/disable
- Matrix panel has Homeserver URL + Access Token + Room ID with save/connect/test/disable
- Response routing is race-condition free (per-request context, no shared state)
- All TypeScript compiles cleanly in both nexus and livos
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-03-hybrid-memory-channel-expansion/v1.5-03-05-SUMMARY.md`
</output>
