---
phase: v1.5-03-hybrid-memory-channel-expansion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - nexus/packages/core/src/channels/slack.ts
  - nexus/packages/core/src/channels/types.ts
  - nexus/packages/core/src/channels/index.ts
autonomous: true

must_haves:
  truths:
    - "SlackProvider implements ChannelProvider interface using @slack/bolt Socket Mode"
    - "ChannelId type includes 'slack' as a valid option"
    - "ChannelManager registers SlackProvider and can route messages to Slack"
    - "Slack bot token and app token are read from Redis config"
  artifacts:
    - path: "nexus/packages/core/src/channels/slack.ts"
      provides: "SlackProvider implementation"
      contains: "class SlackProvider"
    - path: "nexus/packages/core/src/channels/types.ts"
      provides: "Updated ChannelId with 'slack'"
      contains: "'slack'"
    - path: "nexus/packages/core/src/channels/index.ts"
      provides: "SlackProvider registered in ChannelManager"
      contains: "SlackProvider"
  key_links:
    - from: "nexus/packages/core/src/channels/slack.ts"
      to: "@slack/bolt"
      via: "App constructor with Socket Mode"
      pattern: "new App"
    - from: "nexus/packages/core/src/channels/index.ts"
      to: "nexus/packages/core/src/channels/slack.ts"
      via: "import and register"
      pattern: "providers.set.*slack"
---

<objective>
Implement SlackProvider using @slack/bolt Socket Mode, update ChannelId to include 'slack', and register it in ChannelManager.

Purpose: Users should be able to connect a Slack workspace and interact with the AI via Slack messages.

Output: Working SlackProvider that follows the existing TelegramProvider/DiscordProvider pattern.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@nexus/packages/core/src/channels/types.ts
@nexus/packages/core/src/channels/index.ts
@nexus/packages/core/src/channels/telegram.ts
@nexus/packages/core/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ChannelId type and metadata for Slack</name>
  <files>nexus/packages/core/src/channels/types.ts</files>
  <action>
Update the ChannelId type and CHANNEL_META in `nexus/packages/core/src/channels/types.ts`:

1. Change the ChannelId type from:
   ```typescript
   export type ChannelId = 'telegram' | 'discord';
   ```
   to:
   ```typescript
   export type ChannelId = 'telegram' | 'discord' | 'slack' | 'matrix';
   ```
   Include 'matrix' now even though the MatrixProvider comes later — this avoids a second type change.

2. Update ChannelConfig to support Slack's dual-token requirement:
   ```typescript
   export interface ChannelConfig {
     enabled: boolean;
     token?: string;
     /** Slack app-level token for Socket Mode (xapp-...) */
     appToken?: string;
     /** Matrix homeserver URL */
     homeserverUrl?: string;
     /** Matrix room ID */
     roomId?: string;
   }
   ```

3. Add entries to CHANNEL_META:
   ```typescript
   export const CHANNEL_META: Record<ChannelId, { name: string; color: string; textLimit: number }> = {
     telegram: { name: 'Telegram', color: '#0088cc', textLimit: 4096 },
     discord: { name: 'Discord', color: '#5865F2', textLimit: 2000 },
     slack: { name: 'Slack', color: '#4A154B', textLimit: 4000 },
     matrix: { name: 'Matrix', color: '#0DBD8B', textLimit: 65536 },
   };
   ```

Do NOT change the ChannelProvider interface, IncomingMessage, OutgoingMessage, chunkText, or getRedisPrefix — those are generic and work for any channel.
  </action>
  <verify>
Run `cd nexus/packages/core && npx tsc --noEmit` to verify TypeScript compiles. Note: There will likely be type errors in other files that use `ChannelId` exhaustively (e.g., daemon.ts hardcoded channel lists). These are expected and will be fixed in a later task — verify the types.ts file itself is correct.
  </verify>
  <done>
ChannelId type includes 'slack' and 'matrix'. ChannelConfig has optional appToken, homeserverUrl, roomId fields for Slack and Matrix. CHANNEL_META has entries for all four channels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SlackProvider and register in ChannelManager</name>
  <files>nexus/packages/core/src/channels/slack.ts, nexus/packages/core/src/channels/index.ts, nexus/packages/core/src/daemon.ts</files>
  <action>
**Create `nexus/packages/core/src/channels/slack.ts`:**

Follow the exact same pattern as TelegramProvider. The file should be ~180 lines.

```typescript
import { App, LogLevel } from '@slack/bolt';
import type Redis from 'ioredis';
import { logger } from '../logger.js';
import type {
  ChannelProvider,
  ChannelConfig,
  ChannelStatus,
  IncomingMessage,
} from './types.js';
import { chunkText, CHANNEL_META, getRedisPrefix } from './types.js';

export class SlackProvider implements ChannelProvider {
  readonly id = 'slack' as const;
  readonly name = 'Slack';

  private redis: Redis | null = null;
  private app: App | null = null;
  private config: ChannelConfig = { enabled: false };
  private status: ChannelStatus = { enabled: false, connected: false };
  private messageHandler: ((msg: IncomingMessage) => Promise<void>) | null = null;

  async init(redis: Redis): Promise<void> {
    this.redis = redis;
    await this.loadConfig();
  }

  private async loadConfig(): Promise<void> {
    if (!this.redis) return;
    const configStr = await this.redis.get(`${getRedisPrefix(this.id)}:config`);
    if (configStr) {
      try {
        this.config = JSON.parse(configStr);
      } catch {
        logger.warn('SlackProvider: invalid config in Redis');
      }
    }
  }

  async updateConfig(config: ChannelConfig): Promise<void> {
    this.config = { ...this.config, ...config };
    if (this.redis) {
      await this.redis.set(`${getRedisPrefix(this.id)}:config`, JSON.stringify(this.config));
    }
    if (config.token && config.appToken && this.config.enabled) {
      await this.disconnect();
      await this.connect();
    } else if (!this.config.enabled) {
      await this.disconnect();
    }
  }

  async connect(): Promise<void> {
    if (!this.config.enabled || !this.config.token || !this.config.appToken) {
      this.status = { enabled: false, connected: false, error: 'Not configured (need bot token + app token)' };
      await this.saveStatus();
      return;
    }

    try {
      this.app = new App({
        token: this.config.token,        // Bot token (xoxb-...)
        appToken: this.config.appToken,  // App-level token (xapp-...)
        socketMode: true,
        logLevel: LogLevel.WARN,
      });

      // Listen for messages
      this.app.message(async ({ message, say }) => {
        if (!this.messageHandler) return;
        // Skip bot messages and message_changed events
        if ((message as any).subtype) return;
        const msg = message as any;
        if (!msg.text || msg.bot_id) return;

        const incoming: IncomingMessage = {
          channel: 'slack',
          chatId: msg.channel,
          userId: msg.user || 'unknown',
          userName: msg.user, // Will be Slack user ID; display name requires API call
          text: msg.text,
          timestamp: Math.floor(parseFloat(msg.ts || '0') * 1000),
          replyToMessageId: msg.thread_ts,
          isGroup: msg.channel_type === 'group' || msg.channel_type === 'channel',
        };

        // Save last chat ID for heartbeat delivery
        if (this.redis) {
          await this.redis.set(`nexus:slack:last_chat_id`, msg.channel);
        }

        await this.messageHandler(incoming);
      });

      await this.app.start();

      // Get bot info
      const authResult = await this.app.client.auth.test({ token: this.config.token });

      this.status = {
        enabled: true,
        connected: true,
        botName: (authResult as any).bot_id || (authResult as any).user,
        botId: (authResult as any).user_id,
        lastConnect: new Date().toISOString(),
      };

      await this.saveStatus();
      logger.info('SlackProvider: connected via Socket Mode', { bot: this.status.botName });
    } catch (err: any) {
      this.status = {
        enabled: true,
        connected: false,
        error: err.message || 'Connection failed',
      };
      await this.saveStatus();
      logger.error('SlackProvider: connection failed', { error: err.message });
    }
  }

  async disconnect(): Promise<void> {
    if (this.app) {
      try {
        await this.app.stop();
      } catch {
        // Ignore stop errors
      }
      this.app = null;
    }
    this.status = { ...this.status, connected: false };
    await this.saveStatus();
  }

  async getStatus(): Promise<ChannelStatus> {
    return this.status;
  }

  async sendMessage(chatId: string, text: string, replyTo?: string): Promise<boolean> {
    if (!this.app || !this.status.connected) return false;

    try {
      const chunks = chunkText(text, CHANNEL_META.slack.textLimit);
      for (const chunk of chunks) {
        await this.app.client.chat.postMessage({
          token: this.config.token,
          channel: chatId,
          text: chunk,
          ...(replyTo ? { thread_ts: replyTo } : {}),
        });
      }
      return true;
    } catch (err: any) {
      logger.error('SlackProvider: send failed', { error: err.message, chatId });
      return false;
    }
  }

  onMessage(handler: (msg: IncomingMessage) => Promise<void>): void {
    this.messageHandler = handler;
  }

  async testConnection(): Promise<{ ok: boolean; error?: string; botName?: string }> {
    if (!this.config.token || !this.config.appToken) {
      return { ok: false, error: 'Bot token and app-level token required' };
    }

    try {
      const testApp = new App({
        token: this.config.token,
        appToken: this.config.appToken,
        socketMode: true,
        logLevel: LogLevel.ERROR,
      });
      const authResult = await testApp.client.auth.test({ token: this.config.token });
      await testApp.stop().catch(() => {});
      return {
        ok: true,
        botName: (authResult as any).user || (authResult as any).bot_id,
      };
    } catch (err: any) {
      return { ok: false, error: err.message || 'Test failed' };
    }
  }

  private async saveStatus(): Promise<void> {
    if (!this.redis) return;
    try {
      await this.redis.set(`${getRedisPrefix(this.id)}:status`, JSON.stringify(this.status));
    } catch {
      // Ignore Redis errors during status save
    }
  }
}
```

**Update `nexus/packages/core/src/channels/index.ts`:**

1. Add import: `import { SlackProvider } from './slack.js';`
2. In the ChannelManager constructor, add: `this.providers.set('slack', new SlackProvider());`

**Update `nexus/packages/core/src/daemon.ts`:**

Find the hardcoded channel lists in daemon.ts and update them to include 'slack':

1. In `sendChannelResponse` (around line 2053): Change `const channelSources = ['telegram', 'discord'] as const;` to `const channelSources = ['telegram', 'discord', 'slack'] as const;`

2. In the action routing section (around line 2187-2188): Change `const channelSources = ['telegram', 'discord'] as const;` to `const channelSources = ['telegram', 'discord', 'slack'] as const;`

3. In `nexus/packages/core/src/index.ts`, in the heartbeat delivery logic (around line 120-141): Update the `'telegram', 'discord'` list to include `'slack'`. Change:
   ```typescript
   for (const channelId of ['telegram', 'discord'] as const) {
   ```
   to:
   ```typescript
   for (const channelId of ['telegram', 'discord', 'slack'] as const) {
   ```
   Also update the if check:
   ```typescript
   if (target === 'telegram' || target === 'discord') {
   ```
   to:
   ```typescript
   if (target === 'telegram' || target === 'discord' || target === 'slack') {
   ```

These are the only places with hardcoded channel lists that need updating. Do NOT add 'matrix' here yet — that comes in plan 04.
  </action>
  <verify>
Run `cd nexus/packages/core && npx tsc --noEmit` to verify TypeScript compiles. Grep for `class SlackProvider` in slack.ts, `SlackProvider` in index.ts, and `'slack'` in daemon.ts to confirm all wiring.
  </verify>
  <done>
SlackProvider is implemented using @slack/bolt Socket Mode, registered in ChannelManager, and all hardcoded channel lists in daemon.ts and index.ts include 'slack'. The provider handles incoming messages, sends responses via chat.postMessage, supports threaded replies, and stores last_chat_id for heartbeat delivery.
  </done>
</task>

</tasks>

<verification>
1. `cd nexus/packages/core && npx tsc --noEmit` — zero errors
2. Grep confirms `class SlackProvider` in slack.ts
3. Grep confirms `'slack'` in ChannelId type
4. Grep confirms `SlackProvider` imported and registered in channels/index.ts
5. Grep confirms `'slack'` in daemon.ts sendChannelResponse
6. Grep confirms `'slack'` in index.ts heartbeat delivery
</verification>

<success_criteria>
- SlackProvider implements full ChannelProvider interface
- Socket Mode connection (no public URL required)
- Messages from Slack are routed through the standard inbox pipeline
- Responses are sent back to the correct Slack channel/thread
- ChannelManager registers and manages SlackProvider lifecycle
- Hardcoded channel lists updated across daemon.ts and index.ts
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/v1.5-03-hybrid-memory-channel-expansion/v1.5-03-03-SUMMARY.md`
</output>
