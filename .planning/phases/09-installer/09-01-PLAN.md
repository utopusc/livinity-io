---
phase: 09-installer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - livos/install.sh
autonomous: true

must_haves:
  truths:
    - "install.sh detects OS and reports Ubuntu/Debian vs other"
    - "install.sh detects architecture and maps to amd64/arm64"
    - "install.sh fails gracefully on partial download (function wrapped)"
    - "install.sh cleans up on error (ERR trap)"
  artifacts:
    - path: "livos/install.sh"
      provides: "One-command installer foundation"
      contains: "main()"
      min_lines: 200
  key_links:
    - from: "livos/install.sh"
      to: "/etc/os-release"
      via: "source for OS detection"
      pattern: "\\. /etc/os-release"
---

<objective>
Create the foundation of install.sh with robust error handling, OS/architecture detection, and function wrapping for curl | bash safety.

Purpose: Establish a production-grade installer foundation that handles errors gracefully, detects the target system accurately, and prevents partial script execution from network interruptions.

Output: `livos/install.sh` with main function wrapper, strict mode, ERR trap, cleanup handler, and comprehensive OS/architecture detection.
</objective>

<execution_context>
@C:\Users\hello\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hello\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-installer/09-RESEARCH.md
@livos/setup.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create install.sh with function wrapper and strict mode</name>
  <files>livos/install.sh</files>
  <action>
Create new `livos/install.sh` that wraps all logic in a `main()` function for curl | bash safety.

Structure (from research):
```bash
#!/usr/bin/env bash
# LivOS One-Command Installer
# Usage: curl -sSL https://... | bash

main() {
    set -euo pipefail

    # Constants
    LIVOS_DIR="/opt/livos"
    REPO_URL="https://github.com/utopusc/livos.git"

    # Colors (from existing setup.sh)
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'

    # Helper functions
    info()  { echo -e "${BLUE}[INFO]${NC}  $*"; }
    ok()    { echo -e "${GREEN}[OK]${NC}    $*"; }
    warn()  { echo -e "${YELLOW}[WARN]${NC}  $*"; }
    fail()  { echo -e "${RED}[FAIL]${NC}  $*"; cleanup_on_error; exit 1; }
    step()  { echo -e "\n${CYAN}━━━ $* ━━━${NC}"; }

    # Setup ERR trap
    trap 'cleanup_on_error $LINENO' ERR

    # ... rest of installation logic ...

    echo "Installation complete!"
}

cleanup_on_error() {
    local line_no="${1:-unknown}"
    echo -e "\n${RED}[ERROR]${NC} Installation failed at line $line_no"
    echo "Partial installation may exist. Check /opt/livos for cleanup."
    # Don't auto-remove - user may want to inspect
}

# Execute main - prevents partial script execution
main "$@"
```

Keep the color scheme and helper functions from existing setup.sh but restructure into main().
  </action>
  <verify>bash -n livos/install.sh (syntax check passes)</verify>
  <done>install.sh exists with main() wrapper, set -euo pipefail, ERR trap, cleanup_on_error function</done>
</task>

<task type="auto">
  <name>Task 2: Add OS and architecture detection</name>
  <files>livos/install.sh</files>
  <action>
Add comprehensive OS and architecture detection inside main(), before any installation steps.

Add these functions inside main():

```bash
detect_os() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        OS_ID="${ID:-unknown}"
        OS_VERSION_ID="${VERSION_ID:-unknown}"
        OS_CODENAME="${VERSION_CODENAME:-}"
        OS_PRETTY_NAME="${PRETTY_NAME:-Unknown OS}"
    else
        fail "Cannot detect OS - /etc/os-release not found"
    fi

    # Validate supported OS
    case "$OS_ID" in
        ubuntu|debian)
            ok "Detected: $OS_PRETTY_NAME"
            ;;
        *)
            warn "OS '$OS_ID' not officially supported. Continuing anyway..."
            warn "Tested on: Ubuntu 22.04+, Debian 11+"
            ;;
    esac
}

detect_arch() {
    local raw_arch
    raw_arch=$(uname -m)

    case "$raw_arch" in
        x86_64)  ARCH="amd64" ;;
        aarch64) ARCH="arm64" ;;
        armv7l)  ARCH="armhf" ;;
        *)       fail "Unsupported architecture: $raw_arch" ;;
    esac

    ok "Architecture: $ARCH ($raw_arch)"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        fail "This script must be run as root (use: sudo bash install.sh)"
    fi
    ok "Running as root"
}
```

Call these in sequence at the start of main():
```bash
step "Pre-flight checks"
check_root
detect_os
detect_arch
```

The $OS_ID, $OS_CODENAME, and $ARCH variables will be used later for package installation and Docker setup.
  </action>
  <verify>Run: bash -c "source livos/install.sh; detect_os; detect_arch" (in a test context) or review code for correct function definitions</verify>
  <done>install.sh has detect_os(), detect_arch(), check_root() functions that set OS_ID, OS_CODENAME, ARCH variables</done>
</task>

<task type="auto">
  <name>Task 3: Port dependency installation from setup.sh</name>
  <files>livos/install.sh</files>
  <action>
Port the dependency installation logic from existing setup.sh into install.sh, using the new OS detection variables.

Add idempotent install functions:

```bash
install_nodejs() {
    local required_version=22

    if command -v node &>/dev/null; then
        local current
        current=$(node -v | cut -d. -f1 | tr -d v)
        if [[ "$current" -ge "$required_version" ]]; then
            ok "Node.js $(node -v) already installed"
            return 0
        fi
    fi

    info "Installing Node.js ${required_version}.x..."

    apt-get update -qq
    apt-get install -y -qq ca-certificates curl gnupg

    mkdir -p /etc/apt/keyrings
    curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | \
        gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg

    echo "deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_${required_version}.x nodistro main" | \
        tee /etc/apt/sources.list.d/nodesource.list

    apt-get update -qq
    apt-get install -y -qq nodejs

    ok "Node.js $(node -v) installed"
}

install_docker() {
    if command -v docker &>/dev/null; then
        ok "Docker $(docker --version | cut -d' ' -f3 | tr -d ',') already installed"
        return 0
    fi

    info "Installing Docker..."

    # Remove old versions
    apt-get remove -y docker docker-engine docker.io containerd runc 2>/dev/null || true

    apt-get update -qq
    apt-get install -y -qq ca-certificates curl

    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL "https://download.docker.com/linux/${OS_ID}/gpg" -o /etc/apt/keyrings/docker.asc
    chmod a+r /etc/apt/keyrings/docker.asc

    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] \
        https://download.docker.com/linux/${OS_ID} ${OS_CODENAME} stable" | \
        tee /etc/apt/sources.list.d/docker.list

    apt-get update -qq
    apt-get install -y -qq docker-ce docker-ce-cli containerd.io \
        docker-buildx-plugin docker-compose-plugin

    systemctl enable docker
    systemctl start docker

    ok "Docker $(docker --version | cut -d' ' -f3 | tr -d ',') installed"
}

install_redis() {
    if command -v redis-server &>/dev/null; then
        ok "Redis already installed"
        return 0
    fi

    info "Installing Redis..."
    apt-get install -y -qq redis-server
    systemctl enable redis-server
    ok "Redis installed"
}

install_pnpm() {
    if command -v pnpm &>/dev/null; then
        ok "pnpm already installed"
        return 0
    fi

    info "Installing pnpm..."
    npm install -g pnpm
    ok "pnpm installed"
}

install_pm2() {
    if command -v pm2 &>/dev/null; then
        ok "PM2 already installed"
        return 0
    fi

    info "Installing PM2..."
    npm install -g pm2
    ok "PM2 installed"
}

install_python() {
    if command -v python3 &>/dev/null; then
        ok "Python3 $(python3 --version | cut -d' ' -f2) already installed"
        return 0
    fi

    info "Installing Python3..."
    apt-get install -y -qq python3 python3-pip python3-venv
    ok "Python3 installed"
}

install_build_tools() {
    info "Installing build tools..."
    apt-get install -y -qq build-essential git curl
    ok "Build tools ready"
}
```

Add a main installation step that calls these:
```bash
step "Installing system dependencies"
export DEBIAN_FRONTEND=noninteractive
apt-get update -qq

install_build_tools
install_nodejs
install_pnpm
install_pm2
install_redis
install_docker
install_python

ok "All system dependencies ready"
```

Note: Docker install uses $OS_ID and $OS_CODENAME from detect_os().
  </action>
  <verify>bash -n livos/install.sh (syntax check)</verify>
  <done>install.sh has idempotent install functions for Node.js, Docker, Redis, pnpm, PM2, Python, build-essential that use OS detection variables</done>
</task>

</tasks>

<verification>
1. `bash -n livos/install.sh` returns 0 (no syntax errors)
2. Script contains `main()` function wrapper with `main "$@"` at end
3. Script contains `set -euo pipefail` inside main
4. Script contains `trap 'cleanup_on_error' ERR`
5. Script contains `detect_os()` that sources `/etc/os-release`
6. Script contains `detect_arch()` that maps uname -m to amd64/arm64
7. Script contains idempotent install_* functions for all dependencies
</verification>

<success_criteria>
- install.sh exists at livos/install.sh
- Script is executable and passes bash syntax check
- Main function wrapper prevents partial execution
- ERR trap provides error line number on failure
- OS detection works and sets OS_ID, OS_CODENAME, ARCH
- All dependency installers are idempotent (check before install)
</success_criteria>

<output>
After completion, create `.planning/phases/09-installer/09-01-SUMMARY.md`
</output>
