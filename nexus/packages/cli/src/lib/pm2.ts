import { execSync } from 'node:child_process';
import { writeFileSync, existsSync } from 'node:fs';
import { createConnection } from 'node:net';

// ── Types ──────────────────────────────────────────────────────

export interface ServiceConfig {
  livosBaseDir: string;
  nexusBaseDir: string;
  logsDir: string;
}

export interface HealthResult {
  service: string;
  healthy: boolean;
  port: number;
}

interface PM2JsonProcess {
  name: string;
  pm2_env: { status: string };
}

// ── Ecosystem Generator ────────────────────────────────────────

/**
 * Generate the contents of a PM2 ecosystem.config.cjs file.
 * Returns a JavaScript string that can be written to disk.
 */
export function generateEcosystemConfig(config: ServiceConfig): string {
  const { livosBaseDir, nexusBaseDir, logsDir } = config;

  // Determine Python interpreter for memory service
  const venvPython = `${nexusBaseDir}/packages/memory/venv/bin/python3`;

  return `// PM2 Ecosystem config — generated by livinity CLI
// Do not edit manually; re-run \`livinity setup\` to regenerate.

const LIVOS_BASE = '${livosBaseDir}';
const NEXUS_BASE = '${nexusBaseDir}';
const LOGS_DIR   = '${logsDir}';

// Check for Python venv
const fs = require('fs');
const memoryInterpreter = fs.existsSync('${venvPython}')
  ? '${venvPython}'
  : 'python3';

module.exports = {
  apps: [
    // ── LivOS daemon ──────────────────────────────────────
    {
      name: 'livos',
      interpreter: 'tsx',
      script: LIVOS_BASE + '/packages/livinityd/source/cli.ts',
      args: '--data-directory ' + LIVOS_BASE + '/data --port 8080',
      env: {
        NODE_ENV: 'production',
      },
      max_memory_restart: '500M',
      exp_backoff_restart_delay: 100,
      log_file:   LOGS_DIR + '/livos.log',
      error_file: LOGS_DIR + '/livos-error.log',
      out_file:   LOGS_DIR + '/livos-out.log',
    },

    // ── Nexus Core ────────────────────────────────────────
    {
      name: 'nexus-core',
      script: 'packages/core/dist/index.js',
      cwd: NEXUS_BASE,
      env: {
        NODE_ENV: 'production',
        DAEMON_INTERVAL_MS: '30000',
      },
      max_memory_restart: '500M',
      exp_backoff_restart_delay: 100,
      log_file:   LOGS_DIR + '/nexus-core.log',
      error_file: LOGS_DIR + '/nexus-core-error.log',
      out_file:   LOGS_DIR + '/nexus-core-out.log',
    },

    // ── Nexus Worker ──────────────────────────────────────
    {
      name: 'nexus-worker',
      script: 'packages/worker/dist/index.js',
      cwd: NEXUS_BASE,
      env: {
        NODE_ENV: 'production',
      },
      max_memory_restart: '500M',
      exp_backoff_restart_delay: 100,
      log_file:   LOGS_DIR + '/nexus-worker.log',
      error_file: LOGS_DIR + '/nexus-worker-error.log',
      out_file:   LOGS_DIR + '/nexus-worker-out.log',
    },

    // ── Nexus Memory (Python) ─────────────────────────────
    {
      name: 'nexus-memory',
      interpreter: memoryInterpreter,
      script: 'packages/memory/src/server.py',
      cwd: NEXUS_BASE,
      env: {
        MEMORY_PORT: '3300',
      },
      max_memory_restart: '500M',
      exp_backoff_restart_delay: 100,
      log_file:   LOGS_DIR + '/nexus-memory.log',
      error_file: LOGS_DIR + '/nexus-memory-error.log',
      out_file:   LOGS_DIR + '/nexus-memory-out.log',
    },

    // ── Nexus MCP Server ──────────────────────────────────
    {
      name: 'nexus-mcp',
      script: 'packages/mcp-server/dist/index.js',
      cwd: NEXUS_BASE,
      env: {
        NODE_ENV: 'production',
        MCP_PORT: '3100',
      },
      max_memory_restart: '500M',
      exp_backoff_restart_delay: 100,
      log_file:   LOGS_DIR + '/nexus-mcp.log',
      error_file: LOGS_DIR + '/nexus-mcp-error.log',
      out_file:   LOGS_DIR + '/nexus-mcp-out.log',
    },
  ],
};
`;
}

/**
 * Write the PM2 ecosystem config to a file.
 */
export function writeEcosystemFile(filePath: string, config: ServiceConfig): void {
  const content = generateEcosystemConfig(config);
  writeFileSync(filePath, content, { encoding: 'utf-8' });
}

// ── Service Management ─────────────────────────────────────────

/**
 * Start PM2 services from the given ecosystem config file.
 * Returns lists of successfully started and failed service names.
 */
export async function startServices(
  ecosystemPath: string,
): Promise<{ started: string[]; failed: string[] }> {
  execSync(`pm2 start ${ecosystemPath}`, {
    stdio: ['pipe', 'pipe', 'pipe'],
    encoding: 'utf-8',
    timeout: 60_000,
  });

  // Wait briefly for services to initialize
  await new Promise(resolve => setTimeout(resolve, 3000));

  // Parse pm2 jlist to verify which services actually started
  const raw = execSync('pm2 jlist', {
    stdio: ['pipe', 'pipe', 'pipe'],
    encoding: 'utf-8',
    timeout: 10_000,
  });

  const processes = JSON.parse(raw) as PM2JsonProcess[];
  const started: string[] = [];
  const failed: string[] = [];

  for (const proc of processes) {
    if (proc.pm2_env.status === 'online') {
      started.push(proc.name);
    } else {
      failed.push(proc.name);
    }
  }

  return { started, failed };
}

/**
 * Stop and delete all PM2 managed services.
 */
export async function stopServices(): Promise<void> {
  try {
    execSync('pm2 delete all', {
      stdio: ['pipe', 'pipe', 'pipe'],
      encoding: 'utf-8',
      timeout: 30_000,
    });
  } catch {
    // pm2 delete all may fail if no processes exist — that's OK
  }
}

// ── Health Verification ────────────────────────────────────────

/**
 * Check TCP connectivity on each service port.
 * Returns health status for each service.
 */
export async function verifyHealth(ports: {
  livos: number;
  api: number;
  mcp: number;
  memory: number;
}): Promise<HealthResult[]> {
  const checks: Array<{ service: string; port: number }> = [
    { service: 'LivOS', port: ports.livos },
    { service: 'Nexus API (core)', port: ports.api },
    { service: 'Nexus MCP', port: ports.mcp },
    { service: 'Nexus Memory', port: ports.memory },
  ];

  const results: HealthResult[] = [];

  for (const check of checks) {
    const healthy = await checkPort(check.port, 5000);
    results.push({
      service: check.service,
      healthy,
      port: check.port,
    });
  }

  return results;
}

function checkPort(port: number, timeoutMs: number): Promise<boolean> {
  return new Promise(resolve => {
    const socket = createConnection({ port, host: '127.0.0.1' });

    const timer = setTimeout(() => {
      socket.destroy();
      resolve(false);
    }, timeoutMs);

    socket.on('connect', () => {
      clearTimeout(timer);
      socket.destroy();
      resolve(true);
    });

    socket.on('error', () => {
      clearTimeout(timer);
      socket.destroy();
      resolve(false);
    });
  });
}
